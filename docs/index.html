<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>cashocs API documentation</title>
<meta name="description" content="cashocs is a Computational Adjoint based SHape optimization and Optimal Control Software for python â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>cashocs</code></h1>
</header>
<section id="section-intro">
<p>cashocs is a Computational Adjoint based SHape optimization and Optimal Control Software for python.</p>
<p>cashocs can be used to treat optimal control and shape optimization
problems constrained by PDEs. It derives the necessary adjoint
equations automatically and implements various solvers for the
problems. cashocs is based on the finite element package FEniCS and
allows the user to define the optimization problems in the
high-level unified form language (UFL).</p>
<h2 id="installation">Installation</h2>
<ul>
<li>
<p>First, install <a href="https://fenicsproject.org/download/">FEniCS</a>, version 2019.1. Note, that FEniCS should be compiled with PETSc and petsc4py.</p>
</li>
<li>
<p>Then, install <a href="https://github.com/nschloe/meshio">meshio</a> with a <a href="https://www.h5py.org">h5py</a> version that matches the hdf5 version used in FEniCS, and <a href="https://matplotlib.org/">matplotlib</a></p>
</li>
</ul>
<p>Note, that if you want to have a <a href="https://docs.conda.io/en/latest/index.html">conda</a> installation, you can simply create a new environment with</p>
<pre><code>conda create -n NAME -c conda-forge fenics=2019 meshio matplotlib
</code></pre>
<p>which automatically installs all prerequisites to get started.</p>
<ul>
<li>
<p>You might also want to install <a href="https://gmsh.info/">GMSH</a>. CASHOCS does not necessarily need this to function properly, but it is required for the remeshing functionality.</p>
</li>
<li>
<p>Clone this repository with git, and run</p>
<pre><code>pip3 install .
</code></pre>
</li>
<li>
<p>Alternatively, you can install CASHOCS via the PYPI</p>
<pre><code>pip3 install cashocs
</code></pre>
</li>
</ul>
<p>You can install the newest (development) version of cashocs with</p>
<pre><code>    pip3 install git+temp_url
</code></pre>
<h2 id="getting-started">Getting Started</h2>
<p>Since cashocs is based on FEniCS, most of the user input consists of definining
the objects (such as the state system and cost functional) via UFL forms. If one
has a functioning code for the forward problem and the evaluation of the cost
functional, the necessary modifications to optimize the problem in cashocs
are minimal. Consider, e.g., the following optimization problem</p>
<p><span><span class="MathJax_Preview"> \min J(y, u) = \frac{1}{2} \int_{\Omega} \lvert y - y_d \rvert^2 \text{d}x + \frac{\alpha}{2} \int_\Omega u^2 \text{d}x \\
\text{ subject to }
\begin{aligned}
- \Delta y &amp;= u \quad \text{ in } \Omega, \\
y &amp;= 0 \quad \text{ on } \Gamma.
\end{aligned}
</span><script type="math/tex; mode=display"> \min J(y, u) = \frac{1}{2} \int_{\Omega} \lvert y - y_d \rvert^2 \text{d}x + \frac{\alpha}{2} \int_\Omega u^2 \text{d}x \\
\text{ subject to }
\begin{aligned}
- \Delta y &= u \quad \text{ in } \Omega, \\
y &= 0 \quad \text{ on } \Gamma.
\end{aligned}
</script></span></p>
<p>Note, that the entire problem is treated in detail in demo_01.py in the demos folder.</p>
<p>For our purposes, we assume that a mesh for this problem is defined and that a
suitable function space is chosen. This can, e.g., be achieved via</p>
<pre><code>from fenics import *
import cashocs

config = cashocs.create_config('path_to_config')
mesh, subdomains, boundaries, dx, ds, dS = cashocs.regular_mesh(25)
V = FunctionSpace(mesh, 'CG', 1)
</code></pre>
<p>The config object which is created from a .ini file is used to determine the
parameters for the optimization algorithms.</p>
<p>To define the state problem, we then define a state variable y, an adjoint variable
p and a control variable u, and write the PDE as a weak form</p>
<pre><code>y = Function(V)
p = Function(V)
u = Function(V)
e = inner(grad(y), grad(p)) - u*p*dx
bcs = cashocs.create_bcs_list(V, Constant(0), boundaries, [1,2,3,4])
</code></pre>
<p>Finally, we have to define the cost functional and the optimization problem</p>
<pre><code>y_d = Expression('sin(2*pi * x[0] * sin(2*pi*x[1]))', degree=1)
alpha = 1e-6
J = 1/2*(y - y_d) * (y - y_d) * dx + alpha/2*u*u*dx
opt_problem = cashocs.OptimalControlProblem(e, bcs, J, y, u, p, config)
opt_problem.solve()
</code></pre>
<p>The only major difference between cashocs and fenics code is that one has to
use Function objects for states and adjoints, and that Trial- and TestFunctions
are not needed to define the state equation. Other than that, the syntax would
also be valid with fenics.</p>
<p>For a detailed discussion of the features of cashocs and its usage we refer to the <a href="#demos">demos</a>.</p>
<h2 id="demos">Demos</h2>
<p>The documentation of the demos can be found <a target="_blank" rel="noopener noreferrer" href="./doc_demos.html">here</a>.</p>
<p>Note, that cashocs was also used to obtain the numerical results for my preprints
<a href="url">Blauth, LeithÃ¤user, and Pinnau, Optimal Control of the Sabatier Process in Microchannel Reactors</a> and <a href="url">Blauth, Nonlinear Conjugate Gradient Methods for PDE Constrained Shape Optimization based on Steklov-Poincare Type Metrics</a></p>
<h2 id="command-line-interface-for-mesh-conversion">Command Line Interface For Mesh Conversion</h2>
<p>cashocs includes a command line interface for converting gmsh mesh files to
xdmf ones, which can be read very easily into fenics. The corresponding command
for the conversion (after having generated a mesh file 'in.msh' with gmsh)
is given by</p>
<pre><code>cashocs-convert in.msh out.xdmf
</code></pre>
<p>This also create .xdmf files for subdomains and boundaries in case they are tagged
in gmsh as Physical quantities.</p>
<h2 id="license">License</h2>
<p>CASHOCS is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>CASHOCS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with CASHOCS.
If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.</p>
<h2 id="contact-about">Contact / About</h2>
<p>I'm Sebastian Blauth, a PhD student at Fraunhofer ITWM and TU Kaiserslautern,
and I developed this project as part of my work. If you have any questions /
suggestions / feedback, etc., you can contact me via
<a href="mailto:sebastian.blauth@itwm.fraunhofer.de">sebastian.blauth@itwm.fraunhofer.de</a>.</p>
<p>Copyright (C) 2020 Sebastian Blauth</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (C) 2020 Sebastian Blauth
#
# This file is part of CASHOCS.
#
# CASHOCS is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CASHOCS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CASHOCS.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

r&#34;&#34;&#34;cashocs is a Computational Adjoint based SHape optimization and Optimal Control Software for python.

cashocs can be used to treat optimal control and shape optimization
problems constrained by PDEs. It derives the necessary adjoint
equations automatically and implements various solvers for the
problems. cashocs is based on the finite element package FEniCS and
allows the user to define the optimization problems in the
high-level unified form language (UFL).

.. include:: ./documentation.md

&#34;&#34;&#34;

from . import verification
from ._optimal_control.optimal_control_problem import OptimalControlProblem
from ._shape_optimization.shape_optimization_problem import ShapeOptimizationProblem
from .geometry import import_mesh, regular_box_mesh, regular_mesh
from .nonlinear_solvers import damped_newton_solve
from .utils import create_bcs_list, create_config



__all__ = [&#39;import_mesh&#39;, &#39;regular_mesh&#39;, &#39;regular_box_mesh&#39;,
                   &#39;damped_newton_solve&#39;, &#39;OptimalControlProblem&#39;, &#39;ShapeOptimizationProblem&#39;,
                   &#39;create_config&#39;, &#39;create_bcs_list&#39;, &#39;verification&#39;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="cashocs.geometry" href="geometry.html">cashocs.geometry</a></code></dt>
<dd>
<div class="desc"><p>Mesh generation and import tools â€¦</p></div>
</dd>
<dt><code class="name"><a title="cashocs.nonlinear_solvers" href="nonlinear_solvers.html">cashocs.nonlinear_solvers</a></code></dt>
<dd>
<div class="desc"><p>Custom solvers for nonlinear equations â€¦</p></div>
</dd>
<dt><code class="name"><a title="cashocs.optimization_problem" href="optimization_problem.html">cashocs.optimization_problem</a></code></dt>
<dd>
<div class="desc"><p>Blueprint for the PDE constrained optimization problems â€¦</p></div>
</dd>
<dt><code class="name"><a title="cashocs.utils" href="utils.html">cashocs.utils</a></code></dt>
<dd>
<div class="desc"><p>Module including utility and helper functions â€¦</p></div>
</dd>
<dt><code class="name"><a title="cashocs.verification" href="verification.html">cashocs.verification</a></code></dt>
<dd>
<div class="desc"><p>This module includes finite difference Taylor tests to verify the computed gradients.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cashocs.create_bcs_list"><code class="name flex">
<span>def <span class="ident">create_bcs_list</span></span>(<span>function_space, value, boundaries, idcs, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create several Dirichlet boundary conditions at once.</p>
<p>Wraps multiple Dirichlet boundary conditions into a list, in case
they have the same value but are to be defined for multiple boundaries
with different markers. Particularly useful for defining homogeneous
boundary conditions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>function_space</code></strong> :&ensp;<code>dolfin.function.functionspace.FunctionSpace</code></dt>
<dd>The function space onto which the BCs should be imposed on.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>dolfin.function.constant.Constant</code> or <code>dolfin.function.expression.Expression</code> or <code>dolfin.function.function.Function</code> or <code>float</code> or <code>tuple(float)</code></dt>
<dd>The value of the boundary condition. Has to be compatible with the function_space,
so that it could also be used as DirichletBC(function_space, value, &hellip;).</dd>
<dt><strong><code>boundaries</code></strong> :&ensp;<code>dolfin.cpp.mesh.MeshFunctionSizet</code></dt>
<dd>The MeshFunction object representing the boundaries.</dd>
<dt><strong><code>idcs</code></strong> :&ensp;<code>list[int]</code> or <code>int</code></dt>
<dd>A list of indices / boundary markers that determine the boundaries
onto which the Dirichlet boundary conditions should be applied to.
Can also be a single integer for a single boundary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[dolfin.fem.dirichletbc.DirichletBC]</code></dt>
<dd>A list of DirichletBC objects that represent the boundary conditions.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Generate homogeneous Dirichlet boundary conditions for all 4 sides of the unit square.</p>
<pre><code>from fenics import *
import cashocs

mesh, _, _, _, _, _ = cashocs.regular_mesh(25)
V = FunctionSpace(mesh, 'CG', 1)
bcs = cashocs.create_bcs_list(V, Constant(0), boundaries, [1,2,3,4])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_bcs_list(function_space, value, boundaries, idcs, **kwargs):
        &#34;&#34;&#34;Create several Dirichlet boundary conditions at once.

        Wraps multiple Dirichlet boundary conditions into a list, in case
        they have the same value but are to be defined for multiple boundaries
        with different markers. Particularly useful for defining homogeneous
        boundary conditions.

        Parameters
        ----------
        function_space : dolfin.function.functionspace.FunctionSpace
                The function space onto which the BCs should be imposed on.
        value : dolfin.function.constant.Constant or dolfin.function.expression.Expression or dolfin.function.function.Function or float or tuple(float)
                The value of the boundary condition. Has to be compatible with the function_space,
                so that it could also be used as DirichletBC(function_space, value, ...).
        boundaries : dolfin.cpp.mesh.MeshFunctionSizet
                The MeshFunction object representing the boundaries.
        idcs : list[int] or int
                A list of indices / boundary markers that determine the boundaries
                onto which the Dirichlet boundary conditions should be applied to.
                Can also be a single integer for a single boundary.

        Returns
        -------
        list[dolfin.fem.dirichletbc.DirichletBC]
                A list of DirichletBC objects that represent the boundary conditions.

        Examples
        --------
        Generate homogeneous Dirichlet boundary conditions for all 4 sides of the unit square.

            from fenics import *
            import cashocs

            mesh, _, _, _, _, _ = cashocs.regular_mesh(25)
            V = FunctionSpace(mesh, &#39;CG&#39;, 1)
            bcs = cashocs.create_bcs_list(V, Constant(0), boundaries, [1,2,3,4])
        &#34;&#34;&#34;

        bcs_list = []
        if type(idcs) == list:
                for i in idcs:
                        bcs_list.append(fenics.DirichletBC(function_space, value, boundaries, i, **kwargs))

        elif type(idcs) == int:
                bcs_list.append(fenics.DirichletBC(function_space, value, boundaries, idcs, **kwargs))

        return bcs_list</code></pre>
</details>
</dd>
<dt id="cashocs.create_config"><code class="name flex">
<span>def <span class="ident">create_config</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a config object from a config file.</p>
<p>Creates the config from a .ini file via the
configparser package.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the config .ini file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>configparser.ConfigParser</code></dt>
<dd>The output config file, which includes the path
to the .ini file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_config(path):
        &#34;&#34;&#34;Generates a config object from a config file.

        Creates the config from a .ini file via the
        configparser package.

        Parameters
        ----------
        path : str
                The path to the config .ini file.

        Returns
        -------
        configparser.ConfigParser
                The output config file, which includes the path
                to the .ini file.
        &#34;&#34;&#34;

        config = configparser.ConfigParser()
        config.read(path)

        return config</code></pre>
</details>
</dd>
<dt id="cashocs.damped_newton_solve"><code class="name flex">
<span>def <span class="ident">damped_newton_solve</span></span>(<span>F, u, bcs, rtol=1e-10, atol=1e-10, max_iter=50, convergence_type='combined', norm_type='l2', damped=True, verbose=True, ksp=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A damped Newton method for solving nonlinear equations.</p>
<p>The Newton method is based on the natural monotonicity test from Deuflhard [1].
It also allows fine tuning via a direct interface, and absolute, relative,
and combined stopping criteria. Can also be used to specify the solver for
the inner (linear) subproblems via petsc ksps.</p>
<p>The method terminates after <code>max_iter</code> iterations, or if a termination criterion is
satisfied. These criteria are given by
<span><span class="MathJax_Preview"> \lvert\lvert F_{k} \rvert\rvert \leq \texttt{rtol} \lvert\lvert F_0 \rvert\rvert \quad \text{ if convergence_type is 'rel'} \\
\lvert\lvert F_{k} \rvert\rvert \leq \texttt{atol} \quad \text{ if convergence_type is 'abs'} \\
\lvert\lvert F_{k} \rvert\rvert \leq \texttt{atol} + \text{rtol} \lvert\lvert F_0 \rvert\rvert \quad \text{ if convergence_type is 'combined'}
</span><script type="math/tex; mode=display"> \lvert\lvert F_{k} \rvert\rvert \leq \texttt{rtol} \lvert\lvert F_0 \rvert\rvert \quad \text{ if convergence_type is 'rel'} \\
\lvert\lvert F_{k} \rvert\rvert \leq \texttt{atol} \quad \text{ if convergence_type is 'abs'} \\
\lvert\lvert F_{k} \rvert\rvert \leq \texttt{atol} + \text{rtol} \lvert\lvert F_0 \rvert\rvert \quad \text{ if convergence_type is 'combined'}
</script></span>
The norm chosen for the termination criterion is specified via <code>norm_type</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>F</code></strong> :&ensp;<code>ufl.form.Form</code></dt>
<dd>The variational form of the nonlinear problem to be solved by Newton's method.</dd>
<dt><strong><code>u</code></strong> :&ensp;<code>dolfin.function.function.Function</code></dt>
<dd>The sought solution / initial guess. It is not assumed that the initial guess
satisfies the Dirichlet boundary conditions, they are applied automatically.
The method overwrites / updates this Function.</dd>
<dt><strong><code>bcs</code></strong> :&ensp;<code>list[dolfin.fem.dirichletbc.DirichletBC]</code></dt>
<dd>A list of DirichletBCs for the nonlinear variational problem.</dd>
<dt><strong><code>rtol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Relative tolerance of the solver if convergence_type is either 'combined' or 'rel'
(default is <code>rtol</code> = 1e-10).</dd>
<dt><strong><code>atol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Absolute tolerance of the solver if convergence_type is either 'combined' or 'abs'
(default is atol = 1e-10).</dd>
<dt><strong><code>max_iter</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of iterations carried out by the method
(default is max_iter = 50).</dd>
<dt><strong><code>convergence_type</code></strong> :&ensp;<code>{'combined', 'rel', 'abs'}</code></dt>
<dd>Determines the type of stopping criterion that is used.</dd>
<dt><strong><code>norm_type</code></strong> :&ensp;<code>{'l2', 'linf'}</code></dt>
<dd>Determines which norm is used in the stopping criterion.</dd>
<dt><strong><code>damped</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, then a damping strategy is used. If false, the classical
Newton-Raphson iteration (without damping) is used (default is True).</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, prints status of the iteration to the console (default
is true).</dd>
<dt><strong><code>ksp</code></strong> :&ensp;<code>petsc4py.PETSc.KSP</code>, optional</dt>
<dd>The PETSc ksp object used to solve the inner (linear) problem
if this is None it uses the direct solver MUMPS (default is
None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dolfin.function.function.Function</code></dt>
<dd>The solution of the nonlinear variational problem, if converged.
This overrides the input function u.</dd>
</dl>
<h2 id="references">References</h2>
<p>[1] P. Deuflhard, "Newton methods for nonlinear problems", Springer,
Heidelberg, 2011, <a href="https://doi.org/10.1007/978-3-642-23899-4">https://doi.org/10.1007/978-3-642-23899-4</a></p>
<h2 id="examples">Examples</h2>
<p>This example solves the problem</p>
<p><span><span class="MathJax_Preview"> - \Delta u + u^3 = 1 \quad \text{ in } \Omega=(0,1)^2 \\
u = 0 \quad \text{ on } \Gamma.
</span><script type="math/tex; mode=display"> - \Delta u + u^3 = 1 \quad \text{ in } \Omega=(0,1)^2 \\
u = 0 \quad \text{ on } \Gamma.
</script></span></p>
<pre><code>from fenics import *
import cashocs

mesh, _, boundaries, dx, _, _ = cashocs.regular_mesh(25)
V = FunctionSpace(mesh, 'CG', 1)

u = Function(V)
v = TestFunction(V)
F = inner(grad(u), grad(v))*dx + pow(u,3)*v*dx - Constant(1)*v*dx
bcs = cashocs.create_bcs_list(V, Constant(0.0), boundaries, [1,2,3,4])
cashocs.damped_newton_solve(F, u, bcs)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def damped_newton_solve(F, u, bcs, rtol=1e-10, atol=1e-10, max_iter=50, convergence_type=&#39;combined&#39;, norm_type=&#39;l2&#39;,
                                                damped=True, verbose=True, ksp=None):
        r&#34;&#34;&#34;A damped Newton method for solving nonlinear equations.

        The Newton method is based on the natural monotonicity test from Deuflhard [1].
        It also allows fine tuning via a direct interface, and absolute, relative,
        and combined stopping criteria. Can also be used to specify the solver for
        the inner (linear) subproblems via petsc ksps.

        The method terminates after `max_iter` iterations, or if a termination criterion is
        satisfied. These criteria are given by
        $$ \lvert\lvert F_{k} \rvert\rvert \leq \texttt{rtol} \lvert\lvert F_0 \rvert\rvert \quad \text{ if convergence_type is &#39;rel&#39;} \\
        \lvert\lvert F_{k} \rvert\rvert \leq \texttt{atol} \quad \text{ if convergence_type is &#39;abs&#39;} \\
        \lvert\lvert F_{k} \rvert\rvert \leq \texttt{atol} + \text{rtol} \lvert\lvert F_0 \rvert\rvert \quad \text{ if convergence_type is &#39;combined&#39;}
        $$
        The norm chosen for the termination criterion is specified via `norm_type`.

        Parameters
        ----------
        F : ufl.form.Form
                The variational form of the nonlinear problem to be solved by Newton&#39;s method.
        u : dolfin.function.function.Function
                The sought solution / initial guess. It is not assumed that the initial guess
                satisfies the Dirichlet boundary conditions, they are applied automatically.
                The method overwrites / updates this Function.
        bcs : list[dolfin.fem.dirichletbc.DirichletBC]
                A list of DirichletBCs for the nonlinear variational problem.
        rtol : float, optional
                Relative tolerance of the solver if convergence_type is either &#39;combined&#39; or &#39;rel&#39;
                (default is `rtol` = 1e-10).
        atol : float, optional
                Absolute tolerance of the solver if convergence_type is either &#39;combined&#39; or &#39;abs&#39;
                (default is atol = 1e-10).
        max_iter : int, optional
                Maximum number of iterations carried out by the method
                (default is max_iter = 50).
        convergence_type : {&#39;combined&#39;, &#39;rel&#39;, &#39;abs&#39;}
                Determines the type of stopping criterion that is used.
        norm_type : {&#39;l2&#39;, &#39;linf&#39;}
                Determines which norm is used in the stopping criterion.
        damped : bool, optional
                If true, then a damping strategy is used. If false, the classical
                Newton-Raphson iteration (without damping) is used (default is True).
        verbose : bool, optional
                If true, prints status of the iteration to the console (default
                is true).
        ksp : petsc4py.PETSc.KSP, optional
                The PETSc ksp object used to solve the inner (linear) problem
                if this is None it uses the direct solver MUMPS (default is
                None).

        Returns
        -------
        dolfin.function.function.Function
                The solution of the nonlinear variational problem, if converged.
                This overrides the input function u.

        References
        ----------
        [1] P. Deuflhard, &#34;Newton methods for nonlinear problems&#34;, Springer,
        Heidelberg, 2011, https://doi.org/10.1007/978-3-642-23899-4

        Examples
        --------
        This example solves the problem

        $$ - \Delta u + u^3 = 1 \quad \text{ in } \Omega=(0,1)^2 \\
        u = 0 \quad \text{ on } \Gamma.
        $$

            from fenics import *
            import cashocs

            mesh, _, boundaries, dx, _, _ = cashocs.regular_mesh(25)
            V = FunctionSpace(mesh, &#39;CG&#39;, 1)

            u = Function(V)
            v = TestFunction(V)
            F = inner(grad(u), grad(v))*dx + pow(u,3)*v*dx - Constant(1)*v*dx
            bcs = cashocs.create_bcs_list(V, Constant(0.0), boundaries, [1,2,3,4])
            cashocs.damped_newton_solve(F, u, bcs)
        &#34;&#34;&#34;
        
        if not convergence_type in [&#39;rel&#39;, &#39;abs&#39;, &#39;combined&#39;]:
                raise InputError(&#39;cashocs.nonlinear_solvers.damped_newton_solve&#39;, &#39;convergence_type&#39;, &#39;Input convergence_type has to be one of \&#39;rel\&#39;, \&#39;abs\&#39;, or \&#39;combined\&#39;.&#39;)
        
        if not norm_type in [&#39;l2&#39;, &#39;linf&#39;]:
                raise InputError(&#39;cashocs.nonlinear_solvers.damped_newton_solve&#39;, &#39;norm_type&#39;, &#39;Input norm_type has to be one of \&#39;l2\&#39; or \&#39;linf\&#39;.&#39;)

        # create the PETSc ksp
        if ksp is None:
                options = [[
                        [&#39;ksp_type&#39;, &#39;preonly&#39;],
                        [&#39;pc_type&#39;, &#39;lu&#39;],
                        [&#39;pc_factor_mat_solver_type&#39;, &#39;mumps&#39;],
                        [&#39;mat_mumps_icntl_24&#39;, 1]
                ]]

                ksp = PETSc.KSP().create()
                _setup_petsc_options([ksp], options)
                ksp.setFromOptions()

        # Calculate the Jacobian.
        dF = fenics.derivative(F, u)

        # Setup increment and function for monotonicity test
        V = u.function_space()
        du = fenics.Function(V)
        ddu = fenics.Function(V)
        u_save = fenics.Function(V)
        
        iterations = 0
        
        [bc.apply(u.vector()) for bc in bcs]
        # copy the boundary conditions and homogenize them for the increment
        bcs_hom = [fenics.DirichletBC(bc) for bc in bcs]
        [bc.homogenize() for bc in bcs_hom]

        assembler = fenics.SystemAssembler(dF, -F, bcs_hom)
        assembler.keep_diagonal = True
        A_fenics = fenics.PETScMatrix()
        residuum = fenics.PETScVector()

        # Compute the initial residual
        assembler.assemble(A_fenics, residuum)
        A_fenics.ident_zeros()
        A = fenics.as_backend_type(A_fenics).mat()
        b = fenics.as_backend_type(residuum).vec()
        
        res_0 = residuum.norm(norm_type)
        if res_0 == 0.0:
                if verbose:
                        print(&#39;Residual vanishes, input is already a solution.&#39;)
                return u

        res = res_0
        if verbose:
                print(&#39;Newton Iteration &#39; + format(iterations, &#39;2d&#39;) + &#39; - residuum (abs):  &#39;
                          + format(res, &#39;.3e&#39;) + &#39; (tol = &#39; + format(atol, &#39;.3e&#39;) + &#39;)    residuum (rel): &#39;
                          + format(res/res_0, &#39;.3e&#39;) + &#39; (tol = &#39; + format(rtol, &#39;.3e&#39;) + &#39;)&#39;)
        
        if convergence_type == &#39;abs&#39;:
                tol = atol
        elif convergence_type == &#39;rel&#39;:
                tol = rtol*res_0
        else:
                tol = rtol*res_0 + atol

        # While loop until termination
        while res &gt; tol and iterations &lt; max_iter:
                iterations += 1
                lmbd = 1.0
                breakdown = False
                u_save.vector()[:] = u.vector()[:]

                # Solve the inner problem
                _solve_linear_problem(ksp, A, b, du.vector().vec())

                # perform backtracking in case damping is used
                if damped:
                        while True:
                                u.vector()[:] += lmbd*du.vector()[:]
                                assembler.assemble(residuum)
                                b = fenics.as_backend_type(residuum).vec()
                                _solve_linear_problem(ksp=ksp, b=b, x=ddu.vector().vec())

                                if ddu.vector().norm(norm_type)/du.vector().norm(norm_type) &lt;= 1:
                                        break
                                else:
                                        u.vector()[:] = u_save.vector()[:]
                                        lmbd /= 2
                                
                                if lmbd &lt; 1e-6:
                                        breakdown = True
                                        break
                
                else:
                        u.vector()[:] += du.vector()[:]
                
                if breakdown:
                        raise NotConvergedError(&#39;Damped Newton Solver Breakdown, stepsize for increment too low.&#39;)

                if iterations == max_iter:
                        raise NotConvergedError(&#39;Newton Solver exceeded maximum number of iterations.&#39;)

                # compute the new residual
                assembler.assemble(A_fenics, residuum)
                A_fenics.ident_zeros()
                A = fenics.as_backend_type(A_fenics).mat()
                b = fenics.as_backend_type(residuum).vec()

                [bc.apply(residuum) for bc in bcs_hom]
                
                res = residuum.norm(norm_type)
                if verbose:
                        print(&#39;Newton Iteration &#39; + format(iterations, &#39;2d&#39;) + &#39; - residuum (abs):  &#39;
                                  + format(res, &#39;.3e&#39;) + &#39; (tol = &#39; + format(atol, &#39;.3e&#39;) + &#39;)    residuum (rel): &#39;
                                  + format(res/res_0, &#39;.3e&#39;) + &#39; (tol = &#39; + format(rtol, &#39;.3e&#39;) + &#39;)&#39;)
                
                if res &lt; tol:
                        if verbose:
                                print(&#39;&#39;)
                                print(&#39;Newton Solver converged after &#39; + str(iterations) + &#39; iterations.&#39;)
                        break
        
        return u</code></pre>
</details>
</dd>
<dt id="cashocs.import_mesh"><code class="name flex">
<span>def <span class="ident">import_mesh</span></span>(<span>arg)</span>
</code></dt>
<dd>
<div class="desc"><p>Imports a mesh file for use with cashocs / fenics.</p>
<p>This function imports a mesh file that was generated by GMSH and converted to
.xdmf with the command line function cashocs-convert (see cashocs main documentation).
The syntax for the conversion is</p>
<pre><code>cashocs-convert in.msh out.xdmf
</code></pre>
<p>If there are Physical quantities specified in the gmsh file, these are imported
to the subdomains and boundaries output of this function and can also be directly
accessed via the measures, e.g., with dx(1), ds(1), etc.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arg</code></strong> :&ensp;<code>str</code> or <code>configparser.ConfigParser</code></dt>
<dd>This is either a string, in which case it corresponds to the location
of the mesh file in .xdmf file format, or a config file that
has this path stored in its settings.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>dolfin.cpp.mesh.Mesh</code></dt>
<dd>The imported (computational) mesh.</dd>
<dt><strong><code>subdomains</code></strong> :&ensp;<code>dolfin.cpp.mesh.MeshFunctionSizet</code></dt>
<dd>A MeshFunction object containing the subdomains,
i.e., the Physical regions marked in the gmsh
file.</dd>
<dt><strong><code>boundaries</code></strong> :&ensp;<code>dolfin.cpp.mesh.MeshFunctionSizet</code></dt>
<dd>A MeshFunction object containing the boundaries,
i.e., the Physical regions marked in the gmsh
file. Can, e.g., be used to set up boundary
conditions.</dd>
<dt><strong><code>dx</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>The volume measure of the mesh corresponding to
the subdomains (i.e. gmsh Physical region indices).</dd>
<dt><strong><code>ds</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>The surface measure of the mesh corresponding to
the boundaries (i.e. gmsh Physical region indices).</dd>
<dt><strong><code>dS</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>The interior facet measure of the mesh corresponding
to boundaries (i.e. gmsh Physical region indices).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_mesh(arg):
        &#34;&#34;&#34;Imports a mesh file for use with cashocs / fenics.

        This function imports a mesh file that was generated by GMSH and converted to
        .xdmf with the command line function cashocs-convert (see cashocs main documentation).
        The syntax for the conversion is

            cashocs-convert in.msh out.xdmf

        If there are Physical quantities specified in the gmsh file, these are imported
        to the subdomains and boundaries output of this function and can also be directly
        accessed via the measures, e.g., with dx(1), ds(1), etc.

        Parameters
        ----------
        arg : str or configparser.ConfigParser
                This is either a string, in which case it corresponds to the location
                of the mesh file in .xdmf file format, or a config file that
                has this path stored in its settings.

        Returns
        -------
        mesh : dolfin.cpp.mesh.Mesh
                The imported (computational) mesh.
        subdomains : dolfin.cpp.mesh.MeshFunctionSizet
                A MeshFunction object containing the subdomains,
                i.e., the Physical regions marked in the gmsh
                file.
        boundaries : dolfin.cpp.mesh.MeshFunctionSizet
                A MeshFunction object containing the boundaries,
                i.e., the Physical regions marked in the gmsh
                file. Can, e.g., be used to set up boundary
                conditions.
        dx : ufl.measure.Measure
                The volume measure of the mesh corresponding to
                the subdomains (i.e. gmsh Physical region indices).
        ds : ufl.measure.Measure
                The surface measure of the mesh corresponding to
                the boundaries (i.e. gmsh Physical region indices).
        dS : ufl.measure.Measure
                The interior facet measure of the mesh corresponding
                to boundaries (i.e. gmsh Physical region indices).
        &#34;&#34;&#34;
        
        start_time = time.time()
        print(&#39;Importing mesh to FEniCS&#39;)
        # Check for the file format

        if type(arg) == str:
                mesh_file = arg
                mesh_attribute = &#39;str&#39;
        elif type(arg) == configparser.ConfigParser:
                mesh_attribute = &#39;config&#39;
                ### overloading for remeshing
                if not arg.getboolean(&#39;Mesh&#39;, &#39;remesh&#39;, fallback=False):
                        mesh_file = arg.get(&#39;Mesh&#39;, &#39;mesh_file&#39;)
                else:
                        if not (&#39;_cashocs_remesh_flag&#39; in sys.argv):
                                mesh_file = arg.get(&#39;Mesh&#39;, &#39;mesh_file&#39;)
                        else:
                                temp_dir = sys.argv[-1]
                                with open(temp_dir + &#39;/temp_dict.json&#39;, &#39;r&#39;) as file:
                                        temp_dict = json.load(file)
                                mesh_file = temp_dict[&#39;mesh_file&#39;]

        else:
                raise InputError(&#39;cashocs.geometry.import_mesh&#39;, &#39;arg&#39;, &#39;Not a valid argument for import_mesh. Has to be either a path to a mesh file (str) or a config.&#39;)

        if mesh_file[-5:] == &#39;.xdmf&#39;:
                file_string = mesh_file[:-5]
        else:
                raise InputError(&#39;cashocs.geometry.import_mesh&#39;, &#39;arg&#39;, &#39;Not a suitable mesh file format. Has to end in .xdmf.&#39;)
        
        mesh = fenics.Mesh()
        xdmf_file = fenics.XDMFFile(mesh.mpi_comm(), mesh_file)
        xdmf_file.read(mesh)
        xdmf_file.close()
        
        subdomains_mvc = fenics.MeshValueCollection(&#39;size_t&#39;, mesh, mesh.geometric_dimension())
        boundaries_mvc = fenics.MeshValueCollection(&#39;size_t&#39;, mesh, mesh.geometric_dimension() - 1)

        if os.path.exists(file_string + &#39;_subdomains.xdmf&#39;):
                xdmf_subdomains = fenics.XDMFFile(mesh.mpi_comm(), file_string + &#39;_subdomains.xdmf&#39;)
                xdmf_subdomains.read(subdomains_mvc, &#39;subdomains&#39;)
                xdmf_subdomains.close()
        if os.path.exists(file_string + &#39;_boundaries.xdmf&#39;):
                xdmf_boundaries = fenics.XDMFFile(mesh.mpi_comm(), file_string + &#39;_boundaries.xdmf&#39;)
                xdmf_boundaries.read(boundaries_mvc, &#39;boundaries&#39;)
                xdmf_boundaries.close()

        subdomains = fenics.MeshFunction(&#39;size_t&#39;, mesh, subdomains_mvc)
        boundaries = fenics.MeshFunction(&#39;size_t&#39;, mesh, boundaries_mvc)

        dx = fenics.Measure(&#39;dx&#39;, domain=mesh, subdomain_data=subdomains)
        ds = fenics.Measure(&#39;ds&#39;, domain=mesh, subdomain_data=boundaries)
        dS = fenics.Measure(&#39;dS&#39;, domain=mesh, subdomain_data=boundaries)
        
        end_time = time.time()
        print(&#39;Done Importing Mesh. Elapsed Time: &#39; + format(end_time - start_time, &#39;.3e&#39;) + &#39; s&#39;)
        print(&#39;&#39;)

        # Add an attribute to the mesh to show with what procedure it was generated
        mesh._cashocs_generator = mesh_attribute

        return mesh, subdomains, boundaries, dx, ds, dS</code></pre>
</details>
</dd>
<dt id="cashocs.regular_box_mesh"><code class="name flex">
<span>def <span class="ident">regular_box_mesh</span></span>(<span>n=10, S_x=0.0, S_y=0.0, S_z=None, E_x=1.0, E_y=1.0, E_z=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a mesh corresponding to a rectangle or cube.</p>
<p>This function creates a uniform mesh of either a rectangle
or a cube, with specified start (S_) and end points (E_).
The resulting mesh uses n elements along the shortest direction
and accordingly many along the longer ones. The resulting domain is</p>
<p><span><span class="MathJax_Preview">[S_x, E_x] \times [S_y, E_y] \phantom{ \times [S_z, E_z] a} \quad \text{ in } 2D, \\
[S_x, E_x] \times [S_y, E_y] \times [S_z, E_z] \quad \text{ in } 3D.
</span><script type="math/tex; mode=display">[S_x, E_x] \times [S_y, E_y] \phantom{ \times [S_z, E_z] a} \quad \text{ in } 2D, \\
[S_x, E_x] \times [S_y, E_y] \times [S_z, E_z] \quad \text{ in } 3D.
</script></span></p>
<p>The boundary markers are ordered as follows:</p>
<ul>
<li>
<p>1 corresponds to <span><span class="MathJax_Preview">\{x=S_x\}</span><script type="math/tex">\{x=S_x\}</script></span>.</p>
</li>
<li>
<p>2 corresponds to <span><span class="MathJax_Preview">\{x=E_x\}</span><script type="math/tex">\{x=E_x\}</script></span>.</p>
</li>
<li>
<p>3 corresponds to <span><span class="MathJax_Preview">\{y=S_y\}</span><script type="math/tex">\{y=S_y\}</script></span>.</p>
</li>
<li>
<p>4 corresponds to <span><span class="MathJax_Preview">\{y=E_y\}</span><script type="math/tex">\{y=E_y\}</script></span>.</p>
</li>
<li>
<p>5 corresponds to <span><span class="MathJax_Preview">\{z=S_z\}</span><script type="math/tex">\{z=S_z\}</script></span> (only in 3D).</p>
</li>
<li>
<p>6 corresponds to <span><span class="MathJax_Preview">\{z=E_z\}</span><script type="math/tex">\{z=E_z\}</script></span> (only in 3D).</p>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of elements in the shortest coordinate direction.</dd>
<dt><strong><code>S_x</code></strong> :&ensp;<code>float</code></dt>
<dd>Start of the x-interval.</dd>
<dt><strong><code>S_y</code></strong> :&ensp;<code>float</code></dt>
<dd>Start of the y-interval.</dd>
<dt><strong><code>S_z</code></strong> :&ensp;<code>float</code> or <code>None</code>, optional</dt>
<dd>Start of the z-interval, mesh is 2D if this is None
(default is None).</dd>
<dt><strong><code>E_x</code></strong> :&ensp;<code>float</code></dt>
<dd>End of the x-interval.</dd>
<dt><strong><code>E_y</code></strong> :&ensp;<code>float</code></dt>
<dd>End of the y-interval.</dd>
<dt><strong><code>E_z</code></strong> :&ensp;<code>float</code> or <code>None</code>, optional</dt>
<dd>End of the z-interval, mesh is 2D if this is None
(default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>dolfin.cpp.mesh.Mesh</code></dt>
<dd>the computational mesh</dd>
<dt><strong><code>subdomains</code></strong> :&ensp;<code>dolfin.cpp.mesh.MeshFunctionSizet</code></dt>
<dd>a MeshFunction object containing the subdomains</dd>
<dt><strong><code>boundaries</code></strong> :&ensp;<code>dolfin.cpp.mesh.MeshFunctionSizet</code></dt>
<dd>a MeshFunction object containing the boundaries</dd>
<dt><strong><code>dx</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>the volume measure of the mesh corresponding to subdomains</dd>
<dt><strong><code>ds</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>the surface measure of the mesh corresponding to boundaries</dd>
<dt><strong><code>dS</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>the interior facet measure of the mesh corresponding to boundaries</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regular_box_mesh(n=10, S_x=0.0, S_y=0.0, S_z=None, E_x=1.0, E_y=1.0, E_z=None):
        r&#34;&#34;&#34;Creates a mesh corresponding to a rectangle or cube.

        This function creates a uniform mesh of either a rectangle
        or a cube, with specified start (S_) and end points (E_).
        The resulting mesh uses n elements along the shortest direction
        and accordingly many along the longer ones. The resulting domain is

        $$[S_x, E_x] \times [S_y, E_y] \phantom{ \times [S_z, E_z] a} \quad \text{ in } 2D, \\
        [S_x, E_x] \times [S_y, E_y] \times [S_z, E_z] \quad \text{ in } 3D.
        $$

        The boundary markers are ordered as follows:

          - 1 corresponds to \(\{x=S_x\}\).

          - 2 corresponds to \(\{x=E_x\}\).

          - 3 corresponds to \(\{y=S_y\}\).

          - 4 corresponds to \(\{y=E_y\}\).

          - 5 corresponds to \(\{z=S_z\}\) (only in 3D).

          - 6 corresponds to \(\{z=E_z\}\) (only in 3D).

        Parameters
        ----------
        n : int
                Number of elements in the shortest coordinate direction.
        S_x : float
                Start of the x-interval.
        S_y : float
                Start of the y-interval.
        S_z : float or None, optional
                Start of the z-interval, mesh is 2D if this is None
                (default is None).
        E_x : float
                End of the x-interval.
        E_y : float
                End of the y-interval.
        E_z : float or None, optional
                End of the z-interval, mesh is 2D if this is None
                (default is None).

        Returns
        -------
        mesh : dolfin.cpp.mesh.Mesh
                the computational mesh
        subdomains : dolfin.cpp.mesh.MeshFunctionSizet
                a MeshFunction object containing the subdomains
        boundaries : dolfin.cpp.mesh.MeshFunctionSizet
                a MeshFunction object containing the boundaries
        dx : ufl.measure.Measure
                the volume measure of the mesh corresponding to subdomains
        ds : ufl.measure.Measure
                the surface measure of the mesh corresponding to boundaries
        dS : ufl.measure.Measure
                the interior facet measure of the mesh corresponding to boundaries
        &#34;&#34;&#34;

        n = int(n)
        
        if not S_x &lt; E_x:
                raise InputError(&#39;cashocs.geometry.regular_box_mesh&#39;, &#39;S_x&#39;, &#39;Incorrect input for the x-coordinate. S_x has to be smaller than E_x.&#39;)
        if not S_y &lt; E_y:
                raise InputError(&#39;cashocs.geometry.regular_box_mesh&#39;, &#39;S_y&#39;, &#39;Incorrect input for the y-coordinate. S_y has to be smaller than E_y.&#39;)
        if not ((S_z is None and E_z is None) or (S_z &lt; E_z)):
                raise InputError(&#39;cashocs.geometry.regular_box_mesh&#39;, &#39;S_z&#39;, &#39;Incorrect input for the z-coordinate. S_z has to be smaller than E_z, or only one of them is specified.&#39;)

        if S_z is None:
                lx = E_x - S_x
                ly = E_y - S_y
                sizes = [lx, ly]
                dim = 2
        else:
                lx = E_x - S_x
                ly = E_y - S_y
                lz = E_z - S_z
                sizes = [lx, ly, lz]
                dim = 3

        size_min = np.min(sizes)
        num_points = [int(np.round(length/size_min*n)) for length in sizes]

        if S_z is None:
                mesh = fenics.RectangleMesh(fenics.Point(S_x, S_y), fenics.Point(E_x, E_y), num_points[0], num_points[1])
        else:
                mesh = fenics.BoxMesh(fenics.Point(S_x, S_y, S_z), fenics.Point(E_x, E_y, E_z), num_points[0], num_points[1], num_points[2])

        subdomains = fenics.MeshFunction(&#39;size_t&#39;, mesh, dim=dim)
        boundaries = fenics.MeshFunction(&#39;size_t&#39;, mesh, dim=dim - 1)

        x_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[0], sx, tol)&#39;, tol=fenics.DOLFIN_EPS, sx=S_x)
        x_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[0], ex, tol)&#39;, tol=fenics.DOLFIN_EPS, ex=E_x)
        x_min.mark(boundaries, 1)
        x_max.mark(boundaries, 2)

        y_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[1], sy, tol)&#39;, tol=fenics.DOLFIN_EPS, sy=S_y)
        y_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[1], ey, tol)&#39;, tol=fenics.DOLFIN_EPS, ey=E_y)
        y_min.mark(boundaries, 3)
        y_max.mark(boundaries, 4)

        if S_z is not None:
                z_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[2], sz, tol)&#39;, tol=fenics.DOLFIN_EPS, sz=S_z)
                z_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[2], ez, tol)&#39;, tol=fenics.DOLFIN_EPS, ez=E_z)
                z_min.mark(boundaries, 5)
                z_max.mark(boundaries, 6)

        dx = fenics.Measure(&#39;dx&#39;, mesh, subdomain_data=subdomains)
        ds = fenics.Measure(&#39;ds&#39;, mesh, subdomain_data=boundaries)
        dS = fenics.Measure(&#39;dS&#39;, mesh)

        return mesh, subdomains, boundaries, dx, ds, dS</code></pre>
</details>
</dd>
<dt id="cashocs.regular_mesh"><code class="name flex">
<span>def <span class="ident">regular_mesh</span></span>(<span>n=10, L_x=1.0, L_y=1.0, L_z=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a mesh corresponding to a rectangle or cube.</p>
<p>This function creates a uniform mesh of either a rectangle
or a cube, starting at the origin and having length specified
in lx, lx, lz. The resulting mesh uses n elements along the
shortest direction and accordingly many along the longer ones.
The resulting domain is
<span><span class="MathJax_Preview">[0, L_x] \times [0, L_y] \phantom{ \times [0, L_z] a} \quad \text{ in } 2D, \\
[0, L_x] \times [0, L_y] \times [0, L_z] \quad \text{ in } 3D.
</span><script type="math/tex; mode=display">[0, L_x] \times [0, L_y] \phantom{ \times [0, L_z] a} \quad \text{ in } 2D, \\
[0, L_x] \times [0, L_y] \times [0, L_z] \quad \text{ in } 3D.
</script></span></p>
<p>The boundary markers are ordered as follows:</p>
<ul>
<li>
<p>1 corresponds to <span><span class="MathJax_Preview">\{x=0\}</span><script type="math/tex">\{x=0\}</script></span>.</p>
</li>
<li>
<p>2 corresponds to <span><span class="MathJax_Preview">\{x=L_x\}</span><script type="math/tex">\{x=L_x\}</script></span>.</p>
</li>
<li>
<p>3 corresponds to <span><span class="MathJax_Preview">\{y=0\}</span><script type="math/tex">\{y=0\}</script></span>.</p>
</li>
<li>
<p>4 corresponds to <span><span class="MathJax_Preview">\{y=L_y\}</span><script type="math/tex">\{y=L_y\}</script></span>.</p>
</li>
<li>
<p>5 corresponds to <span><span class="MathJax_Preview">\{z=0\}</span><script type="math/tex">\{z=0\}</script></span> (only in 3D).</p>
</li>
<li>
<p>6 corresponds to <span><span class="MathJax_Preview">\{z=L_z\}</span><script type="math/tex">\{z=L_z\}</script></span> (only in 3D).</p>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of elements in the shortest coordinate direction.</dd>
<dt><strong><code>L_x</code></strong> :&ensp;<code>float</code></dt>
<dd>Length in x-direction.</dd>
<dt><strong><code>L_y</code></strong> :&ensp;<code>float</code></dt>
<dd>Length in y-direction.</dd>
<dt><strong><code>L_z</code></strong> :&ensp;<code>float</code> or <code>None</code>, optional</dt>
<dd>Length in z-direction, if this is None, then the geometry
will be two-dimensional (default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>dolfin.cpp.mesh.Mesh</code></dt>
<dd>The computational mesh.</dd>
<dt><strong><code>subdomains</code></strong> :&ensp;<code>dolfin.cpp.mesh.MeshFunctionSizet</code></dt>
<dd>A MeshFunction object containing the subdomains.</dd>
<dt><strong><code>boundaries</code></strong> :&ensp;<code>dolfin.cpp.mesh.MeshFunctionSizet</code></dt>
<dd>A MeshFunction object containing the boundaries.</dd>
<dt><strong><code>dx</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>The volume measure of the mesh corresponding to subdomains.</dd>
<dt><strong><code>ds</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>The surface measure of the mesh corresponding to boundaries.</dd>
<dt><strong><code>dS</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>The interior facet measure of the mesh corresponding to boundaries.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regular_mesh(n=10, L_x=1.0, L_y=1.0, L_z=None):
        r&#34;&#34;&#34;Creates a mesh corresponding to a rectangle or cube.

        This function creates a uniform mesh of either a rectangle
        or a cube, starting at the origin and having length specified
        in lx, lx, lz. The resulting mesh uses n elements along the
        shortest direction and accordingly many along the longer ones.
        The resulting domain is
                $$[0, L_x] \times [0, L_y] \phantom{ \times [0, L_z] a} \quad \text{ in } 2D, \\
                [0, L_x] \times [0, L_y] \times [0, L_z] \quad \text{ in } 3D.
                $$

        The boundary markers are ordered as follows:

          - 1 corresponds to \(\{x=0\}\).

          - 2 corresponds to \(\{x=L_x\}\).

          - 3 corresponds to \(\{y=0\}\).

          - 4 corresponds to \(\{y=L_y\}\).

          - 5 corresponds to \(\{z=0\}\) (only in 3D).

          - 6 corresponds to \(\{z=L_z\}\) (only in 3D).

        Parameters
        ----------
        n : int
                Number of elements in the shortest coordinate direction.
        L_x : float
                Length in x-direction.
        L_y : float
                Length in y-direction.
        L_z : float or None, optional
                Length in z-direction, if this is None, then the geometry
                will be two-dimensional (default is None).

        Returns
        -------
        mesh : dolfin.cpp.mesh.Mesh
                The computational mesh.
        subdomains : dolfin.cpp.mesh.MeshFunctionSizet
                A MeshFunction object containing the subdomains.
        boundaries : dolfin.cpp.mesh.MeshFunctionSizet
                A MeshFunction object containing the boundaries.
        dx : ufl.measure.Measure
                The volume measure of the mesh corresponding to subdomains.
        ds : ufl.measure.Measure
                The surface measure of the mesh corresponding to boundaries.
        dS : ufl.measure.Measure
                The interior facet measure of the mesh corresponding to boundaries.
        &#34;&#34;&#34;
        
        if not L_x &gt; 0.0:
                raise InputError(&#39;cashocs.geometry.regular_mesh&#39;, &#39;L_x&#39;, &#39;L_x needs to be positive&#39;)
        if not L_y &gt; 0.0:
                raise InputError(&#39;cashocs.geometry.regular_mesh&#39;, &#39;L_y&#39;, &#39;L_y needs to be positive&#39;)
        if not (L_z is None or L_z &gt; 0.0):
                raise InputError(&#39;cashocs.geometry.regular_mesh&#39;, &#39;L_z&#39;, &#39;L_z needs to be positive or None (for 2D mesh)&#39;)
        
        n = int(n)
        
        if L_z is None:
                sizes = [L_x, L_y]
                dim = 2
        else:
                sizes = [L_x, L_y, L_z]
                dim = 3
        
        size_min = np.min(sizes)
        num_points = [int(np.round(length/size_min*n)) for length in sizes]
        
        if L_z is None:
                mesh = fenics.RectangleMesh(fenics.Point(0, 0), fenics.Point(sizes), num_points[0], num_points[1])
        else:
                mesh = fenics.BoxMesh(fenics.Point(0, 0, 0), fenics.Point(sizes), num_points[0], num_points[1], num_points[2])
        
        subdomains = fenics.MeshFunction(&#39;size_t&#39;, mesh, dim=dim)
        boundaries = fenics.MeshFunction(&#39;size_t&#39;, mesh, dim=dim - 1)
        
        x_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[0], 0, tol)&#39;, tol=fenics.DOLFIN_EPS)
        x_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[0], length, tol)&#39;, tol=fenics.DOLFIN_EPS, length=sizes[0])
        x_min.mark(boundaries, 1)
        x_max.mark(boundaries, 2)

        y_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[1], 0, tol)&#39;, tol=fenics.DOLFIN_EPS)
        y_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[1], length, tol)&#39;, tol=fenics.DOLFIN_EPS, length=sizes[1])
        y_min.mark(boundaries, 3)
        y_max.mark(boundaries, 4)

        if L_z is not None:
                z_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[2], 0, tol)&#39;, tol=fenics.DOLFIN_EPS)
                z_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[2], length, tol)&#39;, tol=fenics.DOLFIN_EPS, length=sizes[2])
                z_min.mark(boundaries, 5)
                z_max.mark(boundaries, 6)
        
        dx = fenics.Measure(&#39;dx&#39;, mesh, subdomain_data=subdomains)
        ds = fenics.Measure(&#39;ds&#39;, mesh, subdomain_data=boundaries)
        dS = fenics.Measure(&#39;dS&#39;, mesh)
        
        return mesh, subdomains, boundaries, dx, ds, dS</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cashocs.OptimalControlProblem"><code class="flex name class">
<span>class <span class="ident">OptimalControlProblem</span></span>
<span>(</span><span>state_forms, bcs_list, cost_functional_form, states, controls, adjoints, config, riesz_scalar_products=None, control_constraints=None, initial_guess=None, ksp_options=None, adjoint_ksp_options=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Implements an optimal control problem.</p>
<p>This class is used to define an optimal control problem, and also to solve
it subsequently. For a detailed documentation, see the examples in the "demos"
folder. For easier input, when consider single (state or control) variables,
these do not have to be wrapped into a list.
Note, that in the case of multiple variables these have to be grouped into
ordered lists, where state_forms, bcs_list, states, adjoints have to have
the same order (i.e. [state1, state2, state3,&hellip;] and [adjoint1, adjoint2,
adjoint3, &hellip;], where adjoint1 is the adjoint of state1 and so on.</p>
<p>Initializes the optimal control problem.</p>
<p>This is used to generate all classes and functionalities. First ensures
consistent input as the <strong>init</strong> function is overloaded. Afterwards, the
solution algorithm is initialized.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state_forms</code></strong> :&ensp;<code>ufl.form.Form</code> or <code>list[ufl.form.Form]</code></dt>
<dd>the weak form of the state equation (user implemented). Can be either
a single UFL form, or a (ordered) list of UFL forms</dd>
<dt><strong><code>bcs_list</code></strong> :&ensp;<code>list[dolfin.fem.dirichletbc.DirichletBC]</code> or <code>list[list[dolfin.fem.dirichletbc.DirichletBC]]</code> or <code>dolfin.fem.dirichletbc.DirichletBC</code> or <code>None</code></dt>
<dd>the list of DirichletBC objects describing Dirichlet (essential) boundary conditions.
If this is None, then no Dirichlet boundary conditions are imposed.</dd>
<dt><strong><code>cost_functional_form</code></strong> :&ensp;<code>ufl.form.Form</code></dt>
<dd>UFL form of the cost functional</dd>
<dt><strong><code>states</code></strong> :&ensp;<code>dolfin.function.function.Function</code> or <code>list[dolfin.function.function.Function]</code></dt>
<dd>the state variable(s), can either be a single fenics Function, or a (ordered) list of these</dd>
<dt><strong><code>controls</code></strong> :&ensp;<code>dolfin.function.function.Function</code> or <code>list[dolfin.function.function.Function]</code></dt>
<dd>the control variable(s), can either be a single fenics Function, or a list of these</dd>
<dt><strong><code>adjoints</code></strong> :&ensp;<code>dolfin.function.function.Function</code> or <code>list[dolfin.function.function.Function]</code></dt>
<dd>the adjoint variable(s), can either be a single fenics Function, or a (ordered) list of these</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>configparser.ConfigParser</code></dt>
<dd>the config file for the problem, generated via cashocs.create_config(path_to_config)</dd>
<dt><strong><code>riesz_scalar_products</code></strong> :&ensp;<code>None</code> or <code>ufl.form.Form</code> or <code>list[ufl.form.Form]</code>, optional</dt>
<dd>the scalar products of the control space. Can either be None, a single UFL form, or a
(ordered) list of UFL forms. If None, the <span><span class="MathJax_Preview">L^2(\Omega)</span><script type="math/tex">L^2(\Omega)</script></span> product is used.
(default is None)</dd>
<dt><strong><code>control_constraints</code></strong> :&ensp;<code>None</code> or <code>list[dolfin.function.function.Function]</code> or <code>list[float]</code> or <code>list[list[dolfin.function.function.Function]]</code> or <code>list[list[float]]</code>, optional</dt>
<dd>Box constraints posed on the control, None means that there are none (default is None).
The (inner) lists should contain two elements of the form [u_a, u_b], where u_a is the lower,
and u_b the upper bound.</dd>
<dt><strong><code>initial_guess</code></strong> :&ensp;<code>list[dolfin.function.function.Function]</code>, optional</dt>
<dd>list of functions that act as initial guess for the state variables, should be valid input for fenics.assign.
(defaults to None (which means a zero initial guess))</dd>
<dt><strong><code>ksp_options</code></strong> :&ensp;<code>list[list[str]]</code> or <code>list[list[list[str]]]</code> or <code>None</code>, optional</dt>
<dd>A list of strings corresponding to command line options for PETSc,
used to solve the state systems. If this is None, then the direct solver
mumps is used (default is None).</dd>
<dt><strong><code>adjoint_ksp_options</code></strong> :&ensp;<code>list[list[str]]</code> or <code>list[list[list[str]]]</code> or <code>None</code></dt>
<dd>A list of strings corresponding to command line options for PETSc,
used to solve the adjoint systems. If this is None, then the same options
as for the state systems are used (default is None).</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>The corresponding examples detailing the use of this class can be found
in the "demos" folder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OptimalControlProblem(OptimizationProblem):
        &#34;&#34;&#34;Implements an optimal control problem.

        This class is used to define an optimal control problem, and also to solve
        it subsequently. For a detailed documentation, see the examples in the &#34;demos&#34;
        folder. For easier input, when consider single (state or control) variables,
        these do not have to be wrapped into a list.
        Note, that in the case of multiple variables these have to be grouped into
        ordered lists, where state_forms, bcs_list, states, adjoints have to have
        the same order (i.e. [state1, state2, state3,...] and [adjoint1, adjoint2,
        adjoint3, ...], where adjoint1 is the adjoint of state1 and so on.
        &#34;&#34;&#34;

        def __init__(self, state_forms, bcs_list, cost_functional_form, states, controls, adjoints, config,
                                 riesz_scalar_products=None, control_constraints=None, initial_guess=None, ksp_options=None,
                                 adjoint_ksp_options=None):
                r&#34;&#34;&#34;Initializes the optimal control problem.

                This is used to generate all classes and functionalities. First ensures
                consistent input as the __init__ function is overloaded. Afterwards, the
                solution algorithm is initialized.
                
                Parameters
                ----------
                state_forms : ufl.form.Form or list[ufl.form.Form]
                        the weak form of the state equation (user implemented). Can be either
                        a single UFL form, or a (ordered) list of UFL forms
                bcs_list : list[dolfin.fem.dirichletbc.DirichletBC] or list[list[dolfin.fem.dirichletbc.DirichletBC]] or dolfin.fem.dirichletbc.DirichletBC or None
                        the list of DirichletBC objects describing Dirichlet (essential) boundary conditions.
                        If this is None, then no Dirichlet boundary conditions are imposed.
                cost_functional_form : ufl.form.Form
                        UFL form of the cost functional
                states : dolfin.function.function.Function or list[dolfin.function.function.Function]
                        the state variable(s), can either be a single fenics Function, or a (ordered) list of these
                controls : dolfin.function.function.Function or list[dolfin.function.function.Function]
                        the control variable(s), can either be a single fenics Function, or a list of these
                adjoints : dolfin.function.function.Function or list[dolfin.function.function.Function]
                        the adjoint variable(s), can either be a single fenics Function, or a (ordered) list of these
                config : configparser.ConfigParser
                        the config file for the problem, generated via cashocs.create_config(path_to_config)
                riesz_scalar_products : None or ufl.form.Form or list[ufl.form.Form], optional
                        the scalar products of the control space. Can either be None, a single UFL form, or a
                        (ordered) list of UFL forms. If None, the \(L^2(\Omega)\) product is used.
                        (default is None)
                control_constraints : None or list[dolfin.function.function.Function] or list[float] or list[list[dolfin.function.function.Function]] or list[list[float]], optional
                        Box constraints posed on the control, None means that there are none (default is None).
                        The (inner) lists should contain two elements of the form [u_a, u_b], where u_a is the lower,
                        and u_b the upper bound.
                initial_guess : list[dolfin.function.function.Function], optional
                        list of functions that act as initial guess for the state variables, should be valid input for fenics.assign.
                        (defaults to None (which means a zero initial guess))
                ksp_options : list[list[str]] or list[list[list[str]]] or None, optional
                        A list of strings corresponding to command line options for PETSc,
                        used to solve the state systems. If this is None, then the direct solver
                        mumps is used (default is None).
                adjoint_ksp_options : list[list[str]] or list[list[list[str]]] or None
                        A list of strings corresponding to command line options for PETSc,
                        used to solve the adjoint systems. If this is None, then the same options
                        as for the state systems are used (default is None).

                Examples
                --------
                The corresponding examples detailing the use of this class can be found
                in the &#34;demos&#34; folder.
                &#34;&#34;&#34;

                OptimizationProblem.__init__(self, state_forms, bcs_list, cost_functional_form, states, adjoints, config, initial_guess, ksp_options, adjoint_ksp_options)
                ### Overloading, such that we do not have to use lists for a single state and a single control
                ### controls
                try:
                        if type(controls) == list and len(controls) &gt; 0:
                                for i in range(len(controls)):
                                        if controls[i].__module__ == &#39;dolfin.function.function&#39; and type(controls[i]).__name__ == &#39;Function&#39;:
                                                pass
                                        else:
                                                raise InputError(&#39;cashocs._optimization.optimal_control_problem.OptimalControlProblem&#39;, &#39;controls&#39;, &#39;controls have to be fenics Functions.&#39;)

                                self.controls = controls

                        elif controls.__module__ == &#39;dolfin.function.function&#39; and type(controls).__name__ == &#39;Function&#39;:
                                self.controls = [controls]
                        else:
                                raise InputError(&#39;cashocs._optimization.optimal_control_problem.OptimalControlProblem&#39;, &#39;controls&#39;, &#39;Type of controls is wrong.&#39;)
                except:
                        raise InputError(&#39;cashocs._optimization.optimal_control_problem.OptimalControlProblem&#39;, &#39;controls&#39;, &#39;Type of controls is wrong.&#39;)

                self.control_dim = len(self.controls)

                ### riesz_scalar_products
                if riesz_scalar_products is None:
                        dx = fenics.Measure(&#39;dx&#39;, self.controls[0].function_space().mesh())
                        self.riesz_scalar_products = [fenics.inner(fenics.TrialFunction(self.controls[i].function_space()), fenics.TestFunction(self.controls[i].function_space())) * dx
                                                                                  for i in range(len(self.controls))]
                else:
                        try:
                                if type(riesz_scalar_products)==list and len(riesz_scalar_products) &gt; 0:
                                        for i in range(len(riesz_scalar_products)):
                                                if riesz_scalar_products[i].__module__== &#39;ufl.form&#39; and type(riesz_scalar_products[i]).__name__== &#39;Form&#39;:
                                                        pass
                                                else:
                                                        raise InputError(&#39;cashocs._optimization.optimal_control_problem.OptimalControlProblem&#39;, &#39;riesz_scalar_products&#39;, &#39;riesz_scalar_products have to be ufl forms&#39;)
                                        self.riesz_scalar_products = riesz_scalar_products
                                elif riesz_scalar_products.__module__== &#39;ufl.form&#39; and type(riesz_scalar_products).__name__== &#39;Form&#39;:
                                        self.riesz_scalar_products = [riesz_scalar_products]
                                else:
                                        raise InputError(&#39;cashocs._optimization.optimal_control_problem.OptimalControlProblem&#39;, &#39;riesz_scalar_products&#39;, &#39;riesz_scalar_products have to be ufl forms&#39;)
                        except:
                                raise InputError(&#39;cashocs._optimization.optimal_control_problem.OptimalControlProblem&#39;, &#39;riesz_scalar_products&#39;, &#39;riesz_scalar_products have to be ufl forms&#39;)

                ### control_constraints
                if control_constraints is None:
                        self.control_constraints = []
                        for control in self.controls:
                                u_a = fenics.Function(control.function_space())
                                u_a.vector()[:] = float(&#39;-inf&#39;)
                                u_b = fenics.Function(control.function_space())
                                u_b.vector()[:] = float(&#39;inf&#39;)
                                self.control_constraints.append([u_a, u_b])
                else:
                        try:
                                if type(control_constraints) == list and len(control_constraints) &gt; 0:
                                        if type(control_constraints[0]) == list:
                                                for i in range(len(control_constraints)):
                                                        if type(control_constraints[i]) == list and len(control_constraints[i]) == 2:
                                                                for j in range(2):
                                                                        if type(control_constraints[i][j]) in [float, int]:
                                                                                pass
                                                                        elif control_constraints[i][j].__module__ == &#39;dolfin.function.function&#39; and type(control_constraints[i][j]).__name__ == &#39;Function&#39;:
                                                                                pass
                                                                        else:
                                                                                raise InputError(&#39;cashocs._optimization.optimal_control_problem.OptimalControlProblem&#39;, &#39;control_constraints&#39;,
                                                                                                                 &#39;control_constraints has to be a list containing upper and lower bounds&#39;)
                                                                pass
                                                        else:
                                                                raise InputError(&#39;cashocs._optimization.optimal_control_problem.OptimalControlProblem&#39;, &#39;control_constraints&#39;,
                                                                                                                 &#39;control_constraints has to be a list containing upper and lower bounds&#39;)
                                                self.control_constraints = control_constraints
                                        elif (type(control_constraints[0]) in [float, int] or (control_constraints[0].__module__ == &#39;dolfin.function.function&#39; and type(control_constraints[0]).__name__==&#39;Function&#39;)) \
                                                and (type(control_constraints[1]) in [float, int] or (control_constraints[1].__module__ == &#39;dolfin.function.function&#39; and type(control_constraints[1]).__name__==&#39;Function&#39;)):

                                                self.control_constraints = [control_constraints]
                                        else:
                                                raise InputError(&#39;cashocs._optimization.optimal_control_problem.OptimalControlProblem&#39;, &#39;control_constraints&#39;,
                                                                                                                 &#39;control_constraints has to be a list containing upper and lower bounds&#39;)

                        except:
                                raise InputError(&#39;cashocs._optimization.optimal_control_problem.OptimalControlProblem&#39;, &#39;control_constraints&#39;,
                                                                                                                 &#39;control_constraints has to be a list containing upper and lower bounds&#39;)

                # recast floats into functions for compatibility
                temp_constraints = self.control_constraints[:]
                self.control_constraints = []
                for idx, pair in enumerate(temp_constraints):
                        if type(pair[0]) in [float, int]:
                                lower_bound = fenics.Function(self.controls[idx].function_space())
                                lower_bound.vector()[:] = pair[0]
                        elif pair[0].__module__ == &#39;dolfin.function.function&#39; and type(pair[0]).__name__ == &#39;Function&#39;:
                                lower_bound = pair[0]
                        else:
                                raise InputError(&#39;cashocs._optimization.optimal_control_problem.OptimalControlProblem&#39;, &#39;control_constraints&#39;, &#39;Wrong type for the control constraints&#39;)

                        if type(pair[1]) in [float, int]:
                                upper_bound = fenics.Function(self.controls[idx].function_space())
                                upper_bound.vector()[:] = pair[1]
                        elif pair[1].__module__ == &#39;dolfin.function.function&#39; and type(pair[1]).__name__ == &#39;Function&#39;:
                                upper_bound = pair[1]
                        else:
                                raise InputError(&#39;cashocs._optimization.optimal_control_problem.OptimalControlProblem&#39;, &#39;control_constraints&#39;, &#39;Wrong type for the control constraints&#39;)

                        self.control_constraints.append([lower_bound, upper_bound])

                ### Check whether the control constraints are feasible, and whether they are actually present
                self.require_control_constraints = [False for i in range(self.control_dim)]
                for idx, pair in enumerate(self.control_constraints):
                        if not np.alltrue(pair[0].vector()[:] &lt; pair[1].vector()[:]):
                                raise InputError(&#39;cashocs._optimization.optimal_control_problem.OptimalControlProblem&#39;, &#39;control_constraints&#39;,
                                                                 &#39;The lower bound must always be smaller than the upper bound for the control_constraints.&#39;)

                        if np.max(pair[0].vector()[:]) == float(&#39;-inf&#39;) and np.min(pair[1].vector()[:]) == float(&#39;inf&#39;):
                                # no control constraint for this component
                                pass
                        else:
                                self.require_control_constraints[idx] = True
                                if not (self.controls[idx].ufl_element().family() == &#39;Lagrange&#39; and self.controls[idx].ufl_element().degree() == 1):
                                        raise InputError(&#39;cashocs._optimization.optimal_control_problem.OptimalControlProblem&#39;, &#39;controls&#39;,
                                                                         &#39;Control constraints are only implemented for linear Lagrange elements&#39;)
                
                if not len(self.riesz_scalar_products) == self.control_dim:
                        raise InputError(&#39;cashocs._optimization.optimal_control_problem.OptimalControlProblem&#39;, &#39;riesz_scalar_products&#39;, &#39;Length of controls does not match&#39;)
                if not len(self.control_constraints) == self.control_dim:
                        raise InputError(&#39;cashocs._optimization.optimal_control_problem.OptimalControlProblem&#39;, &#39;control_constraints&#39;, &#39;Length of controls does not match&#39;)
                ### end overloading

                self.lagrangian = Lagrangian(self.state_forms, self.cost_functional_form)
                self.form_handler = ControlFormHandler(self.lagrangian, self.bcs_list, self.states, self.controls, self.adjoints, self.config,
                                                                                           self.riesz_scalar_products, self.control_constraints, self.ksp_options, self.adjoint_ksp_options,
                                                                                           self.require_control_constraints)

                self.state_spaces = self.form_handler.state_spaces
                self.control_spaces = self.form_handler.control_spaces
                self.adjoint_spaces = self.form_handler.adjoint_spaces

                self.projected_difference = [fenics.Function(V) for V in self.control_spaces]

                self.state_problem = StateProblem(self.form_handler, self.initial_guess)
                self.adjoint_problem = AdjointProblem(self.form_handler, self.state_problem)
                self.gradient_problem = GradientProblem(self.form_handler, self.state_problem, self.adjoint_problem)

                self.algorithm = _optimization_algorithm_configuration(self.config)

                self.reduced_cost_functional = ReducedCostFunctional(self.form_handler, self.state_problem)

                self.gradients = self.gradient_problem.gradients
                self.objective_value = 1.0



        def _stationary_measure_squared(self):
                &#34;&#34;&#34;Computes the stationary measure (squared) corresponding to box-constraints

                In case there are no box constraints this reduces to the classical gradient
                norm.

                Returns
                -------
                 float
                        The square of the stationary measure

                &#34;&#34;&#34;

                for j in range(self.control_dim):
                        self.projected_difference[j].vector()[:] = self.controls[j].vector()[:] - self.gradients[j].vector()[:]

                self.form_handler.project_to_admissible_set(self.projected_difference)

                for j in range(self.control_dim):
                        self.projected_difference[j].vector()[:] = self.controls[j].vector()[:] - self.projected_difference[j].vector()[:]

                return self.form_handler.scalar_product(self.projected_difference, self.projected_difference)
        
        
        
        def _erase_pde_memory(self):
                &#34;&#34;&#34;Resets the memory of the PDE problems so that new solutions are computed.
                
                This sets the value of has_solution to false for all relevant PDE problems,
                where memory is stored.
                
                Returns
                -------
                None
                &#34;&#34;&#34;
                
                self.state_problem.has_solution = False
                self.adjoint_problem.has_solution = False
                self.gradient_problem.has_solution = False
                

                
        def solve(self, algorithm=None, rtol=None, atol=None, max_iter=None):
                r&#34;&#34;&#34;Solves the optimization problem by the method specified in the config file.

                Updates / overwrites states, controls, and adjoints according
                to the optimization method, i.e., the user-input functions.

                Parameters
                ----------
                algorithm : str or None, optional
                        Selects the optimization algorithm. Valid choices are
                        &#39;gradient_descent&#39; (&#39;gd&#39;), &#39;conjugate_gradient&#39; (&#39;cg&#39;),
                        &#39;lbfgs&#39; (&#39;bfgs&#39;), &#39;newton&#39;, or &#39;pdas&#39;. This overwrites
                        the value specified in the config file. If this is None,
                        then the value in the config file is used. Default is
                        None.
                rtol : float or None, optional
                        The relative tolerance used for the termination criterion.
                        Overwrites the value specified in the config file. If this
                        is None, the value from the config file is taken. Default
                        is None.
                atol : float or None, optional
                        The absolute tolerance used for the termination criterion.
                        Overwrites the value specified in the config file. If this
                        is None, the value from the config file is taken. Default
                        is None.
                max_iter : int or None, optional
                        The maximum number of iterations the optimization algorithm
                        can carry out before it is terminated. Overwrites the value
                        specified in the config file. If this is None, the value from
                        the config file is taken. Default is None.

                Returns
                -------
                None

                Notes
                -----
                If either `rtol` or `atol` are specified as arguments to the solve
                call, the termination criterion changes to:

                  - a purely relative one (if only `rtol` is specified), i.e.,
                $$ || \nabla J(u_k) || \leq \texttt{rtol} || \nabla J(u_0) ||.
                $$
                  - a purely absolute one (if only `atol` is specified), i.e.,
                $$ || \nabla J(u_K) || \leq \texttt{atol}.
                $$
                  - a combined one if both `rtol` and `atol` are specified, i.e.,
                $$ || \nabla J(u_k) || \leq \texttt{atol} + \texttt{rtol} || \nabla J(u_0) ||
                $$
                &#34;&#34;&#34;

                self.algorithm = _optimization_algorithm_configuration(self.config, algorithm)

                if self.algorithm == &#39;newton&#39; or \
                                (self.algorithm == &#39;pdas&#39; and self.config.get(&#39;OptimizationRoutine&#39;, &#39;inner_pdas&#39;) == &#39;newton&#39;):
                        self.form_handler._ControlFormHandler__compute_newton_forms()

                if self.algorithm == &#39;newton&#39;:
                        self.hessian_problem = HessianProblem(self.form_handler, self.gradient_problem)
                if self.algorithm == &#39;pdas&#39;:
                        self.unconstrained_hessian = UnconstrainedHessianProblem(self.form_handler, self.gradient_problem)

                if (rtol is not None) and (atol is None):
                        self.config.set(&#39;OptimizationRoutine&#39;, &#39;rtol&#39;, str(rtol))
                        self.config.set(&#39;OptimizationRoutine&#39;, &#39;atol&#39;, str(0.0))
                elif (atol is not None) and (rtol is None):
                        self.config.set(&#39;OptimizationRoutine&#39;, &#39;rtol&#39;, str(0.0))
                        self.config.set(&#39;OptimizationRoutine&#39;, &#39;atol&#39;, str(atol))
                elif (atol is not None) and (rtol is not None):
                        self.config.set(&#39;OptimizationRoutine&#39;, &#39;rtol&#39;, str(rtol))
                        self.config.set(&#39;OptimizationRoutine&#39;, &#39;atol&#39;, str(atol))

                if max_iter is not None:
                        self.config.set(&#39;OptimizationRoutine&#39;, &#39;maximum_iterations&#39;, str(max_iter))

                if self.algorithm == &#39;gradient_descent&#39;:
                        self.solver = GradientDescent(self)
                elif self.algorithm == &#39;lbfgs&#39;:
                        self.solver = LBFGS(self)
                elif self.algorithm == &#39;conjugate_gradient&#39;:
                        self.solver = CG(self)
                elif self.algorithm == &#39;newton&#39;:
                        self.solver = Newton(self)
                elif self.algorithm == &#39;pdas&#39;:
                        self.solver = PDAS(self)
                else:
                        raise ConfigError(&#39;OptimizationRoutine&#39;, &#39;algorithm&#39;, &#39;Not a valid input. Needs to be one &#39;
                                                          &#39;of \&#39;gradient_descent\&#39; (\&#39;gd\&#39;), \&#39;lbfgs\&#39; (\&#39;bfgs\&#39;), \&#39;conjugate_gradient\&#39; (\&#39;cg\&#39;), \&#39;newton\&#39;, or \&#39;primal_dual_active_set\&#39; (\&#39;pdas\&#39;).&#39;)
                
                self.solver.run()
                self.solver.finalize()



        def compute_gradient(self):
                &#34;&#34;&#34;Solves the Riesz problem to determine the gradient(s)

                This can be used for debugging, or code validation.
                The necessary solutions of the state and adjoint systems
                are carried out automatically.

                Returns
                -------
                list[dolfin.function.function.Function]
                        a list consisting of the (components) of the gradient
                &#34;&#34;&#34;

                self.gradient_problem.solve()

                return self.gradients</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cashocs.optimization_problem.OptimizationProblem" href="optimization_problem.html#cashocs.optimization_problem.OptimizationProblem">OptimizationProblem</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cashocs.OptimalControlProblem.compute_adjoint_variables"><code class="name flex">
<span>def <span class="ident">compute_adjoint_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="cashocs.optimization_problem.OptimizationProblem" href="optimization_problem.html#cashocs.optimization_problem.OptimizationProblem">OptimizationProblem</a></code>.<code><a title="cashocs.optimization_problem.OptimizationProblem.compute_adjoint_variables" href="optimization_problem.html#cashocs.optimization_problem.OptimizationProblem.compute_adjoint_variables">compute_adjoint_variables</a></code>
</p>
<div class="desc inherited"><p>Solves the adjoint system â€¦</p></div>
</dd>
<dt id="cashocs.OptimalControlProblem.compute_gradient"><code class="name flex">
<span>def <span class="ident">compute_gradient</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Solves the Riesz problem to determine the gradient(s)</p>
<p>This can be used for debugging, or code validation.
The necessary solutions of the state and adjoint systems
are carried out automatically.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[dolfin.function.function.Function]</code></dt>
<dd>a list consisting of the (components) of the gradient</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_gradient(self):
        &#34;&#34;&#34;Solves the Riesz problem to determine the gradient(s)

        This can be used for debugging, or code validation.
        The necessary solutions of the state and adjoint systems
        are carried out automatically.

        Returns
        -------
        list[dolfin.function.function.Function]
                a list consisting of the (components) of the gradient
        &#34;&#34;&#34;

        self.gradient_problem.solve()

        return self.gradients</code></pre>
</details>
</dd>
<dt id="cashocs.OptimalControlProblem.compute_state_variables"><code class="name flex">
<span>def <span class="ident">compute_state_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="cashocs.optimization_problem.OptimizationProblem" href="optimization_problem.html#cashocs.optimization_problem.OptimizationProblem">OptimizationProblem</a></code>.<code><a title="cashocs.optimization_problem.OptimizationProblem.compute_state_variables" href="optimization_problem.html#cashocs.optimization_problem.OptimizationProblem.compute_state_variables">compute_state_variables</a></code>
</p>
<div class="desc inherited"><p>Solves the state system â€¦</p></div>
</dd>
<dt id="cashocs.OptimalControlProblem.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, algorithm=None, rtol=None, atol=None, max_iter=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Solves the optimization problem by the method specified in the config file.</p>
<p>Updates / overwrites states, controls, and adjoints according
to the optimization method, i.e., the user-input functions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>algorithm</code></strong> :&ensp;<code>str</code> or <code>None</code>, optional</dt>
<dd>Selects the optimization algorithm. Valid choices are
'gradient_descent' ('gd'), 'conjugate_gradient' ('cg'),
'lbfgs' ('bfgs'), 'newton', or 'pdas'. This overwrites
the value specified in the config file. If this is None,
then the value in the config file is used. Default is
None.</dd>
<dt><strong><code>rtol</code></strong> :&ensp;<code>float</code> or <code>None</code>, optional</dt>
<dd>The relative tolerance used for the termination criterion.
Overwrites the value specified in the config file. If this
is None, the value from the config file is taken. Default
is None.</dd>
<dt><strong><code>atol</code></strong> :&ensp;<code>float</code> or <code>None</code>, optional</dt>
<dd>The absolute tolerance used for the termination criterion.
Overwrites the value specified in the config file. If this
is None, the value from the config file is taken. Default
is None.</dd>
<dt><strong><code>max_iter</code></strong> :&ensp;<code>int</code> or <code>None</code>, optional</dt>
<dd>The maximum number of iterations the optimization algorithm
can carry out before it is terminated. Overwrites the value
specified in the config file. If this is None, the value from
the config file is taken. Default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>If either <code>rtol</code> or <code>atol</code> are specified as arguments to the solve
call, the termination criterion changes to:</p>
<ul>
<li>a purely relative one (if only <code>rtol</code> is specified), i.e.,
<span><span class="MathJax_Preview"> || \nabla J(u_k) || \leq \texttt{rtol} || \nabla J(u_0) ||.
</span><script type="math/tex; mode=display"> || \nabla J(u_k) || \leq \texttt{rtol} || \nabla J(u_0) ||.
</script></span></li>
<li>a purely absolute one (if only <code>atol</code> is specified), i.e.,
<span><span class="MathJax_Preview"> || \nabla J(u_K) || \leq \texttt{atol}.
</span><script type="math/tex; mode=display"> || \nabla J(u_K) || \leq \texttt{atol}.
</script></span></li>
<li>a combined one if both <code>rtol</code> and <code>atol</code> are specified, i.e.,
<span><span class="MathJax_Preview"> || \nabla J(u_k) || \leq \texttt{atol} + \texttt{rtol} || \nabla J(u_0) ||
</span><script type="math/tex; mode=display"> || \nabla J(u_k) || \leq \texttt{atol} + \texttt{rtol} || \nabla J(u_0) ||
</script></span></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve(self, algorithm=None, rtol=None, atol=None, max_iter=None):
        r&#34;&#34;&#34;Solves the optimization problem by the method specified in the config file.

        Updates / overwrites states, controls, and adjoints according
        to the optimization method, i.e., the user-input functions.

        Parameters
        ----------
        algorithm : str or None, optional
                Selects the optimization algorithm. Valid choices are
                &#39;gradient_descent&#39; (&#39;gd&#39;), &#39;conjugate_gradient&#39; (&#39;cg&#39;),
                &#39;lbfgs&#39; (&#39;bfgs&#39;), &#39;newton&#39;, or &#39;pdas&#39;. This overwrites
                the value specified in the config file. If this is None,
                then the value in the config file is used. Default is
                None.
        rtol : float or None, optional
                The relative tolerance used for the termination criterion.
                Overwrites the value specified in the config file. If this
                is None, the value from the config file is taken. Default
                is None.
        atol : float or None, optional
                The absolute tolerance used for the termination criterion.
                Overwrites the value specified in the config file. If this
                is None, the value from the config file is taken. Default
                is None.
        max_iter : int or None, optional
                The maximum number of iterations the optimization algorithm
                can carry out before it is terminated. Overwrites the value
                specified in the config file. If this is None, the value from
                the config file is taken. Default is None.

        Returns
        -------
        None

        Notes
        -----
        If either `rtol` or `atol` are specified as arguments to the solve
        call, the termination criterion changes to:

          - a purely relative one (if only `rtol` is specified), i.e.,
        $$ || \nabla J(u_k) || \leq \texttt{rtol} || \nabla J(u_0) ||.
        $$
          - a purely absolute one (if only `atol` is specified), i.e.,
        $$ || \nabla J(u_K) || \leq \texttt{atol}.
        $$
          - a combined one if both `rtol` and `atol` are specified, i.e.,
        $$ || \nabla J(u_k) || \leq \texttt{atol} + \texttt{rtol} || \nabla J(u_0) ||
        $$
        &#34;&#34;&#34;

        self.algorithm = _optimization_algorithm_configuration(self.config, algorithm)

        if self.algorithm == &#39;newton&#39; or \
                        (self.algorithm == &#39;pdas&#39; and self.config.get(&#39;OptimizationRoutine&#39;, &#39;inner_pdas&#39;) == &#39;newton&#39;):
                self.form_handler._ControlFormHandler__compute_newton_forms()

        if self.algorithm == &#39;newton&#39;:
                self.hessian_problem = HessianProblem(self.form_handler, self.gradient_problem)
        if self.algorithm == &#39;pdas&#39;:
                self.unconstrained_hessian = UnconstrainedHessianProblem(self.form_handler, self.gradient_problem)

        if (rtol is not None) and (atol is None):
                self.config.set(&#39;OptimizationRoutine&#39;, &#39;rtol&#39;, str(rtol))
                self.config.set(&#39;OptimizationRoutine&#39;, &#39;atol&#39;, str(0.0))
        elif (atol is not None) and (rtol is None):
                self.config.set(&#39;OptimizationRoutine&#39;, &#39;rtol&#39;, str(0.0))
                self.config.set(&#39;OptimizationRoutine&#39;, &#39;atol&#39;, str(atol))
        elif (atol is not None) and (rtol is not None):
                self.config.set(&#39;OptimizationRoutine&#39;, &#39;rtol&#39;, str(rtol))
                self.config.set(&#39;OptimizationRoutine&#39;, &#39;atol&#39;, str(atol))

        if max_iter is not None:
                self.config.set(&#39;OptimizationRoutine&#39;, &#39;maximum_iterations&#39;, str(max_iter))

        if self.algorithm == &#39;gradient_descent&#39;:
                self.solver = GradientDescent(self)
        elif self.algorithm == &#39;lbfgs&#39;:
                self.solver = LBFGS(self)
        elif self.algorithm == &#39;conjugate_gradient&#39;:
                self.solver = CG(self)
        elif self.algorithm == &#39;newton&#39;:
                self.solver = Newton(self)
        elif self.algorithm == &#39;pdas&#39;:
                self.solver = PDAS(self)
        else:
                raise ConfigError(&#39;OptimizationRoutine&#39;, &#39;algorithm&#39;, &#39;Not a valid input. Needs to be one &#39;
                                                  &#39;of \&#39;gradient_descent\&#39; (\&#39;gd\&#39;), \&#39;lbfgs\&#39; (\&#39;bfgs\&#39;), \&#39;conjugate_gradient\&#39; (\&#39;cg\&#39;), \&#39;newton\&#39;, or \&#39;primal_dual_active_set\&#39; (\&#39;pdas\&#39;).&#39;)
        
        self.solver.run()
        self.solver.finalize()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cashocs.ShapeOptimizationProblem"><code class="flex name class">
<span>class <span class="ident">ShapeOptimizationProblem</span></span>
<span>(</span><span>state_forms, bcs_list, cost_functional_form, states, adjoints, boundaries, config, initial_guess=None, ksp_options=None, adjoint_ksp_options=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A shape optimization problem</p>
<p>This class is used to define a shape optimization problem, and also to solve
it subsequently. For a detailed documentation, see the examples in the "demos"
folder. For easier input, when consider single (state or control) variables,
these do not have to be wrapped into a list.
Note, that in the case of multiple variables these have to be grouped into
ordered lists, where state_forms, bcs_list, states, adjoints have to have
the same order (i.e. [state1, state2, state3,&hellip;] and [adjoint1, adjoint2,
adjoint3, &hellip;], where adjoint1 is the adjoint of state1 and so on.</p>
<p>Initializes the shape optimization problem</p>
<p>This is used to generate all classes and functionalities. First ensures
consistent input as the <strong>init</strong> function is overloaded. Afterwards, the
solution algorithm is initialized.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state_forms</code></strong> :&ensp;<code>ufl.form.Form</code> or <code>list[ufl.form.Form]</code></dt>
<dd>the weak form of the state equation (user implemented). Can be either</dd>
<dt><strong><code>bcs_list</code></strong> :&ensp;<code>list[dolfin.fem.dirichletbc.DirichletBC]</code> or <code>list[list[dolfin.fem.dirichletbc.DirichletBC]]</code></dt>
<dd>or dolfin.fem.dirichletbc.DirichletBC or None
the list of DirichletBC objects describing Dirichlet (essential) boundary conditions.
If this is None, then no Dirichlet boundary conditions are imposed.</dd>
<dt><strong><code>cost_functional_form</code></strong> :&ensp;<code>ufl.form.Form</code></dt>
<dd>UFL form of the cost functional</dd>
<dt><strong><code>states</code></strong> :&ensp;<code>dolfin.function.function.Function</code> or <code>list[dolfin.function.function.Function]</code></dt>
<dd>the state variable(s), can either be a single fenics Function, or a (ordered) list of these</dd>
<dt><strong><code>adjoints</code></strong> :&ensp;<code>dolfin.function.function.Function</code> or <code>list[dolfin.function.function.Function]</code></dt>
<dd>the adjoint variable(s), can either be a single fenics Function, or a (ordered) list of these</dd>
<dt><strong><code>boundaries</code></strong> :&ensp;<code>dolfin.cpp.mesh.MeshFunctionSizet</code></dt>
<dd>MeshFunction that indicates the boundary markers</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>configparser.ConfigParser</code></dt>
<dd>the config file for the problem, generated via cashocs.create_config(path_to_config)</dd>
<dt><strong><code>initial_guess</code></strong> :&ensp;<code>list[dolfin.function.function.Function]</code>, optional</dt>
<dd>A list of functions that act as initial guess for the state variables, should be valid input for fenics.assign.
(defaults to None (which means a zero initial guess))</dd>
<dt><strong><code>ksp_options</code></strong> :&ensp;<code>list[list[str]]</code> or <code>list[list[list[str]]]</code> or <code>None</code>, optional</dt>
<dd>A list of strings corresponding to command line options for PETSc,
used to solve the state systems. If this is None, then the direct solver
mumps is used (default is None).</dd>
<dt><strong><code>adjoint_ksp_options</code></strong> :&ensp;<code>list[list[str]]</code> or <code>list[list[list[str]]]</code> or <code>None</code></dt>
<dd>A list of strings corresponding to command line options for PETSc,
used to solve the adjoint systems. If this is None, then the same options
as for the state systems are used (default is None).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ShapeOptimizationProblem(OptimizationProblem):
        &#34;&#34;&#34;A shape optimization problem

        This class is used to define a shape optimization problem, and also to solve
        it subsequently. For a detailed documentation, see the examples in the &#34;demos&#34;
        folder. For easier input, when consider single (state or control) variables,
        these do not have to be wrapped into a list.
        Note, that in the case of multiple variables these have to be grouped into
        ordered lists, where state_forms, bcs_list, states, adjoints have to have
        the same order (i.e. [state1, state2, state3,...] and [adjoint1, adjoint2,
        adjoint3, ...], where adjoint1 is the adjoint of state1 and so on.
        &#34;&#34;&#34;

        def __init__(self, state_forms, bcs_list, cost_functional_form, states,
                                 adjoints, boundaries, config, initial_guess=None,
                                 ksp_options=None, adjoint_ksp_options=None):
                &#34;&#34;&#34;Initializes the shape optimization problem

                This is used to generate all classes and functionalities. First ensures
                consistent input as the __init__ function is overloaded. Afterwards, the
                solution algorithm is initialized.

                Parameters
                ----------
                state_forms : ufl.form.Form or list[ufl.form.Form]
                        the weak form of the state equation (user implemented). Can be either
                bcs_list : list[dolfin.fem.dirichletbc.DirichletBC] or list[list[dolfin.fem.dirichletbc.DirichletBC]]
                                   or dolfin.fem.dirichletbc.DirichletBC or None
                        the list of DirichletBC objects describing Dirichlet (essential) boundary conditions.
                        If this is None, then no Dirichlet boundary conditions are imposed.
                cost_functional_form : ufl.form.Form
                        UFL form of the cost functional
                states : dolfin.function.function.Function or list[dolfin.function.function.Function]
                        the state variable(s), can either be a single fenics Function, or a (ordered) list of these
                adjoints : dolfin.function.function.Function or list[dolfin.function.function.Function]
                        the adjoint variable(s), can either be a single fenics Function, or a (ordered) list of these
                boundaries : dolfin.cpp.mesh.MeshFunctionSizet
                        MeshFunction that indicates the boundary markers
                config : configparser.ConfigParser
                        the config file for the problem, generated via cashocs.create_config(path_to_config)
                initial_guess : list[dolfin.function.function.Function], optional
                        A list of functions that act as initial guess for the state variables, should be valid input for fenics.assign.
                        (defaults to None (which means a zero initial guess))
                ksp_options : list[list[str]] or list[list[list[str]]] or None, optional
                        A list of strings corresponding to command line options for PETSc,
                        used to solve the state systems. If this is None, then the direct solver
                        mumps is used (default is None).
                adjoint_ksp_options : list[list[str]] or list[list[list[str]]] or None
                        A list of strings corresponding to command line options for PETSc,
                        used to solve the adjoint systems. If this is None, then the same options
                        as for the state systems are used (default is None).
                &#34;&#34;&#34;

                OptimizationProblem.__init__(self, state_forms, bcs_list, cost_functional_form, states, adjoints, config, initial_guess, ksp_options, adjoint_ksp_options)

                ### Initialize the remeshing behavior, and a temp file
                self.do_remesh = config.getboolean(&#39;Mesh&#39;, &#39;remesh&#39;, fallback=False)
                self.temp_dict = None
                if self.do_remesh:
                        
                        if not os.path.isfile(os.path.realpath(sys.argv[0])):
                                raise CashocsException(&#39;Not a valid configuration. The script has to be the first command line argument.&#39;)

                        try:
                                if __IPYTHON__:
                                        warnings.warn(&#39;You are running a shape optimization problem with remeshing from ipython. Rather run this using the python command&#39;)
                        except NameError:
                                pass

                        try:
                                if not self.states[0].function_space().mesh()._cashocs_generator == &#39;config&#39;:
                                        raise InputError(&#39;cashocs.import_mesh&#39;, &#39;arg&#39;, &#39;You must specify a config file as input for remeshing.&#39;)
                        except AttributeError:
                                raise InputError(&#39;cashocs.import_mesh&#39;, &#39;arg&#39;, &#39;You must specify a config file as input for remeshing.&#39;)

                        if not (&#39;_cashocs_remesh_flag&#39; in sys.argv):
                                self.directory = os.path.dirname(os.path.realpath(sys.argv[0]))
                                self.__clean_previous_temp_files()
                                self.temp_dir = tempfile.mkdtemp(prefix=&#39;._cashocs_remesh_temp_&#39;, dir=self.directory)
                                self.__change_except_hook()
                                self.temp_dict = {&#39;temp_dir&#39; : self.temp_dir, &#39;gmsh_file&#39; : self.config.get(&#39;Mesh&#39;, &#39;gmsh_file&#39;),
                                                                  &#39;geo_file&#39; : self.config.get(&#39;Mesh&#39;, &#39;geo_file&#39;),
                                                                  &#39;OptimizationRoutine&#39; : {&#39;iteration_counter&#39; : 0, &#39;gradient_norm_initial&#39; : 0.0},
                                                                  &#39;output_dict&#39; : {}}

                        else:
                                self.temp_dir = sys.argv[-1]
                                self.__change_except_hook()
                                with open(self.temp_dir + &#39;/temp_dict.json&#39;, &#39;r&#39;) as file:
                                        self.temp_dict = json.load(file)

                ### boundaries
                if boundaries.__module__ == &#39;dolfin.cpp.mesh&#39; and type(boundaries).__name__ == &#39;MeshFunctionSizet&#39;:
                        self.boundaries = boundaries
                else:
                        raise InputError(&#39;cashocs._shape_optimization.shape_optimization_problem.ShapeOptimizationProblem&#39;, &#39;boundaries&#39;, &#39;Not a valid type for boundaries.&#39;)

                self.lagrangian = Lagrangian(self.state_forms, self.cost_functional_form)
                self.shape_form_handler = ShapeFormHandler(self.lagrangian, self.bcs_list, self.states, self.adjoints,
                                                                                                   self.boundaries, self.config, self.ksp_options, self.adjoint_ksp_options)
                self.mesh_handler = _MeshHandler(self)

                self.state_spaces = self.shape_form_handler.state_spaces
                self.adjoint_spaces = self.shape_form_handler.adjoint_spaces

                self.state_problem = StateProblem(self.shape_form_handler, self.initial_guess, self.temp_dict)
                self.adjoint_problem = AdjointProblem(self.shape_form_handler, self.state_problem, self.temp_dict)
                self.shape_gradient_problem = ShapeGradientProblem(self.shape_form_handler, self.state_problem, self.adjoint_problem)

                self.reduced_cost_functional = ReducedShapeCostFunctional(self.shape_form_handler, self.state_problem)

                self.gradient = self.shape_gradient_problem.gradient
                self.objective_value = 1.0
        
        
        
        def _erase_pde_memory(self):
                &#34;&#34;&#34;Resets the memory of the PDE problems so that new solutions are computed.
                
                This sets the value of has_solution to false for all relevant PDE problems,
                where memory is stored.
                
                Returns
                -------
                None
                &#34;&#34;&#34;
                
                self.mesh_handler.bbtree.build(self.mesh_handler.mesh)
                self.shape_form_handler.update_scalar_product()
                self.state_problem.has_solution = False
                self.adjoint_problem.has_solution = False
                self.shape_gradient_problem.has_solution = False



        def solve(self, algorithm=None, rtol=None, atol=None, max_iter=None):
                r&#34;&#34;&#34;Solves the optimization problem by the method specified in the config file.

                Parameters
                ----------
                algorithm : str or None, optional
                        Selects the optimization algorithm. Valid choices are
                        &#39;gradient_descent&#39; (&#39;gd&#39;), &#39;conjugate_gradient&#39; (&#39;cg&#39;),
                        or &#39;lbfgs&#39; (&#39;bfgs&#39;). This overwrites the value specified
                        in the config file. If this is None, then the value in the
                        config file is used. Default is None.
                rtol : float or None, optional
                        The relative tolerance used for the termination criterion.
                        Overwrites the value specified in the config file. If this
                        is None, the value from the config file is taken. Default
                        is None.
                atol : float or None, optional
                        The absolute tolerance used for the termination criterion.
                        Overwrites the value specified in the config file. If this
                        is None, the value from the config file is taken. Default
                        is None.
                max_iter : int or None, optional
                        The maximum number of iterations the optimization algorithm
                        can carry out before it is terminated. Overwrites the value
                        specified in the config file. If this is None, the value from
                        the config file is taken. Default is None.

                Returns
                -------
                None

                Notes
                -----
                If either `rtol` or `atol` are specified as arguments to the solve
                call, the termination criterion changes to:

                  - a purely relative one (if only `rtol` is specified), i.e.,
                $$ || \nabla J(u_k) || \leq \texttt{rtol} || \nabla J(u_0) ||.
                $$
                  - a purely absolute one (if only `atol` is specified), i.e.,
                $$ || \nabla J(u_K) || \leq \texttt{atol}.
                $$
                  - a combined one if both `rtol` and `atol` are specified, i.e.,
                $$ || \nabla J(u_k) || \leq \texttt{atol} + \texttt{rtol} || \nabla J(u_0) ||
                $$
                &#34;&#34;&#34;

                self.algorithm = _optimization_algorithm_configuration(self.config, algorithm)

                if (rtol is not None) and (atol is None):
                        self.config.set(&#39;OptimizationRoutine&#39;, &#39;rtol&#39;, str(rtol))
                        self.config.set(&#39;OptimizationRoutine&#39;, &#39;atol&#39;, str(0.0))
                elif (atol is not None) and (rtol is None):
                        self.config.set(&#39;OptimizationRoutine&#39;, &#39;rtol&#39;, str(0.0))
                        self.config.set(&#39;OptimizationRoutine&#39;, &#39;atol&#39;, str(atol))
                elif (atol is not None) and (rtol is not None):
                        self.config.set(&#39;OptimizationRoutine&#39;, &#39;rtol&#39;, str(rtol))
                        self.config.set(&#39;OptimizationRoutine&#39;, &#39;atol&#39;, str(atol))

                if max_iter is not None:
                        self.config.set(&#39;OptimizationRoutine&#39;, &#39;maximum_iterations&#39;, str(max_iter))

                if self.algorithm == &#39;gradient_descent&#39;:
                        self.solver = GradientDescent(self)
                elif self.algorithm == &#39;lbfgs&#39;:
                        self.solver = LBFGS(self)
                elif self.algorithm == &#39;conjugate_gradient&#39;:
                        self.solver = CG(self)
                else:
                        raise ConfigError(&#39;OptimizationRoutine&#39;, &#39;algorithm&#39;, &#39;Not a valid input. Needs to be one of \&#39;gradient_descent\&#39; (\&#39;gd\&#39;), \&#39;lbfgs\&#39; (\&#39;bfgs\&#39;), or \&#39;conjugate_gradient\&#39; (\&#39;cg\&#39;).&#39;)

                self.solver.run()
                self.solver.finalize()



        def __change_except_hook(self):
                &#34;&#34;&#34;Ensures that temp files are deleted when an exception occurs.

                This modifies the sys.excepthook command so that it also deletes temp files
                (only needed for remeshing)

                Returns
                -------
                None
                &#34;&#34;&#34;

                def custom_except_hook(exctype, value, traceback):
                        print(&#39;DEBUG: Caught the exception, deleting temp files&#39;)
                        os.system(&#39;rm -r &#39; + self.temp_dir)
                        sys.__excepthook__(exctype, value, traceback)

                sys.excepthook = custom_except_hook



        def __clean_previous_temp_files(self):

                for file in os.listdir(self.directory):
                        if file.startswith(&#39;._cashocs_remesh_temp_&#39;):
                                os.system(&#39;rm -r &#39; + file)



        def compute_shape_gradient(self):
                &#34;&#34;&#34;Solves the Riesz problem to determine the gradient(s)

                This can be used for debugging, or code validation.
                The necessary solutions of the state and adjoint systems
                are carried out automatically.

                Returns
                -------
                dolfin.function.function.Function
                        The shape gradient function
                &#34;&#34;&#34;

                self.shape_gradient_problem.solve()

                return self.gradient</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cashocs.optimization_problem.OptimizationProblem" href="optimization_problem.html#cashocs.optimization_problem.OptimizationProblem">OptimizationProblem</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cashocs.ShapeOptimizationProblem.compute_adjoint_variables"><code class="name flex">
<span>def <span class="ident">compute_adjoint_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="cashocs.optimization_problem.OptimizationProblem" href="optimization_problem.html#cashocs.optimization_problem.OptimizationProblem">OptimizationProblem</a></code>.<code><a title="cashocs.optimization_problem.OptimizationProblem.compute_adjoint_variables" href="optimization_problem.html#cashocs.optimization_problem.OptimizationProblem.compute_adjoint_variables">compute_adjoint_variables</a></code>
</p>
<div class="desc inherited"><p>Solves the adjoint system â€¦</p></div>
</dd>
<dt id="cashocs.ShapeOptimizationProblem.compute_shape_gradient"><code class="name flex">
<span>def <span class="ident">compute_shape_gradient</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Solves the Riesz problem to determine the gradient(s)</p>
<p>This can be used for debugging, or code validation.
The necessary solutions of the state and adjoint systems
are carried out automatically.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dolfin.function.function.Function</code></dt>
<dd>The shape gradient function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_shape_gradient(self):
        &#34;&#34;&#34;Solves the Riesz problem to determine the gradient(s)

        This can be used for debugging, or code validation.
        The necessary solutions of the state and adjoint systems
        are carried out automatically.

        Returns
        -------
        dolfin.function.function.Function
                The shape gradient function
        &#34;&#34;&#34;

        self.shape_gradient_problem.solve()

        return self.gradient</code></pre>
</details>
</dd>
<dt id="cashocs.ShapeOptimizationProblem.compute_state_variables"><code class="name flex">
<span>def <span class="ident">compute_state_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="cashocs.optimization_problem.OptimizationProblem" href="optimization_problem.html#cashocs.optimization_problem.OptimizationProblem">OptimizationProblem</a></code>.<code><a title="cashocs.optimization_problem.OptimizationProblem.compute_state_variables" href="optimization_problem.html#cashocs.optimization_problem.OptimizationProblem.compute_state_variables">compute_state_variables</a></code>
</p>
<div class="desc inherited"><p>Solves the state system â€¦</p></div>
</dd>
<dt id="cashocs.ShapeOptimizationProblem.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, algorithm=None, rtol=None, atol=None, max_iter=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Solves the optimization problem by the method specified in the config file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>algorithm</code></strong> :&ensp;<code>str</code> or <code>None</code>, optional</dt>
<dd>Selects the optimization algorithm. Valid choices are
'gradient_descent' ('gd'), 'conjugate_gradient' ('cg'),
or 'lbfgs' ('bfgs'). This overwrites the value specified
in the config file. If this is None, then the value in the
config file is used. Default is None.</dd>
<dt><strong><code>rtol</code></strong> :&ensp;<code>float</code> or <code>None</code>, optional</dt>
<dd>The relative tolerance used for the termination criterion.
Overwrites the value specified in the config file. If this
is None, the value from the config file is taken. Default
is None.</dd>
<dt><strong><code>atol</code></strong> :&ensp;<code>float</code> or <code>None</code>, optional</dt>
<dd>The absolute tolerance used for the termination criterion.
Overwrites the value specified in the config file. If this
is None, the value from the config file is taken. Default
is None.</dd>
<dt><strong><code>max_iter</code></strong> :&ensp;<code>int</code> or <code>None</code>, optional</dt>
<dd>The maximum number of iterations the optimization algorithm
can carry out before it is terminated. Overwrites the value
specified in the config file. If this is None, the value from
the config file is taken. Default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>If either <code>rtol</code> or <code>atol</code> are specified as arguments to the solve
call, the termination criterion changes to:</p>
<ul>
<li>a purely relative one (if only <code>rtol</code> is specified), i.e.,
<span><span class="MathJax_Preview"> || \nabla J(u_k) || \leq \texttt{rtol} || \nabla J(u_0) ||.
</span><script type="math/tex; mode=display"> || \nabla J(u_k) || \leq \texttt{rtol} || \nabla J(u_0) ||.
</script></span></li>
<li>a purely absolute one (if only <code>atol</code> is specified), i.e.,
<span><span class="MathJax_Preview"> || \nabla J(u_K) || \leq \texttt{atol}.
</span><script type="math/tex; mode=display"> || \nabla J(u_K) || \leq \texttt{atol}.
</script></span></li>
<li>a combined one if both <code>rtol</code> and <code>atol</code> are specified, i.e.,
<span><span class="MathJax_Preview"> || \nabla J(u_k) || \leq \texttt{atol} + \texttt{rtol} || \nabla J(u_0) ||
</span><script type="math/tex; mode=display"> || \nabla J(u_k) || \leq \texttt{atol} + \texttt{rtol} || \nabla J(u_0) ||
</script></span></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve(self, algorithm=None, rtol=None, atol=None, max_iter=None):
        r&#34;&#34;&#34;Solves the optimization problem by the method specified in the config file.

        Parameters
        ----------
        algorithm : str or None, optional
                Selects the optimization algorithm. Valid choices are
                &#39;gradient_descent&#39; (&#39;gd&#39;), &#39;conjugate_gradient&#39; (&#39;cg&#39;),
                or &#39;lbfgs&#39; (&#39;bfgs&#39;). This overwrites the value specified
                in the config file. If this is None, then the value in the
                config file is used. Default is None.
        rtol : float or None, optional
                The relative tolerance used for the termination criterion.
                Overwrites the value specified in the config file. If this
                is None, the value from the config file is taken. Default
                is None.
        atol : float or None, optional
                The absolute tolerance used for the termination criterion.
                Overwrites the value specified in the config file. If this
                is None, the value from the config file is taken. Default
                is None.
        max_iter : int or None, optional
                The maximum number of iterations the optimization algorithm
                can carry out before it is terminated. Overwrites the value
                specified in the config file. If this is None, the value from
                the config file is taken. Default is None.

        Returns
        -------
        None

        Notes
        -----
        If either `rtol` or `atol` are specified as arguments to the solve
        call, the termination criterion changes to:

          - a purely relative one (if only `rtol` is specified), i.e.,
        $$ || \nabla J(u_k) || \leq \texttt{rtol} || \nabla J(u_0) ||.
        $$
          - a purely absolute one (if only `atol` is specified), i.e.,
        $$ || \nabla J(u_K) || \leq \texttt{atol}.
        $$
          - a combined one if both `rtol` and `atol` are specified, i.e.,
        $$ || \nabla J(u_k) || \leq \texttt{atol} + \texttt{rtol} || \nabla J(u_0) ||
        $$
        &#34;&#34;&#34;

        self.algorithm = _optimization_algorithm_configuration(self.config, algorithm)

        if (rtol is not None) and (atol is None):
                self.config.set(&#39;OptimizationRoutine&#39;, &#39;rtol&#39;, str(rtol))
                self.config.set(&#39;OptimizationRoutine&#39;, &#39;atol&#39;, str(0.0))
        elif (atol is not None) and (rtol is None):
                self.config.set(&#39;OptimizationRoutine&#39;, &#39;rtol&#39;, str(0.0))
                self.config.set(&#39;OptimizationRoutine&#39;, &#39;atol&#39;, str(atol))
        elif (atol is not None) and (rtol is not None):
                self.config.set(&#39;OptimizationRoutine&#39;, &#39;rtol&#39;, str(rtol))
                self.config.set(&#39;OptimizationRoutine&#39;, &#39;atol&#39;, str(atol))

        if max_iter is not None:
                self.config.set(&#39;OptimizationRoutine&#39;, &#39;maximum_iterations&#39;, str(max_iter))

        if self.algorithm == &#39;gradient_descent&#39;:
                self.solver = GradientDescent(self)
        elif self.algorithm == &#39;lbfgs&#39;:
                self.solver = LBFGS(self)
        elif self.algorithm == &#39;conjugate_gradient&#39;:
                self.solver = CG(self)
        else:
                raise ConfigError(&#39;OptimizationRoutine&#39;, &#39;algorithm&#39;, &#39;Not a valid input. Needs to be one of \&#39;gradient_descent\&#39; (\&#39;gd\&#39;), \&#39;lbfgs\&#39; (\&#39;bfgs\&#39;), or \&#39;conjugate_gradient\&#39; (\&#39;cg\&#39;).&#39;)

        self.solver.run()
        self.solver.finalize()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = 'search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#getting-started">Getting started</a></li>
<li><a href="#demos">Demos</a></li>
<li><a href="#command-line-interface-for-mesh-conversion">Command line interface for mesh conversion</a></li>
<li><a href="#license">License</a></li>
<li><a href="#contact-about">Contact / About</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="cashocs.geometry" href="geometry.html">cashocs.geometry</a></code></li>
<li><code><a title="cashocs.nonlinear_solvers" href="nonlinear_solvers.html">cashocs.nonlinear_solvers</a></code></li>
<li><code><a title="cashocs.optimization_problem" href="optimization_problem.html">cashocs.optimization_problem</a></code></li>
<li><code><a title="cashocs.utils" href="utils.html">cashocs.utils</a></code></li>
<li><code><a title="cashocs.verification" href="verification.html">cashocs.verification</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="cashocs.create_bcs_list" href="#cashocs.create_bcs_list">create_bcs_list</a></code></li>
<li><code><a title="cashocs.create_config" href="#cashocs.create_config">create_config</a></code></li>
<li><code><a title="cashocs.damped_newton_solve" href="#cashocs.damped_newton_solve">damped_newton_solve</a></code></li>
<li><code><a title="cashocs.import_mesh" href="#cashocs.import_mesh">import_mesh</a></code></li>
<li><code><a title="cashocs.regular_box_mesh" href="#cashocs.regular_box_mesh">regular_box_mesh</a></code></li>
<li><code><a title="cashocs.regular_mesh" href="#cashocs.regular_mesh">regular_mesh</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cashocs.OptimalControlProblem" href="#cashocs.OptimalControlProblem">OptimalControlProblem</a></code></h4>
<ul class="">
<li><code><a title="cashocs.OptimalControlProblem.compute_adjoint_variables" href="optimization_problem.html#cashocs.OptimalControlProblem.compute_adjoint_variables">compute_adjoint_variables</a></code></li>
<li><code><a title="cashocs.OptimalControlProblem.compute_gradient" href="#cashocs.OptimalControlProblem.compute_gradient">compute_gradient</a></code></li>
<li><code><a title="cashocs.OptimalControlProblem.compute_state_variables" href="optimization_problem.html#cashocs.OptimalControlProblem.compute_state_variables">compute_state_variables</a></code></li>
<li><code><a title="cashocs.OptimalControlProblem.solve" href="#cashocs.OptimalControlProblem.solve">solve</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cashocs.ShapeOptimizationProblem" href="#cashocs.ShapeOptimizationProblem">ShapeOptimizationProblem</a></code></h4>
<ul class="">
<li><code><a title="cashocs.ShapeOptimizationProblem.compute_adjoint_variables" href="optimization_problem.html#cashocs.ShapeOptimizationProblem.compute_adjoint_variables">compute_adjoint_variables</a></code></li>
<li><code><a title="cashocs.ShapeOptimizationProblem.compute_shape_gradient" href="#cashocs.ShapeOptimizationProblem.compute_shape_gradient">compute_shape_gradient</a></code></li>
<li><code><a title="cashocs.ShapeOptimizationProblem.compute_state_variables" href="optimization_problem.html#cashocs.ShapeOptimizationProblem.compute_state_variables">compute_state_variables</a></code></li>
<li><code><a title="cashocs.ShapeOptimizationProblem.solve" href="#cashocs.ShapeOptimizationProblem.solve">solve</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>