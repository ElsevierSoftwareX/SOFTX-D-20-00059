<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>cashocs.geometry API documentation</title>
<meta name="description" content="Mesh generation and import tools â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cashocs.geometry</code></h1>
</header>
<section id="section-intro">
<p>Mesh generation and import tools.</p>
<p>This module consists of tools for for the fast generation
or import of meshes into fenics. The import_mesh function
is used to import (converted) gmsh mesh files, and the
regular_(box_)mesh commands create 2D and 3D box meshes
which are great for testing.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (C) 2020 Sebastian Blauth
#
# This file is part of CASHOCS.
#
# CASHOCS is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CASHOCS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CASHOCS.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

&#34;&#34;&#34;Mesh generation and import tools.

This module consists of tools for for the fast generation
or import of meshes into fenics. The import_mesh function
is used to import (converted) gmsh mesh files, and the
regular_(box_)mesh commands create 2D and 3D box meshes
which are great for testing.
&#34;&#34;&#34;

import configparser
import json
import os
import sys
import time
import warnings

import fenics
import numpy as np
from petsc4py import PETSc
from ufl import Jacobian, JacobianInverse

from ._exceptions import ConfigError, InputError
from .utils import (_assemble_petsc_system, _setup_petsc_options,
                                        _solve_linear_problem, write_out_mesh)



def import_mesh(arg):
        &#34;&#34;&#34;Imports a mesh file for use with cashocs / fenics.

        This function imports a mesh file that was generated by GMSH and converted to
        .xdmf with the command line function cashocs-convert (see cashocs main documentation).
        The syntax for the conversion is

            cashocs-convert in.msh out.xdmf

        If there are Physical quantities specified in the gmsh file, these are imported
        to the subdomains and boundaries output of this function and can also be directly
        accessed via the measures, e.g., with dx(1), ds(1), etc.

        Parameters
        ----------
        arg : str or configparser.ConfigParser
                This is either a string, in which case it corresponds to the location
                of the mesh file in .xdmf file format, or a config file that
                has this path stored in its settings.

        Returns
        -------
        mesh : dolfin.cpp.mesh.Mesh
                The imported (computational) mesh.
        subdomains : dolfin.cpp.mesh.MeshFunctionSizet
                A MeshFunction object containing the subdomains,
                i.e., the Physical regions marked in the gmsh
                file.
        boundaries : dolfin.cpp.mesh.MeshFunctionSizet
                A MeshFunction object containing the boundaries,
                i.e., the Physical regions marked in the gmsh
                file. Can, e.g., be used to set up boundary
                conditions.
        dx : ufl.measure.Measure
                The volume measure of the mesh corresponding to
                the subdomains (i.e. gmsh Physical region indices).
        ds : ufl.measure.Measure
                The surface measure of the mesh corresponding to
                the boundaries (i.e. gmsh Physical region indices).
        dS : ufl.measure.Measure
                The interior facet measure of the mesh corresponding
                to boundaries (i.e. gmsh Physical region indices).
        &#34;&#34;&#34;
        
        start_time = time.time()
        print(&#39;Importing mesh to FEniCS&#39;)
        # Check for the file format

        if type(arg) == str:
                mesh_file = arg
                mesh_attribute = &#39;str&#39;
        elif type(arg) == configparser.ConfigParser:
                mesh_attribute = &#39;config&#39;
                ### overloading for remeshing
                if not arg.getboolean(&#39;Mesh&#39;, &#39;remesh&#39;, fallback=False):
                        mesh_file = arg.get(&#39;Mesh&#39;, &#39;mesh_file&#39;)
                else:
                        if not (&#39;_cashocs_remesh_flag&#39; in sys.argv):
                                mesh_file = arg.get(&#39;Mesh&#39;, &#39;mesh_file&#39;)
                        else:
                                temp_dir = sys.argv[-1]
                                with open(temp_dir + &#39;/temp_dict.json&#39;, &#39;r&#39;) as file:
                                        temp_dict = json.load(file)
                                mesh_file = temp_dict[&#39;mesh_file&#39;]

        else:
                raise InputError(&#39;Not a valid argument for import_mesh.&#39;)

        if mesh_file[-5:] == &#39;.xdmf&#39;:
                file_string = mesh_file[:-5]
        else:
                raise InputError(&#39;Not a suitable mesh file format.&#39;)
        
        mesh = fenics.Mesh()
        xdmf_file = fenics.XDMFFile(mesh.mpi_comm(), mesh_file)
        xdmf_file.read(mesh)
        xdmf_file.close()
        
        subdomains_mvc = fenics.MeshValueCollection(&#39;size_t&#39;, mesh, mesh.geometric_dimension())
        boundaries_mvc = fenics.MeshValueCollection(&#39;size_t&#39;, mesh, mesh.geometric_dimension() - 1)

        if os.path.exists(file_string + &#39;_subdomains.xdmf&#39;):
                xdmf_subdomains = fenics.XDMFFile(mesh.mpi_comm(), file_string + &#39;_subdomains.xdmf&#39;)
                xdmf_subdomains.read(subdomains_mvc, &#39;subdomains&#39;)
                xdmf_subdomains.close()
        if os.path.exists(file_string + &#39;_boundaries.xdmf&#39;):
                xdmf_boundaries = fenics.XDMFFile(mesh.mpi_comm(), file_string + &#39;_boundaries.xdmf&#39;)
                xdmf_boundaries.read(boundaries_mvc, &#39;boundaries&#39;)
                xdmf_boundaries.close()

        subdomains = fenics.MeshFunction(&#39;size_t&#39;, mesh, subdomains_mvc)
        boundaries = fenics.MeshFunction(&#39;size_t&#39;, mesh, boundaries_mvc)

        dx = fenics.Measure(&#39;dx&#39;, domain=mesh, subdomain_data=subdomains)
        ds = fenics.Measure(&#39;ds&#39;, domain=mesh, subdomain_data=boundaries)
        dS = fenics.Measure(&#39;dS&#39;, domain=mesh, subdomain_data=boundaries)
        
        end_time = time.time()
        print(&#39;Done Importing Mesh. Elapsed Time: &#39; + format(end_time - start_time, &#39;.3e&#39;) + &#39; s&#39;)
        print(&#39;&#39;)

        # Add an attribute to the mesh to show with what procedure it was generated
        mesh._cashocs_generator = mesh_attribute

        return mesh, subdomains, boundaries, dx, ds, dS



def regular_mesh(n=10, L_x=1.0, L_y=1.0, L_z=None):
        r&#34;&#34;&#34;Creates a mesh corresponding to a rectangle or cube.

        This function creates a uniform mesh of either a rectangle
        or a cube, starting at the origin and having length specified
        in lx, lx, lz. The resulting mesh uses n elements along the
        shortest direction and accordingly many along the longer ones.
        The resulting domain is
                $$[0, L_x] \times [0, L_y] \phantom{ \times [0, L_z] a} \quad \text{ in } 2D, \\
                [0, L_x] \times [0, L_y] \times [0, L_z] \quad \text{ in } 3D.
                $$

        The boundary markers are ordered as follows:

          - 1 corresponds to \(\{x=0\}\).

          - 2 corresponds to \(\{x=L_x\}\).

          - 3 corresponds to \(\{y=0\}\).

          - 4 corresponds to \(\{y=L_y\}\).

          - 5 corresponds to \(\{z=0\}\) (only in 3D).

          - 6 corresponds to \(\{z=L_z\}\) (only in 3D).

        Parameters
        ----------
        n : int
                Number of elements in the shortest coordinate direction.
        L_x : float
                Length in x-direction.
        L_y : float
                Length in y-direction.
        L_z : float or None, optional
                Length in z-direction, if this is None, then the geometry
                will be two-dimensional (default is None).

        Returns
        -------
        mesh : dolfin.cpp.mesh.Mesh
                The computational mesh.
        subdomains : dolfin.cpp.mesh.MeshFunctionSizet
                A MeshFunction object containing the subdomains.
        boundaries : dolfin.cpp.mesh.MeshFunctionSizet
                A MeshFunction object containing the boundaries.
        dx : ufl.measure.Measure
                The volume measure of the mesh corresponding to subdomains.
        ds : ufl.measure.Measure
                The surface measure of the mesh corresponding to boundaries.
        dS : ufl.measure.Measure
                The interior facet measure of the mesh corresponding to boundaries.
        &#34;&#34;&#34;

        n = int(n)
        
        if L_z is None:
                sizes = [L_x, L_y]
                dim = 2
        else:
                sizes = [L_x, L_y, L_z]
                dim = 3
        
        size_min = np.min(sizes)
        num_points = [int(np.round(length/size_min*n)) for length in sizes]
        
        if L_z is None:
                mesh = fenics.RectangleMesh(fenics.Point(0, 0), fenics.Point(sizes), num_points[0], num_points[1])
        else:
                mesh = fenics.BoxMesh(fenics.Point(0, 0, 0), fenics.Point(sizes), num_points[0], num_points[1], num_points[2])
        
        subdomains = fenics.MeshFunction(&#39;size_t&#39;, mesh, dim=dim)
        boundaries = fenics.MeshFunction(&#39;size_t&#39;, mesh, dim=dim - 1)
        
        x_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[0], 0, tol)&#39;, tol=fenics.DOLFIN_EPS)
        x_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[0], length, tol)&#39;, tol=fenics.DOLFIN_EPS, length=sizes[0])
        x_min.mark(boundaries, 1)
        x_max.mark(boundaries, 2)

        y_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[1], 0, tol)&#39;, tol=fenics.DOLFIN_EPS)
        y_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[1], length, tol)&#39;, tol=fenics.DOLFIN_EPS, length=sizes[1])
        y_min.mark(boundaries, 3)
        y_max.mark(boundaries, 4)

        if L_z is not None:
                z_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[2], 0, tol)&#39;, tol=fenics.DOLFIN_EPS)
                z_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[2], length, tol)&#39;, tol=fenics.DOLFIN_EPS, length=sizes[2])
                z_min.mark(boundaries, 5)
                z_max.mark(boundaries, 6)
        
        dx = fenics.Measure(&#39;dx&#39;, mesh, subdomain_data=subdomains)
        ds = fenics.Measure(&#39;ds&#39;, mesh, subdomain_data=boundaries)
        dS = fenics.Measure(&#39;dS&#39;, mesh)
        
        return mesh, subdomains, boundaries, dx, ds, dS



def regular_box_mesh(n=10, S_x=0.0, S_y=0.0, S_z=None, E_x=1.0, E_y=1.0, E_z=None):
        r&#34;&#34;&#34;Creates a mesh corresponding to a rectangle or cube.

        This function creates a uniform mesh of either a rectangle
        or a cube, with specified start (S_) and end points (E_).
        The resulting mesh uses n elements along the shortest direction
        and accordingly many along the longer ones. The resulting domain is

        $$[S_x, E_x] \times [S_y, E_y] \phantom{ \times [S_z, E_z] a} \quad \text{ in } 2D, \\
        [S_x, E_x] \times [S_y, E_y] \times [S_z, E_z] \quad \text{ in } 3D.
        $$

        The boundary markers are ordered as follows:

          - 1 corresponds to \(\{x=S_x\}\).

          - 2 corresponds to \(\{x=E_x\}\).

          - 3 corresponds to \(\{y=S_y\}\).

          - 4 corresponds to \(\{y=E_y\}\).

          - 5 corresponds to \(\{z=S_z\}\) (only in 3D).

          - 6 corresponds to \(\{z=E_z\}\) (only in 3D).

        Parameters
        ----------
        n : int
                Number of elements in the shortest coordinate direction.
        S_x : float
                Start of the x-interval.
        S_y : float
                Start of the y-interval.
        S_z : float or None, optional
                Start of the z-interval, mesh is 2D if this is None
                (default is None).
        E_x : float
                End of the x-interval.
        E_y : float
                End of the y-interval.
        E_z : float or None, optional
                End of the z-interval, mesh is 2D if this is None
                (default is None).

        Returns
        -------
        mesh : dolfin.cpp.mesh.Mesh
                the computational mesh
        subdomains : dolfin.cpp.mesh.MeshFunctionSizet
                a MeshFunction object containing the subdomains
        boundaries : dolfin.cpp.mesh.MeshFunctionSizet
                a MeshFunction object containing the boundaries
        dx : ufl.measure.Measure
                the volume measure of the mesh corresponding to subdomains
        ds : ufl.measure.Measure
                the surface measure of the mesh corresponding to boundaries
        dS : ufl.measure.Measure
                the interior facet measure of the mesh corresponding to boundaries
        &#34;&#34;&#34;

        n = int(n)

        assert S_x &lt; E_x, &#39;Incorrect input for the x-coordinate&#39;
        assert S_y &lt; E_y, &#39;Incorrect input for the y-coordinate&#39;
        assert (S_z is None and E_z is None) or (S_z &lt; E_z), &#39;Incorrect input for the z-coordinate&#39;

        if S_z is None:
                lx = E_x - S_x
                ly = E_y - S_y
                sizes = [lx, ly]
                dim = 2
        else:
                lx = E_x - S_x
                ly = E_y - S_y
                lz = E_z - S_z
                sizes = [lx, ly, lz]
                dim = 3

        size_min = np.min(sizes)
        num_points = [int(np.round(length/size_min*n)) for length in sizes]

        if S_z is None:
                mesh = fenics.RectangleMesh(fenics.Point(S_x, S_y), fenics.Point(E_x, E_y), num_points[0], num_points[1])
        else:
                mesh = fenics.BoxMesh(fenics.Point(S_x, S_y, S_z), fenics.Point(E_x, E_y, E_z), num_points[0], num_points[1], num_points[2])

        subdomains = fenics.MeshFunction(&#39;size_t&#39;, mesh, dim=dim)
        boundaries = fenics.MeshFunction(&#39;size_t&#39;, mesh, dim=dim - 1)

        x_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[0], sx, tol)&#39;, tol=fenics.DOLFIN_EPS, sx=S_x)
        x_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[0], ex, tol)&#39;, tol=fenics.DOLFIN_EPS, ex=E_x)
        x_min.mark(boundaries, 1)
        x_max.mark(boundaries, 2)

        y_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[1], sy, tol)&#39;, tol=fenics.DOLFIN_EPS, sy=S_y)
        y_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[1], ey, tol)&#39;, tol=fenics.DOLFIN_EPS, ey=E_y)
        y_min.mark(boundaries, 3)
        y_max.mark(boundaries, 4)

        if S_z is not None:
                z_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[2], sz, tol)&#39;, tol=fenics.DOLFIN_EPS, sz=S_z)
                z_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[2], ez, tol)&#39;, tol=fenics.DOLFIN_EPS, ez=E_z)
                z_min.mark(boundaries, 5)
                z_max.mark(boundaries, 6)

        dx = fenics.Measure(&#39;dx&#39;, mesh, subdomain_data=subdomains)
        ds = fenics.Measure(&#39;ds&#39;, mesh, subdomain_data=boundaries)
        dS = fenics.Measure(&#39;dS&#39;, mesh)

        return mesh, subdomains, boundaries, dx, ds, dS





class _MeshHandler:
        &#34;&#34;&#34;Handles the mesh for shape optimization problems.

        This class implements all mesh related things for the shape optimization,
         such as transformations and remeshing. Also includes mesh quality control
         checks.
        &#34;&#34;&#34;

        def __init__(self, shape_optimization_problem):
                &#34;&#34;&#34;Initializes the MeshHandler object.

                Parameters
                ----------
                shape_optimization_problem : cashocs._shape_optimization.shape_optimization_problem.ShapeOptimizationProblem
                        The corresponding shape optimization problem.
                &#34;&#34;&#34;

                self.shape_optimization_problem = shape_optimization_problem
                self.shape_form_handler = self.shape_optimization_problem.shape_form_handler
                # Namespacing
                self.mesh = self.shape_form_handler.mesh
                self.dx = self.shape_form_handler.dx
                self.bbtree = self.mesh.bounding_box_tree()
                self.config = self.shape_form_handler.config

                # setup from config
                self.volume_change = float(self.config.get(&#39;MeshQuality&#39;, &#39;volume_change&#39;, fallback=&#39;inf&#39;))
                self.angle_change = float(self.config.get(&#39;MeshQuality&#39;, &#39;angle_change&#39;, fallback=&#39;inf&#39;))

                self.mesh_quality_tol_lower = self.config.getfloat(&#39;MeshQuality&#39;, &#39;tol_lower&#39;, fallback=0.05)
                self.mesh_quality_tol_upper =  self.config.getfloat(&#39;MeshQuality&#39;, &#39;tol_upper&#39;, fallback=0.1)
                assert self.mesh_quality_tol_lower &lt; self.mesh_quality_tol_upper, \
                        &#39;The lower remeshing tolerance has to be strictly smaller than the upper remeshing tolerance&#39;
                if self.mesh_quality_tol_lower &gt; 0.9*self.mesh_quality_tol_upper:
                        warnings.warn(&#39;You are using a lower remesh tolerance close to the upper one. This may slow down the optimization considerably.&#39;)

                self.mesh_quality_measure = self.config.get(&#39;MeshQuality&#39;, &#39;measure&#39;, fallback=&#39;skewness&#39;)
                assert self.mesh_quality_measure in [&#39;skewness&#39;, &#39;maximum_angle&#39;, &#39;radius_ratios&#39;, &#39;condition_number&#39;], \
                        &#39;MeshQuality measure has to be one of `skewness`, `maximum_angle`, `condition_number`, or `radius_ratios`.&#39;

                self.mesh_quality_type = self.config.get(&#39;MeshQuality&#39;, &#39;type&#39;, fallback=&#39;min&#39;)
                assert self.mesh_quality_type in [&#39;min&#39;, &#39;minimum&#39;, &#39;avg&#39;, &#39;average&#39;], \
                        &#39;MeshQuality type has to be one of `min`, `minimum`, `avg`, or `average`.&#39;

                self.current_mesh_quality = 1.0
                self.compute_mesh_quality()

                self.__setup_decrease_computation()
                self.__setup_a_priori()

                # Remeshing initializations
                self.do_remesh = self.config.getboolean(&#39;Mesh&#39;, &#39;remesh&#39;, fallback=False)
                
                if self.do_remesh or self.config.getboolean(&#39;OptimizationRoutine&#39;, &#39;save_mesh&#39;, fallback=False):
                        try:
                                self.mesh_directory = os.path.dirname(os.path.realpath(self.config.get(&#39;Mesh&#39;, &#39;gmsh_file&#39;)))
                        except configparser.Error:
                                if self.do_remesh:
                                        raise ConfigError(&#39;Remeshing is only available with gmsh meshes.&#39;)
                                elif self.config.getboolean(&#39;OptimizationRoutine&#39;, &#39;save_mesh&#39;, fallback=False):
                                        raise ConfigError(&#39;The config option OptimizationRoutine.save_mesh is only available for gmsh meshes. \n&#39;
                                                                  &#39;If you already use a gmsh mesh, please specify Mesh.gmsh_file.&#39;)

                if self.do_remesh:
                        self.temp_dict = self.shape_optimization_problem.temp_dict
                        self.remesh_counter = self.temp_dict.get(&#39;remesh_counter&#39;, 0)
                        self.gmsh_file = self.temp_dict[&#39;gmsh_file&#39;]
                        assert self.gmsh_file[-4:] == &#39;.msh&#39;, &#39;Not a valid gmsh file&#39;
                        
                        self.remesh_directory = self.mesh_directory + &#39;/cashocs_remesh&#39;
                        if not os.path.exists(self.remesh_directory):
                                os.mkdir(self.remesh_directory)
                        if not (&#39;_cashocs_remesh_flag&#39; in sys.argv):
                                os.system(&#39;rm -r &#39; + self.remesh_directory + &#39;/*&#39;)
                        self.remesh_geo_file = self.remesh_directory + &#39;/remesh.geo&#39;

                # create a copy of the initial mesh file
                if self.do_remesh and self.remesh_counter == 0:
                        self.gmsh_file_init = self.remesh_directory + &#39;/mesh_&#39; + format(self.remesh_counter, &#39;d&#39;) + &#39;.msh&#39;
                        copy_mesh = &#39;cp &#39; + self.gmsh_file + &#39; &#39; + self.gmsh_file_init
                        os.system(copy_mesh)
                        self.gmsh_file = self.gmsh_file_init



        def move_mesh(self, transformation):
                r&#34;&#34;&#34;Transforms the mesh by perturbation of identity.

                Moves the mesh according to the deformation given by

                $$\text{id} + \mathcal{V}(x),
                $$

                where \(\mathcal{V}\) is the transformation. This
                represents the perturbation of identity.

                Parameters
                ----------
                transformation : dolfin.function.function.Function
                        The transformation for the mesh, a vector CG1 Function.
                &#34;&#34;&#34;

                assert transformation.ufl_element().family() == &#39;Lagrange&#39; and \
                           transformation.ufl_element().degree() == 1, &#39;Not a valid mesh transformation&#39;

                if not self.__test_a_priori(transformation):
                        return False
                else:
                        self.old_coordinates = self.mesh.coordinates().copy()
                        fenics.ALE.move(self.mesh, transformation)
                        self.bbtree.build(self.mesh)

                        return self.__test_a_posteriori()



        def revert_transformation(self):
                &#34;&#34;&#34;Reverts the previous mesh transformation.

                This is used when the mesh quality for the resulting deformed mesh
                is not sufficient, or when the solution algorithm terminates, e.g., due
                to lack of sufficient decrease in the Armijo rule

                Returns
                -------
                None
                &#34;&#34;&#34;

                self.mesh.coordinates()[:, :] = self.old_coordinates
                self.bbtree.build(self.mesh)



        def __setup_decrease_computation(self):
                &#34;&#34;&#34;Initializes attributes and solver for the frobenius norm check.

                Returns
                -------
                None
                &#34;&#34;&#34;

                assert self.angle_change &gt; 0, &#39;Angle change has to be positive&#39;

                options = [[
                                [&#39;ksp_type&#39;, &#39;preonly&#39;],
                                [&#39;pc_type&#39;, &#39;jacobi&#39;],
                                [&#39;pc_jacobi_type&#39;, &#39;diagonal&#39;],
                                [&#39;ksp_rtol&#39;, 1e-16],
                                [&#39;ksp_atol&#39;, 1e-20],
                                [&#39;ksp_max_it&#39;, 1000]
                ]]
                self.ksp_frobenius = PETSc.KSP().create()
                _setup_petsc_options([self.ksp_frobenius], options)

                self.trial_dg0 = fenics.TrialFunction(self.shape_form_handler.DG0)
                self.test_dg0 = fenics.TestFunction(self.shape_form_handler.DG0)

                if not (self.angle_change == float(&#39;inf&#39;)):
                        self.search_direction_container = fenics.Function(self.shape_form_handler.deformation_space)

                        self.a_frobenius = self.trial_dg0*self.test_dg0*self.dx
                        self.L_frobenius = fenics.sqrt(fenics.inner(fenics.grad(self.search_direction_container), fenics.grad(self.search_direction_container)))*self.test_dg0*self.dx



        def compute_decreases(self, search_direction, stepsize):
                &#34;&#34;&#34;Estimates the number of Armijo decreases for a certain mesh quality.

                Gives a better estimation of the stepsize. The output is
                the number of Armijo decreases we have to do in order to
                get a transformation that satisfies norm(transformation)_fro &lt;= tol,
                where transformation = stepsize*search_direction and tol is specified in
                the config file under &#34;angle_change&#34;. Due to the linearity
                of the norm this has to be done only once, all smaller stepsizes are
                feasible w.r.t. this criterion as well.

                Parameters
                ----------
                search_direction : dolfin.function.function.Function
                        The search direction in the optimization routine / descent algorithm.
                stepsize : float
                        The stepsize in the descent algorithm.

                Returns
                -------
                int
                        A guess for the number of &#34;Armijo halvings&#34; to get a better stepsize
                &#34;&#34;&#34;


                assert self.angle_change &gt; 0, &#39;Angle change has to be positive&#39;
                if self.angle_change == float(&#39;inf&#39;):
                        return 0

                else:
                        self.search_direction_container.vector()[:] = search_direction.vector()[:]
                        A, b = _assemble_petsc_system(self.a_frobenius, self.L_frobenius)
                        x = _solve_linear_problem(self.ksp_frobenius, A, b)

                        frobenius_norm = np.max(x[:])
                        beta_armijo = self.config.getfloat(&#39;OptimizationRoutine&#39;, &#39;beta_armijo&#39;, fallback=2)

                        return np.maximum(np.ceil(np.log(self.angle_change/stepsize/frobenius_norm)/np.log(1/beta_armijo)), 0.0)



        def __setup_a_priori(self):
                &#34;&#34;&#34;Sets up the attributes and petsc solver for the a priori quality check.

                Returns
                -------
                None
                &#34;&#34;&#34;

                if self.volume_change &lt; float(&#39;inf&#39;):
                        options = [[
                                [&#39;ksp_type&#39;, &#39;preonly&#39;],
                                [&#39;pc_type&#39;, &#39;jacobi&#39;],
                                [&#39;pc_jacobi_type&#39;, &#39;diagonal&#39;],
                                [&#39;ksp_rtol&#39;, 1e-16],
                                [&#39;ksp_atol&#39;, 1e-20],
                                [&#39;ksp_max_it&#39;, 1000]
                        ]]
                        self.ksp_prior = PETSc.KSP().create()
                        _setup_petsc_options([self.ksp_prior], options)

                        self.transformation_container = fenics.Function(self.shape_form_handler.deformation_space)
                        dim = self.mesh.geometric_dimension()
                        assert self.volume_change &gt; 1, &#39;Volume change has to be larger than 1&#39;
                        self.a_prior = self.trial_dg0*self.test_dg0*self.dx
                        self.L_prior = fenics.det(fenics.Identity(dim) + fenics.grad(self.transformation_container))*self.test_dg0*self.dx



        def __test_a_priori(self, transformation):
                r&#34;&#34;&#34;Check the quality of the transformation before the actual mesh is moved.

                Checks the quality of the transformation. The criterion is that

                $$ \det(I + D \texttt{transformation})
                $$

                should neither be too large nor too small in order to achieve the best
                transformations.

                Parameters
                ----------
                transformation : dolfin.function.function.Function
                        The transformation for the mesh.

                Returns
                -------
                bool
                        A boolean that indicates whether the desired transformation is feasible
                &#34;&#34;&#34;

                if self.volume_change &lt; float(&#39;inf&#39;):

                        self.transformation_container.vector()[:] = transformation.vector()[:]
                        A, b = _assemble_petsc_system(self.a_prior, self.L_prior)
                        x = _solve_linear_problem(self.ksp_prior, A, b)

                        min_det = np.min(x[:])
                        max_det = np.max(x[:])

                        return (min_det &gt;= 1/self.volume_change) and (max_det &lt;= self.volume_change)

                else:
                        return True



        def __test_a_posteriori(self):
                &#34;&#34;&#34;Checks the quality of the transformation after the actual mesh is moved.

                Checks whether the mesh is a valid finite element mesh
                after it has been moved, i.e., if there are no overlapping
                or self intersecting elements.

                Returns
                -------
                bool
                        True if the test is successful, False otherwise

                Notes
                -----
                fenics itself does not check whether the used mesh is a valid finite
                element mesh, so this check has to be done manually.
                &#34;&#34;&#34;

                mesh = self.mesh
                cells = mesh.cells()
                coordinates = mesh.coordinates()
                self_intersections = False
                for i in range(coordinates.shape[0]):
                        x = fenics.Point(coordinates[i])
                        cells_idx = self.bbtree.compute_entity_collisions(x)
                        intersections = len(cells_idx)
                        M = cells[cells_idx]
                        occurences = M.flatten().tolist().count(i)

                        if intersections &gt; occurences:
                                self_intersections = True
                                break

                if self_intersections:
                        self.revert_transformation()
                        return False
                else:
                        self.compute_mesh_quality()
                        return True



        def compute_mesh_quality(self):
                &#34;&#34;&#34;This computes the current mesh quality.

                Updates the attribute `current_mesh_quality`, based on the type
                of quality measure specified in the config file.

                Returns
                -------
                None
                &#34;&#34;&#34;

                if self.mesh_quality_type in [&#39;min&#39;, &#39;minimum&#39;]:
                        if self.mesh_quality_measure == &#39;skewness&#39;:
                                self.current_mesh_quality = MeshQuality.min_skewness(self.mesh)
                        elif self.mesh_quality_measure == &#39;maximum_angle&#39;:
                                self.current_mesh_quality = MeshQuality.min_maximum_angle(self.mesh)
                        elif self.mesh_quality_measure == &#39;radius_ratios&#39;:
                                self.current_mesh_quality = MeshQuality.min_radius_ratios(self.mesh)
                        elif self.mesh_quality_measure == &#39;condition_number&#39;:
                                self.current_mesh_quality = MeshQuality.min_condition_number(self.mesh)

                else:
                        if self.mesh_quality_measure == &#39;skewness&#39;:
                                self.current_mesh_quality = MeshQuality.avg_skewness(self.mesh)
                        elif self.mesh_quality_measure == &#39;maximum_angle&#39;:
                                self.current_mesh_quality = MeshQuality.avg_maximum_angle(self.mesh)
                        elif self.mesh_quality_measure == &#39;radius_ratios&#39;:
                                self.current_mesh_quality = MeshQuality.avg_radius_ratios(self.mesh)
                        elif self.mesh_quality_measure == &#39;condition_number&#39;:
                                self.current_mesh_quality = MeshQuality.avg_condition_number(self.mesh)



        def __generate_remesh_geo(self, input_mesh_file):
                &#34;&#34;&#34;Generates a .geo file used for remeshing.

                The .geo file is generated via the original .geo file for the
                initial geometry, so that mesh size fields are correctly given
                for the remeshing.

                Parameters
                ----------
                input_mesh_file : str
                        Path to the mesh file used for generating the new .geo file

                Returns
                -------
                None
                &#34;&#34;&#34;

                with open(self.remesh_geo_file, &#39;w&#39;) as file:
                        temp_name = os.path.split(input_mesh_file)[1]

                        file.write(&#39;Merge \&#39;&#39; + temp_name + &#39;\&#39;;\n&#39;)
                        file.write(&#39;CreateGeometry;\n&#39;)
                        file.write(&#39;\n&#39;)

                        geo_file = self.temp_dict[&#39;geo_file&#39;]
                        with open(geo_file, &#39;r&#39;) as f:
                                for line in f:
                                        if line[:2] == &#39;lc&#39;:
                                                file.write(line)
                                        if line[:5] == &#39;Field&#39;:
                                                file.write(line)
                                        if line[:16] == &#39;Background Field&#39;:
                                                file.write(line)



        def remesh(self):
                &#34;&#34;&#34;Remeshes the current geometry with gmsh.

                Performs a remeshing of the geometry, and then restarts
                the optimization problem with the new mesh.

                Returns
                -------
                None
                &#34;&#34;&#34;

                if self.do_remesh:
                        self.remesh_counter += 1
                        self.temp_file = self.remesh_directory + &#39;/mesh_&#39; + format(self.remesh_counter, &#39;d&#39;) + &#39;_pre_remesh&#39; + &#39;.msh&#39;
                        write_out_mesh(self.mesh, self.gmsh_file, self.temp_file)
                        self.__generate_remesh_geo(self.temp_file)

                        # save the output dict (without the last entries since they are &#34;remeshed&#34;)
                        self.temp_dict[&#39;output_dict&#39;] = {}
                        self.temp_dict[&#39;output_dict&#39;][&#39;state_solves&#39;] = self.shape_optimization_problem.state_problem.number_of_solves
                        self.temp_dict[&#39;output_dict&#39;][&#39;adjoint_solves&#39;] = self.shape_optimization_problem.adjoint_problem.number_of_solves
                        self.temp_dict[&#39;output_dict&#39;][&#39;iterations&#39;] = self.shape_optimization_problem.solver.iteration

                        self.temp_dict[&#39;output_dict&#39;][&#39;cost_function_value&#39;] = self.shape_optimization_problem.solver.output_dict[&#39;cost_function_value&#39;][:-1]
                        self.temp_dict[&#39;output_dict&#39;][&#39;gradient_norm&#39;] = self.shape_optimization_problem.solver.output_dict[&#39;gradient_norm&#39;][:-1]
                        self.temp_dict[&#39;output_dict&#39;][&#39;stepsize&#39;] = self.shape_optimization_problem.solver.output_dict[&#39;stepsize&#39;][:-1]
                        self.temp_dict[&#39;output_dict&#39;][&#39;MeshQuality&#39;] = self.shape_optimization_problem.solver.output_dict[&#39;MeshQuality&#39;][:-1]

                        dim = self.mesh.geometric_dimension()

                        self.new_gmsh_file = self.remesh_directory + &#39;/mesh_&#39; + format(self.remesh_counter, &#39;d&#39;) + &#39;.msh&#39;
                        gmsh_command = &#39;gmsh &#39; + self.remesh_geo_file + &#39; -&#39; + str(int(dim)) + &#39; -o &#39; + self.new_gmsh_file
                        if not self.config.getboolean(&#39;Mesh&#39;, &#39;show_gmsh_output&#39;, fallback=False):
                                os.system(gmsh_command + &#39; &gt;/dev/null 2&gt;&amp;1&#39;)
                        else:
                                os.system(gmsh_command)

                        self.temp_dict[&#39;remesh_counter&#39;] = self.remesh_counter

                        # rename_command = &#39;mv &#39; + self.temp_file + &#39; &#39; + self.new_gmsh_file
                        # os.system(rename_command)

                        self.new_xdmf_file = self.remesh_directory + &#39;/mesh_&#39; + format(self.remesh_counter, &#39;d&#39;) + &#39;.xdmf&#39;
                        convert_command = &#39;cashocs-convert &#39; + self.new_gmsh_file + &#39; &#39; + self.new_xdmf_file
                        os.system(convert_command)

                        self.temp_dict[&#39;mesh_file&#39;] = self.new_xdmf_file
                        self.temp_dict[&#39;gmsh_file&#39;] = self.new_gmsh_file

                        # test, whether the same geometry is remeshed again
                        if self.temp_dict[&#39;OptimizationRoutine&#39;][&#39;iteration_counter&#39;] == self.shape_optimization_problem.solver.iteration:
                                raise Exception(&#39;Remeshing the geometry failed. Exiting.&#39;)

                        self.temp_dict[&#39;OptimizationRoutine&#39;][&#39;iteration_counter&#39;] = self.shape_optimization_problem.solver.iteration
                        self.temp_dict[&#39;OptimizationRoutine&#39;][&#39;gradient_norm_initial&#39;] = self.shape_optimization_problem.solver.gradient_norm_initial

                        self.temp_dir = self.temp_dict[&#39;temp_dir&#39;]

                        with open(self.temp_dir + &#39;/temp_dict.json&#39;, &#39;w&#39;) as file:
                                json.dump(self.temp_dict, file)

                        if not (&#39;_cashocs_remesh_flag&#39; in sys.argv):
                                os.execv(sys.executable, [sys.executable] + sys.argv + [&#39;_cashocs_remesh_flag&#39;] + [self.temp_dir])
                        else:
                                os.execv(sys.executable, [sys.executable] + sys.argv[:-2] + [&#39;_cashocs_remesh_flag&#39;] + [self.temp_dir])





class MeshQuality:
        r&#34;&#34;&#34;A class used to compute the quality of a mesh.

        This class implements either a skewness quality measure, one based
        on the maximum angle of the elements, or one based on the radius ratios.
        All quality measures have values in \( [0, 1] \), where 1 corresponds
        to the best / perfect element, and 0 corresponds to degenerate elements.

        Examples
        --------
        This class can be directly used, without any instantiation.

            import cashocs

            mesh, _, _, _, _, _ = cashocs.regular_mesh(10)

            min_skew = cashocs.MeshQuality.min_skewness(mesh)
            avg_skew = cashocs.MeshQuality.avg_skewness(mesh)

            min_angle = cashocs.MeshQuality.min_maximum_angle(mesh)
            avg_angle = cashocs.MeshQuality.avg_maximum_angle(mesh)

            min_rad = cashocs.MeshQuality.min_radius_ratios(mesh)
            avg_rad = cashocs.MeshQuality.avg_radius_ratios(mesh)

            min_cond = cashocs.MeshQuality.min_condition_number(mesh)
            avg_cond = cashocs.MeshQuality.avg_condition_number(mesh)

        This works analogously for any mesh compatible with fenics.
        &#34;&#34;&#34;

        _cpp_code_mesh_quality = &#34;&#34;&#34;
                        #include &lt;pybind11/pybind11.h&gt;
                        #include &lt;pybind11/eigen.h&gt;
                        namespace py = pybind11;
                        
                        #include &lt;dolfin/mesh/Mesh.h&gt;
                        #include &lt;dolfin/mesh/Vertex.h&gt;
                        #include &lt;dolfin/mesh/MeshFunction.h&gt;
                        #include &lt;dolfin/mesh/Cell.h&gt;
                        #include &lt;dolfin/mesh/Vertex.h&gt;
                        
                        using namespace dolfin;
                        
                        
                        void angles_triangle(const Cell&amp; cell, std::vector&lt;double&gt;&amp; angs)
                        {
                          const Mesh&amp; mesh = cell.mesh();
                          angs.resize(3);
                          const std::size_t i0 = cell.entities(0)[0];
                          const std::size_t i1 = cell.entities(0)[1];
                          const std::size_t i2 = cell.entities(0)[2];
                          
                          const Point p0 = Vertex(mesh, i0).point();
                          const Point p1 = Vertex(mesh, i1).point();
                          const Point p2 = Vertex(mesh, i2).point();
                          Point e0 = p1 - p0;
                          Point e1 = p2 - p0;
                          Point e2 = p2 - p1;
                          
                          e0 /= e0.norm();
                          e1 /= e1.norm();
                          e2 /= e2.norm();
                        
                          angs[0] = acos(e0.dot(e1));
                          angs[1] = acos(e0.dot(e2));
                          angs[2] = acos(e1.dot(e2));
                        }
                        
                        
                        
                        void dihedral_angles(const Cell&amp; cell, std::vector&lt;double&gt;&amp; angs)
                        {
                          const Mesh&amp; mesh = cell.mesh();
                          angs.resize(6);
                          
                          const std::size_t i0 = cell.entities(0)[0];
                          const std::size_t i1 = cell.entities(0)[1];
                          const std::size_t i2 = cell.entities(0)[2];
                          const std::size_t i3 = cell.entities(0)[3];
                          
                          const Point p0 = Vertex(mesh, i0).point();
                          const Point p1 = Vertex(mesh, i1).point();
                          const Point p2 = Vertex(mesh, i2).point();
                          const Point p3 = Vertex(mesh, i3).point();
                          
                          const Point e0 = p1 - p0;
                          const Point e1 = p2 - p0;
                          const Point e2 = p3 - p0;
                          const Point e3 = p2 - p1;
                          const Point e4 = p3 - p1;
                          
                          Point n0 = e0.cross(e1);
                          Point n1 = e0.cross(e2);
                          Point n2 = e1.cross(e2);
                          Point n3 = e3.cross(e4);
                          
                          n0 /= n0.norm();
                          n1 /= n1.norm();
                          n2 /= n2.norm();
                          n3 /= n3.norm();
                          
                          angs[0] = acos(n0.dot(n1));
                          angs[1] = acos(-n0.dot(n2));
                          angs[2] = acos(n1.dot(n2));
                          angs[3] = acos(n0.dot(n3));
                          angs[4] = acos(n1.dot(-n3));
                          angs[5] = acos(n2.dot(n3));
                        }
                        
                        
                        
                        dolfin::MeshFunction&lt;double&gt;
                        skewness(std::shared_ptr&lt;const Mesh&gt; mesh)
                        {
                          MeshFunction&lt;double&gt; cf(mesh, mesh-&gt;topology().dim(), 0.0);
                          
                          double opt_angle;
                          std::vector&lt;double&gt; angs;
                          std::vector&lt;double&gt; quals;
                          
                          for (CellIterator cell(*mesh); !cell.end(); ++cell)
                          {
                                if (cell-&gt;dim() == 2)
                                {
                                  quals.resize(3);
                                  angles_triangle(*cell, angs);
                                  opt_angle = DOLFIN_PI / 3.0;
                                }
                                else if (cell-&gt;dim() == 3)
                                {
                                  quals.resize(6);
                                  dihedral_angles(*cell, angs);
                                  opt_angle = acos(1.0/3.0);
                                }
                                else
                                {
                                  dolfin_error(&#34;cashocs_quality.cpp&#34;, &#34;skewness&#34;, &#34;Not a valid dimension for the mesh.&#34;);
                                }
                                
                                for (unsigned int i = 0; i &lt; angs.size(); ++i)
                                {
                                  quals[i] = 1 - std::max((angs[i] - opt_angle) / (DOLFIN_PI - opt_angle), (opt_angle - angs[i]) / opt_angle);
                                }
                                cf[*cell] = *std::min_element(quals.begin(), quals.end());
                          }
                          return cf;
                        }
                        
                        
                        
                        dolfin::MeshFunction&lt;double&gt;
                        maximum_angle(std::shared_ptr&lt;const Mesh&gt; mesh)
                        {
                          MeshFunction&lt;double&gt; cf(mesh, mesh-&gt;topology().dim(), 0.0);
                          
                          double opt_angle;
                          std::vector&lt;double&gt; angs;
                          std::vector&lt;double&gt; quals;
                          
                          for (CellIterator cell(*mesh); !cell.end(); ++cell)
                          {
                                if (cell-&gt;dim() == 2)
                                {
                                  quals.resize(3);
                                  angles_triangle(*cell, angs);
                                  opt_angle = DOLFIN_PI / 3.0;
                                }
                                else if (cell-&gt;dim() == 3)
                                {
                                  quals.resize(6);
                                  dihedral_angles(*cell, angs);
                                  opt_angle = acos(1.0/3.0);
                                }
                                else
                                {
                                  dolfin_error(&#34;cashocs_quality.cpp&#34;, &#34;maximum_angle&#34;, &#34;Not a valid dimension for the mesh.&#34;);
                                }
                                
                                for (unsigned int i = 0; i &lt; angs.size(); ++i)
                                {
                                  quals[i] = 1 - std::max((angs[i] - opt_angle) / (DOLFIN_PI - opt_angle), 0.0);
                                }
                                cf[*cell] = *std::min_element(quals.begin(), quals.end());
                          }
                          return cf;
                        }
                        
                        PYBIND11_MODULE(SIGNATURE, m)
                        {
                          m.def(&#34;skewness&#34;, &amp;skewness);
                          m.def(&#34;maximum_angle&#34;, &amp;maximum_angle);
                        }
                
                &#34;&#34;&#34;
        _quality_object = fenics.compile_cpp_code(_cpp_code_mesh_quality)



        def __init__(self):
                &#34;&#34;&#34;Initializes self.

                &#34;&#34;&#34;
                pass



        @classmethod
        def min_skewness(cls, mesh):
                r&#34;&#34;&#34;Computes the minimal skewness of the mesh.

                This measure the relative distance of a triangle&#39;s angles or
                a tetrahedrons dihedral angles to the corresponding optimal
                angle. The optimal angle is defined as the angle an equilateral,
                and thus equiangular, element has. The skewness lies in
                \( [0,1] \), where 1 corresponds to the case of an optimal
                (equilateral) element, and 0 corresponds to a degenerate
                element. The skewness corresponding to some (dihedral) angle
                \( \alpha \) is defined as

                $$ 1 - \max \left( \frac{\alpha - \alpha^*}{\pi - \alpha*} , \frac{\alpha^* - \alpha}{\alpha^* - 0} \right),
                $$

                where \( \alpha^* \) is the corresponding optimal angle of the reference
                element. To compute the quality measure, the minimum of this expression
                over all elements and all of their (dihedral) angles is computed.

                Parameters
                ----------
                mesh : dolfin.cpp.mesh.Mesh
                        The mesh whose quality shall be computed.

                Returns
                -------
                float
                        The skewness of the mesh.
                &#34;&#34;&#34;

                return np.min(cls._quality_object.skewness(mesh).array())



        @classmethod
        def avg_skewness(cls, mesh):
                r&#34;&#34;&#34;Computes the average skewness of the mesh.

                The skewness corresponding to some (dihedral) angle
                \( \alpha \) is defined as

                $$ 1 - \max \left( \frac{\alpha - \alpha^*}{\pi - \alpha*} , \frac{\alpha^* - \alpha}{\alpha^* - 0} \right),
                $$

                where \( \alpha^* \) is the corresponding optimal angle of the reference
                element.

                Parameters
                ----------
                mesh : dolfin.cpp.mesh.Mesh
                        The mesh, whose quality shall be computed.

                Returns
                -------
                flat
                        The average skewness of the mesh.
                &#34;&#34;&#34;

                return np.average(cls._quality_object.skewness(mesh).array())



        @classmethod
        def min_maximum_angle(cls, mesh):
                r&#34;&#34;&#34;Computes the minimal quality measure based on the largest angle.

                This measures the relative distance of a triangle&#39;s angles or a
                tetrahedron&#39;s dihedral angles to the corresponding optimal
                angle. The optimal angle is defined as the angle an equilateral
                (and thus equiangular) element has. This is defined as

                $$ 1 - \max\left( \frac{\alpha - \alpha^*}{\pi - \alpha^*} , 0 \right),
                $$

                where \( \alpha \) is the corresponding (dihedral) angle of the element
                and \( \alpha^* \) is the corresponding (dihedral) angle of the reference
                element.

                Parameters
                ----------
                mesh : dolfin.cpp.mesh.Mesh
                        The mesh, whose quality shall be computed.

                Returns
                -------
                float
                        The minimum value of the maximum angle quality measure.
                &#34;&#34;&#34;

                return np.min(cls._quality_object.maximum_angle(mesh).array())



        @classmethod
        def avg_maximum_angle(cls, mesh):
                r&#34;&#34;&#34;Computes the average quality of the mesh based on the maximum angle.

                Parameters
                ----------
                mesh : dolfin.cpp.mesh.Mesh
                        The mesh, whose quality shall be computed.

                Returns
                -------
                float
                        The average quality, based on the maximum angle measure.
                &#34;&#34;&#34;

                return np.average(cls._quality_object.maximum_angle(mesh).array())


        @staticmethod
        def min_radius_ratios(mesh):
                r&#34;&#34;&#34;Computes the minimal radius ratio of the mesh.

                This measures the ratio of the element&#39;s inradius to it&#39;s circumradius,
                normalized by the geometric dimension. It is an element of \( [0,1] \),
                where 1 indicates best element quality and 0 is obtained for degenerate
                elements. This is computed via

                $$d \frac{r}{R},
                $$

                where \(d\) is the spatial dimension, \(r\) is the inradius, and \(R\) is
                the circumradius. To compute the (global) quality measure, the minimum
                of this expression over all elements is returned.

                Parameters
                ----------
                mesh : dolfin.cpp.mesh.Mesh
                        The mesh, whose radius ratios shall be computed.

                Returns
                -------
                float
                        The minimal radius ratio of the mesh.
                &#34;&#34;&#34;

                return np.min(fenics.MeshQuality.radius_ratios(mesh).array())



        @staticmethod
        def avg_radius_ratios(mesh):
                r&#34;&#34;&#34;Computes the average radius ratio of the mesh.

                Parameters
                ----------
                mesh : dolfin.cpp.mesh.Mesh
                        The mesh, whose quality shall be computed.

                Returns
                -------
                float
                        The average radius ratio of the mesh.
                &#34;&#34;&#34;

                return np.average(fenics.MeshQuality.radius_ratios(mesh).array())



        @staticmethod
        def min_condition_number(mesh):
                r&#34;&#34;&#34;Computes minimal mesh quality based on the condition number of the reference mapping.

                This quality criterion uses the condition number (in the Frobenius norm) of the
                (linear) mapping from the elements of the mesh to the reference element. Computes
                the minimum of the condition number over all elements.

                Parameters
                ----------
                mesh : dolfin.cpp.mesh.Mesh
                        The mesh, whose quality shall be computed.

                Returns
                -------
                float
                        The minimal condition number quality measure.
                &#34;&#34;&#34;

                DG0 = fenics.FunctionSpace(mesh, &#39;DG&#39;, 0)
                jac = Jacobian(mesh)
                inv = JacobianInverse(mesh)

                options = [[
                                [&#39;ksp_type&#39;, &#39;preonly&#39;],
                                [&#39;pc_type&#39;, &#39;jacobi&#39;],
                                [&#39;pc_jacobi_type&#39;, &#39;diagonal&#39;],
                                [&#39;ksp_rtol&#39;, 1e-16],
                                [&#39;ksp_atol&#39;, 1e-20],
                                [&#39;ksp_max_it&#39;, 1000]
                        ]]
                ksp = PETSc.KSP().create()
                _setup_petsc_options([ksp], options)

                dx = fenics.Measure(&#39;dx&#39;, mesh)
                a = fenics.TrialFunction(DG0)*fenics.TestFunction(DG0)*dx
                L = fenics.sqrt(fenics.inner(jac, jac))*fenics.sqrt(fenics.inner(inv, inv))*fenics.TestFunction(DG0)*dx

                cond = fenics.Function(DG0)

                A, b = _assemble_petsc_system(a, L)
                _solve_linear_problem(ksp, A, b, cond.vector().vec())

                return np.min(np.sqrt(mesh.geometric_dimension()) / cond.vector()[:])



        @staticmethod
        def avg_condition_number(mesh):
                &#34;&#34;&#34;Computes the average mesh quality based on the condition number of the reference mapping.

                Parameters
                ----------
                mesh : dolfin.cpp.mesh.Mesh
                        The mesh, whose quality shall be computed.

                Returns
                -------
                float
                        The average mesh quality based on the condition number.
                &#34;&#34;&#34;

                DG0 = fenics.FunctionSpace(mesh, &#39;DG&#39;, 0)
                jac = Jacobian(mesh)
                inv = JacobianInverse(mesh)

                options = [[
                                [&#39;ksp_type&#39;, &#39;preonly&#39;],
                                [&#39;pc_type&#39;, &#39;jacobi&#39;],
                                [&#39;pc_jacobi_type&#39;, &#39;diagonal&#39;],
                                [&#39;ksp_rtol&#39;, 1e-16],
                                [&#39;ksp_atol&#39;, 1e-20],
                                [&#39;ksp_max_it&#39;, 1000]
                        ]]
                ksp = PETSc.KSP().create()
                _setup_petsc_options([ksp], options)

                dx = fenics.Measure(&#39;dx&#39;, mesh)
                a = fenics.TrialFunction(DG0)*fenics.TestFunction(DG0)*dx
                L = fenics.sqrt(fenics.inner(jac, jac))*fenics.sqrt(fenics.inner(inv, inv))*fenics.TestFunction(DG0)*dx

                cond = fenics.Function(DG0)

                A, b = _assemble_petsc_system(a, L)
                _solve_linear_problem(ksp, A, b, cond.vector().vec())

                return np.average(np.sqrt(mesh.geometric_dimension()) / cond.vector()[:])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cashocs.geometry.import_mesh"><code class="name flex">
<span>def <span class="ident">import_mesh</span></span>(<span>arg)</span>
</code></dt>
<dd>
<div class="desc"><p>Imports a mesh file for use with cashocs / fenics.</p>
<p>This function imports a mesh file that was generated by GMSH and converted to
.xdmf with the command line function cashocs-convert (see cashocs main documentation).
The syntax for the conversion is</p>
<pre><code>cashocs-convert in.msh out.xdmf
</code></pre>
<p>If there are Physical quantities specified in the gmsh file, these are imported
to the subdomains and boundaries output of this function and can also be directly
accessed via the measures, e.g., with dx(1), ds(1), etc.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arg</code></strong> :&ensp;<code>str</code> or <code>configparser.ConfigParser</code></dt>
<dd>This is either a string, in which case it corresponds to the location
of the mesh file in .xdmf file format, or a config file that
has this path stored in its settings.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>dolfin.cpp.mesh.Mesh</code></dt>
<dd>The imported (computational) mesh.</dd>
<dt><strong><code>subdomains</code></strong> :&ensp;<code>dolfin.cpp.mesh.MeshFunctionSizet</code></dt>
<dd>A MeshFunction object containing the subdomains,
i.e., the Physical regions marked in the gmsh
file.</dd>
<dt><strong><code>boundaries</code></strong> :&ensp;<code>dolfin.cpp.mesh.MeshFunctionSizet</code></dt>
<dd>A MeshFunction object containing the boundaries,
i.e., the Physical regions marked in the gmsh
file. Can, e.g., be used to set up boundary
conditions.</dd>
<dt><strong><code>dx</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>The volume measure of the mesh corresponding to
the subdomains (i.e. gmsh Physical region indices).</dd>
<dt><strong><code>ds</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>The surface measure of the mesh corresponding to
the boundaries (i.e. gmsh Physical region indices).</dd>
<dt><strong><code>dS</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>The interior facet measure of the mesh corresponding
to boundaries (i.e. gmsh Physical region indices).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_mesh(arg):
        &#34;&#34;&#34;Imports a mesh file for use with cashocs / fenics.

        This function imports a mesh file that was generated by GMSH and converted to
        .xdmf with the command line function cashocs-convert (see cashocs main documentation).
        The syntax for the conversion is

            cashocs-convert in.msh out.xdmf

        If there are Physical quantities specified in the gmsh file, these are imported
        to the subdomains and boundaries output of this function and can also be directly
        accessed via the measures, e.g., with dx(1), ds(1), etc.

        Parameters
        ----------
        arg : str or configparser.ConfigParser
                This is either a string, in which case it corresponds to the location
                of the mesh file in .xdmf file format, or a config file that
                has this path stored in its settings.

        Returns
        -------
        mesh : dolfin.cpp.mesh.Mesh
                The imported (computational) mesh.
        subdomains : dolfin.cpp.mesh.MeshFunctionSizet
                A MeshFunction object containing the subdomains,
                i.e., the Physical regions marked in the gmsh
                file.
        boundaries : dolfin.cpp.mesh.MeshFunctionSizet
                A MeshFunction object containing the boundaries,
                i.e., the Physical regions marked in the gmsh
                file. Can, e.g., be used to set up boundary
                conditions.
        dx : ufl.measure.Measure
                The volume measure of the mesh corresponding to
                the subdomains (i.e. gmsh Physical region indices).
        ds : ufl.measure.Measure
                The surface measure of the mesh corresponding to
                the boundaries (i.e. gmsh Physical region indices).
        dS : ufl.measure.Measure
                The interior facet measure of the mesh corresponding
                to boundaries (i.e. gmsh Physical region indices).
        &#34;&#34;&#34;
        
        start_time = time.time()
        print(&#39;Importing mesh to FEniCS&#39;)
        # Check for the file format

        if type(arg) == str:
                mesh_file = arg
                mesh_attribute = &#39;str&#39;
        elif type(arg) == configparser.ConfigParser:
                mesh_attribute = &#39;config&#39;
                ### overloading for remeshing
                if not arg.getboolean(&#39;Mesh&#39;, &#39;remesh&#39;, fallback=False):
                        mesh_file = arg.get(&#39;Mesh&#39;, &#39;mesh_file&#39;)
                else:
                        if not (&#39;_cashocs_remesh_flag&#39; in sys.argv):
                                mesh_file = arg.get(&#39;Mesh&#39;, &#39;mesh_file&#39;)
                        else:
                                temp_dir = sys.argv[-1]
                                with open(temp_dir + &#39;/temp_dict.json&#39;, &#39;r&#39;) as file:
                                        temp_dict = json.load(file)
                                mesh_file = temp_dict[&#39;mesh_file&#39;]

        else:
                raise InputError(&#39;Not a valid argument for import_mesh.&#39;)

        if mesh_file[-5:] == &#39;.xdmf&#39;:
                file_string = mesh_file[:-5]
        else:
                raise InputError(&#39;Not a suitable mesh file format.&#39;)
        
        mesh = fenics.Mesh()
        xdmf_file = fenics.XDMFFile(mesh.mpi_comm(), mesh_file)
        xdmf_file.read(mesh)
        xdmf_file.close()
        
        subdomains_mvc = fenics.MeshValueCollection(&#39;size_t&#39;, mesh, mesh.geometric_dimension())
        boundaries_mvc = fenics.MeshValueCollection(&#39;size_t&#39;, mesh, mesh.geometric_dimension() - 1)

        if os.path.exists(file_string + &#39;_subdomains.xdmf&#39;):
                xdmf_subdomains = fenics.XDMFFile(mesh.mpi_comm(), file_string + &#39;_subdomains.xdmf&#39;)
                xdmf_subdomains.read(subdomains_mvc, &#39;subdomains&#39;)
                xdmf_subdomains.close()
        if os.path.exists(file_string + &#39;_boundaries.xdmf&#39;):
                xdmf_boundaries = fenics.XDMFFile(mesh.mpi_comm(), file_string + &#39;_boundaries.xdmf&#39;)
                xdmf_boundaries.read(boundaries_mvc, &#39;boundaries&#39;)
                xdmf_boundaries.close()

        subdomains = fenics.MeshFunction(&#39;size_t&#39;, mesh, subdomains_mvc)
        boundaries = fenics.MeshFunction(&#39;size_t&#39;, mesh, boundaries_mvc)

        dx = fenics.Measure(&#39;dx&#39;, domain=mesh, subdomain_data=subdomains)
        ds = fenics.Measure(&#39;ds&#39;, domain=mesh, subdomain_data=boundaries)
        dS = fenics.Measure(&#39;dS&#39;, domain=mesh, subdomain_data=boundaries)
        
        end_time = time.time()
        print(&#39;Done Importing Mesh. Elapsed Time: &#39; + format(end_time - start_time, &#39;.3e&#39;) + &#39; s&#39;)
        print(&#39;&#39;)

        # Add an attribute to the mesh to show with what procedure it was generated
        mesh._cashocs_generator = mesh_attribute

        return mesh, subdomains, boundaries, dx, ds, dS</code></pre>
</details>
</dd>
<dt id="cashocs.geometry.regular_box_mesh"><code class="name flex">
<span>def <span class="ident">regular_box_mesh</span></span>(<span>n=10, S_x=0.0, S_y=0.0, S_z=None, E_x=1.0, E_y=1.0, E_z=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a mesh corresponding to a rectangle or cube.</p>
<p>This function creates a uniform mesh of either a rectangle
or a cube, with specified start (S_) and end points (E_).
The resulting mesh uses n elements along the shortest direction
and accordingly many along the longer ones. The resulting domain is</p>
<p><span><span class="MathJax_Preview">[S_x, E_x] \times [S_y, E_y] \phantom{ \times [S_z, E_z] a} \quad \text{ in } 2D, \\
[S_x, E_x] \times [S_y, E_y] \times [S_z, E_z] \quad \text{ in } 3D.
</span><script type="math/tex; mode=display">[S_x, E_x] \times [S_y, E_y] \phantom{ \times [S_z, E_z] a} \quad \text{ in } 2D, \\
[S_x, E_x] \times [S_y, E_y] \times [S_z, E_z] \quad \text{ in } 3D.
</script></span></p>
<p>The boundary markers are ordered as follows:</p>
<ul>
<li>
<p>1 corresponds to <span><span class="MathJax_Preview">\{x=S_x\}</span><script type="math/tex">\{x=S_x\}</script></span>.</p>
</li>
<li>
<p>2 corresponds to <span><span class="MathJax_Preview">\{x=E_x\}</span><script type="math/tex">\{x=E_x\}</script></span>.</p>
</li>
<li>
<p>3 corresponds to <span><span class="MathJax_Preview">\{y=S_y\}</span><script type="math/tex">\{y=S_y\}</script></span>.</p>
</li>
<li>
<p>4 corresponds to <span><span class="MathJax_Preview">\{y=E_y\}</span><script type="math/tex">\{y=E_y\}</script></span>.</p>
</li>
<li>
<p>5 corresponds to <span><span class="MathJax_Preview">\{z=S_z\}</span><script type="math/tex">\{z=S_z\}</script></span> (only in 3D).</p>
</li>
<li>
<p>6 corresponds to <span><span class="MathJax_Preview">\{z=E_z\}</span><script type="math/tex">\{z=E_z\}</script></span> (only in 3D).</p>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of elements in the shortest coordinate direction.</dd>
<dt><strong><code>S_x</code></strong> :&ensp;<code>float</code></dt>
<dd>Start of the x-interval.</dd>
<dt><strong><code>S_y</code></strong> :&ensp;<code>float</code></dt>
<dd>Start of the y-interval.</dd>
<dt><strong><code>S_z</code></strong> :&ensp;<code>float</code> or <code>None</code>, optional</dt>
<dd>Start of the z-interval, mesh is 2D if this is None
(default is None).</dd>
<dt><strong><code>E_x</code></strong> :&ensp;<code>float</code></dt>
<dd>End of the x-interval.</dd>
<dt><strong><code>E_y</code></strong> :&ensp;<code>float</code></dt>
<dd>End of the y-interval.</dd>
<dt><strong><code>E_z</code></strong> :&ensp;<code>float</code> or <code>None</code>, optional</dt>
<dd>End of the z-interval, mesh is 2D if this is None
(default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>dolfin.cpp.mesh.Mesh</code></dt>
<dd>the computational mesh</dd>
<dt><strong><code>subdomains</code></strong> :&ensp;<code>dolfin.cpp.mesh.MeshFunctionSizet</code></dt>
<dd>a MeshFunction object containing the subdomains</dd>
<dt><strong><code>boundaries</code></strong> :&ensp;<code>dolfin.cpp.mesh.MeshFunctionSizet</code></dt>
<dd>a MeshFunction object containing the boundaries</dd>
<dt><strong><code>dx</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>the volume measure of the mesh corresponding to subdomains</dd>
<dt><strong><code>ds</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>the surface measure of the mesh corresponding to boundaries</dd>
<dt><strong><code>dS</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>the interior facet measure of the mesh corresponding to boundaries</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regular_box_mesh(n=10, S_x=0.0, S_y=0.0, S_z=None, E_x=1.0, E_y=1.0, E_z=None):
        r&#34;&#34;&#34;Creates a mesh corresponding to a rectangle or cube.

        This function creates a uniform mesh of either a rectangle
        or a cube, with specified start (S_) and end points (E_).
        The resulting mesh uses n elements along the shortest direction
        and accordingly many along the longer ones. The resulting domain is

        $$[S_x, E_x] \times [S_y, E_y] \phantom{ \times [S_z, E_z] a} \quad \text{ in } 2D, \\
        [S_x, E_x] \times [S_y, E_y] \times [S_z, E_z] \quad \text{ in } 3D.
        $$

        The boundary markers are ordered as follows:

          - 1 corresponds to \(\{x=S_x\}\).

          - 2 corresponds to \(\{x=E_x\}\).

          - 3 corresponds to \(\{y=S_y\}\).

          - 4 corresponds to \(\{y=E_y\}\).

          - 5 corresponds to \(\{z=S_z\}\) (only in 3D).

          - 6 corresponds to \(\{z=E_z\}\) (only in 3D).

        Parameters
        ----------
        n : int
                Number of elements in the shortest coordinate direction.
        S_x : float
                Start of the x-interval.
        S_y : float
                Start of the y-interval.
        S_z : float or None, optional
                Start of the z-interval, mesh is 2D if this is None
                (default is None).
        E_x : float
                End of the x-interval.
        E_y : float
                End of the y-interval.
        E_z : float or None, optional
                End of the z-interval, mesh is 2D if this is None
                (default is None).

        Returns
        -------
        mesh : dolfin.cpp.mesh.Mesh
                the computational mesh
        subdomains : dolfin.cpp.mesh.MeshFunctionSizet
                a MeshFunction object containing the subdomains
        boundaries : dolfin.cpp.mesh.MeshFunctionSizet
                a MeshFunction object containing the boundaries
        dx : ufl.measure.Measure
                the volume measure of the mesh corresponding to subdomains
        ds : ufl.measure.Measure
                the surface measure of the mesh corresponding to boundaries
        dS : ufl.measure.Measure
                the interior facet measure of the mesh corresponding to boundaries
        &#34;&#34;&#34;

        n = int(n)

        assert S_x &lt; E_x, &#39;Incorrect input for the x-coordinate&#39;
        assert S_y &lt; E_y, &#39;Incorrect input for the y-coordinate&#39;
        assert (S_z is None and E_z is None) or (S_z &lt; E_z), &#39;Incorrect input for the z-coordinate&#39;

        if S_z is None:
                lx = E_x - S_x
                ly = E_y - S_y
                sizes = [lx, ly]
                dim = 2
        else:
                lx = E_x - S_x
                ly = E_y - S_y
                lz = E_z - S_z
                sizes = [lx, ly, lz]
                dim = 3

        size_min = np.min(sizes)
        num_points = [int(np.round(length/size_min*n)) for length in sizes]

        if S_z is None:
                mesh = fenics.RectangleMesh(fenics.Point(S_x, S_y), fenics.Point(E_x, E_y), num_points[0], num_points[1])
        else:
                mesh = fenics.BoxMesh(fenics.Point(S_x, S_y, S_z), fenics.Point(E_x, E_y, E_z), num_points[0], num_points[1], num_points[2])

        subdomains = fenics.MeshFunction(&#39;size_t&#39;, mesh, dim=dim)
        boundaries = fenics.MeshFunction(&#39;size_t&#39;, mesh, dim=dim - 1)

        x_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[0], sx, tol)&#39;, tol=fenics.DOLFIN_EPS, sx=S_x)
        x_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[0], ex, tol)&#39;, tol=fenics.DOLFIN_EPS, ex=E_x)
        x_min.mark(boundaries, 1)
        x_max.mark(boundaries, 2)

        y_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[1], sy, tol)&#39;, tol=fenics.DOLFIN_EPS, sy=S_y)
        y_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[1], ey, tol)&#39;, tol=fenics.DOLFIN_EPS, ey=E_y)
        y_min.mark(boundaries, 3)
        y_max.mark(boundaries, 4)

        if S_z is not None:
                z_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[2], sz, tol)&#39;, tol=fenics.DOLFIN_EPS, sz=S_z)
                z_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[2], ez, tol)&#39;, tol=fenics.DOLFIN_EPS, ez=E_z)
                z_min.mark(boundaries, 5)
                z_max.mark(boundaries, 6)

        dx = fenics.Measure(&#39;dx&#39;, mesh, subdomain_data=subdomains)
        ds = fenics.Measure(&#39;ds&#39;, mesh, subdomain_data=boundaries)
        dS = fenics.Measure(&#39;dS&#39;, mesh)

        return mesh, subdomains, boundaries, dx, ds, dS</code></pre>
</details>
</dd>
<dt id="cashocs.geometry.regular_mesh"><code class="name flex">
<span>def <span class="ident">regular_mesh</span></span>(<span>n=10, L_x=1.0, L_y=1.0, L_z=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a mesh corresponding to a rectangle or cube.</p>
<p>This function creates a uniform mesh of either a rectangle
or a cube, starting at the origin and having length specified
in lx, lx, lz. The resulting mesh uses n elements along the
shortest direction and accordingly many along the longer ones.
The resulting domain is
<span><span class="MathJax_Preview">[0, L_x] \times [0, L_y] \phantom{ \times [0, L_z] a} \quad \text{ in } 2D, \\
[0, L_x] \times [0, L_y] \times [0, L_z] \quad \text{ in } 3D.
</span><script type="math/tex; mode=display">[0, L_x] \times [0, L_y] \phantom{ \times [0, L_z] a} \quad \text{ in } 2D, \\
[0, L_x] \times [0, L_y] \times [0, L_z] \quad \text{ in } 3D.
</script></span></p>
<p>The boundary markers are ordered as follows:</p>
<ul>
<li>
<p>1 corresponds to <span><span class="MathJax_Preview">\{x=0\}</span><script type="math/tex">\{x=0\}</script></span>.</p>
</li>
<li>
<p>2 corresponds to <span><span class="MathJax_Preview">\{x=L_x\}</span><script type="math/tex">\{x=L_x\}</script></span>.</p>
</li>
<li>
<p>3 corresponds to <span><span class="MathJax_Preview">\{y=0\}</span><script type="math/tex">\{y=0\}</script></span>.</p>
</li>
<li>
<p>4 corresponds to <span><span class="MathJax_Preview">\{y=L_y\}</span><script type="math/tex">\{y=L_y\}</script></span>.</p>
</li>
<li>
<p>5 corresponds to <span><span class="MathJax_Preview">\{z=0\}</span><script type="math/tex">\{z=0\}</script></span> (only in 3D).</p>
</li>
<li>
<p>6 corresponds to <span><span class="MathJax_Preview">\{z=L_z\}</span><script type="math/tex">\{z=L_z\}</script></span> (only in 3D).</p>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of elements in the shortest coordinate direction.</dd>
<dt><strong><code>L_x</code></strong> :&ensp;<code>float</code></dt>
<dd>Length in x-direction.</dd>
<dt><strong><code>L_y</code></strong> :&ensp;<code>float</code></dt>
<dd>Length in y-direction.</dd>
<dt><strong><code>L_z</code></strong> :&ensp;<code>float</code> or <code>None</code>, optional</dt>
<dd>Length in z-direction, if this is None, then the geometry
will be two-dimensional (default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>dolfin.cpp.mesh.Mesh</code></dt>
<dd>The computational mesh.</dd>
<dt><strong><code>subdomains</code></strong> :&ensp;<code>dolfin.cpp.mesh.MeshFunctionSizet</code></dt>
<dd>A MeshFunction object containing the subdomains.</dd>
<dt><strong><code>boundaries</code></strong> :&ensp;<code>dolfin.cpp.mesh.MeshFunctionSizet</code></dt>
<dd>A MeshFunction object containing the boundaries.</dd>
<dt><strong><code>dx</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>The volume measure of the mesh corresponding to subdomains.</dd>
<dt><strong><code>ds</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>The surface measure of the mesh corresponding to boundaries.</dd>
<dt><strong><code>dS</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>The interior facet measure of the mesh corresponding to boundaries.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regular_mesh(n=10, L_x=1.0, L_y=1.0, L_z=None):
        r&#34;&#34;&#34;Creates a mesh corresponding to a rectangle or cube.

        This function creates a uniform mesh of either a rectangle
        or a cube, starting at the origin and having length specified
        in lx, lx, lz. The resulting mesh uses n elements along the
        shortest direction and accordingly many along the longer ones.
        The resulting domain is
                $$[0, L_x] \times [0, L_y] \phantom{ \times [0, L_z] a} \quad \text{ in } 2D, \\
                [0, L_x] \times [0, L_y] \times [0, L_z] \quad \text{ in } 3D.
                $$

        The boundary markers are ordered as follows:

          - 1 corresponds to \(\{x=0\}\).

          - 2 corresponds to \(\{x=L_x\}\).

          - 3 corresponds to \(\{y=0\}\).

          - 4 corresponds to \(\{y=L_y\}\).

          - 5 corresponds to \(\{z=0\}\) (only in 3D).

          - 6 corresponds to \(\{z=L_z\}\) (only in 3D).

        Parameters
        ----------
        n : int
                Number of elements in the shortest coordinate direction.
        L_x : float
                Length in x-direction.
        L_y : float
                Length in y-direction.
        L_z : float or None, optional
                Length in z-direction, if this is None, then the geometry
                will be two-dimensional (default is None).

        Returns
        -------
        mesh : dolfin.cpp.mesh.Mesh
                The computational mesh.
        subdomains : dolfin.cpp.mesh.MeshFunctionSizet
                A MeshFunction object containing the subdomains.
        boundaries : dolfin.cpp.mesh.MeshFunctionSizet
                A MeshFunction object containing the boundaries.
        dx : ufl.measure.Measure
                The volume measure of the mesh corresponding to subdomains.
        ds : ufl.measure.Measure
                The surface measure of the mesh corresponding to boundaries.
        dS : ufl.measure.Measure
                The interior facet measure of the mesh corresponding to boundaries.
        &#34;&#34;&#34;

        n = int(n)
        
        if L_z is None:
                sizes = [L_x, L_y]
                dim = 2
        else:
                sizes = [L_x, L_y, L_z]
                dim = 3
        
        size_min = np.min(sizes)
        num_points = [int(np.round(length/size_min*n)) for length in sizes]
        
        if L_z is None:
                mesh = fenics.RectangleMesh(fenics.Point(0, 0), fenics.Point(sizes), num_points[0], num_points[1])
        else:
                mesh = fenics.BoxMesh(fenics.Point(0, 0, 0), fenics.Point(sizes), num_points[0], num_points[1], num_points[2])
        
        subdomains = fenics.MeshFunction(&#39;size_t&#39;, mesh, dim=dim)
        boundaries = fenics.MeshFunction(&#39;size_t&#39;, mesh, dim=dim - 1)
        
        x_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[0], 0, tol)&#39;, tol=fenics.DOLFIN_EPS)
        x_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[0], length, tol)&#39;, tol=fenics.DOLFIN_EPS, length=sizes[0])
        x_min.mark(boundaries, 1)
        x_max.mark(boundaries, 2)

        y_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[1], 0, tol)&#39;, tol=fenics.DOLFIN_EPS)
        y_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[1], length, tol)&#39;, tol=fenics.DOLFIN_EPS, length=sizes[1])
        y_min.mark(boundaries, 3)
        y_max.mark(boundaries, 4)

        if L_z is not None:
                z_min = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[2], 0, tol)&#39;, tol=fenics.DOLFIN_EPS)
                z_max = fenics.CompiledSubDomain(&#39;on_boundary &amp;&amp; near(x[2], length, tol)&#39;, tol=fenics.DOLFIN_EPS, length=sizes[2])
                z_min.mark(boundaries, 5)
                z_max.mark(boundaries, 6)
        
        dx = fenics.Measure(&#39;dx&#39;, mesh, subdomain_data=subdomains)
        ds = fenics.Measure(&#39;ds&#39;, mesh, subdomain_data=boundaries)
        dS = fenics.Measure(&#39;dS&#39;, mesh)
        
        return mesh, subdomains, boundaries, dx, ds, dS</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cashocs.geometry.MeshQuality"><code class="flex name class">
<span>class <span class="ident">MeshQuality</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class used to compute the quality of a mesh.</p>
<p>This class implements either a skewness quality measure, one based
on the maximum angle of the elements, or one based on the radius ratios.
All quality measures have values in <span><span class="MathJax_Preview"> [0, 1] </span><script type="math/tex"> [0, 1] </script></span>, where 1 corresponds
to the best / perfect element, and 0 corresponds to degenerate elements.</p>
<h2 id="examples">Examples</h2>
<p>This class can be directly used, without any instantiation.</p>
<pre><code>import cashocs

mesh, _, _, _, _, _ = cashocs.regular_mesh(10)

min_skew = cashocs.MeshQuality.min_skewness(mesh)
avg_skew = cashocs.MeshQuality.avg_skewness(mesh)

min_angle = cashocs.MeshQuality.min_maximum_angle(mesh)
avg_angle = cashocs.MeshQuality.avg_maximum_angle(mesh)

min_rad = cashocs.MeshQuality.min_radius_ratios(mesh)
avg_rad = cashocs.MeshQuality.avg_radius_ratios(mesh)

min_cond = cashocs.MeshQuality.min_condition_number(mesh)
avg_cond = cashocs.MeshQuality.avg_condition_number(mesh)
</code></pre>
<p>This works analogously for any mesh compatible with fenics.</p>
<p>Initializes self.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MeshQuality:
        r&#34;&#34;&#34;A class used to compute the quality of a mesh.

        This class implements either a skewness quality measure, one based
        on the maximum angle of the elements, or one based on the radius ratios.
        All quality measures have values in \( [0, 1] \), where 1 corresponds
        to the best / perfect element, and 0 corresponds to degenerate elements.

        Examples
        --------
        This class can be directly used, without any instantiation.

            import cashocs

            mesh, _, _, _, _, _ = cashocs.regular_mesh(10)

            min_skew = cashocs.MeshQuality.min_skewness(mesh)
            avg_skew = cashocs.MeshQuality.avg_skewness(mesh)

            min_angle = cashocs.MeshQuality.min_maximum_angle(mesh)
            avg_angle = cashocs.MeshQuality.avg_maximum_angle(mesh)

            min_rad = cashocs.MeshQuality.min_radius_ratios(mesh)
            avg_rad = cashocs.MeshQuality.avg_radius_ratios(mesh)

            min_cond = cashocs.MeshQuality.min_condition_number(mesh)
            avg_cond = cashocs.MeshQuality.avg_condition_number(mesh)

        This works analogously for any mesh compatible with fenics.
        &#34;&#34;&#34;

        _cpp_code_mesh_quality = &#34;&#34;&#34;
                        #include &lt;pybind11/pybind11.h&gt;
                        #include &lt;pybind11/eigen.h&gt;
                        namespace py = pybind11;
                        
                        #include &lt;dolfin/mesh/Mesh.h&gt;
                        #include &lt;dolfin/mesh/Vertex.h&gt;
                        #include &lt;dolfin/mesh/MeshFunction.h&gt;
                        #include &lt;dolfin/mesh/Cell.h&gt;
                        #include &lt;dolfin/mesh/Vertex.h&gt;
                        
                        using namespace dolfin;
                        
                        
                        void angles_triangle(const Cell&amp; cell, std::vector&lt;double&gt;&amp; angs)
                        {
                          const Mesh&amp; mesh = cell.mesh();
                          angs.resize(3);
                          const std::size_t i0 = cell.entities(0)[0];
                          const std::size_t i1 = cell.entities(0)[1];
                          const std::size_t i2 = cell.entities(0)[2];
                          
                          const Point p0 = Vertex(mesh, i0).point();
                          const Point p1 = Vertex(mesh, i1).point();
                          const Point p2 = Vertex(mesh, i2).point();
                          Point e0 = p1 - p0;
                          Point e1 = p2 - p0;
                          Point e2 = p2 - p1;
                          
                          e0 /= e0.norm();
                          e1 /= e1.norm();
                          e2 /= e2.norm();
                        
                          angs[0] = acos(e0.dot(e1));
                          angs[1] = acos(e0.dot(e2));
                          angs[2] = acos(e1.dot(e2));
                        }
                        
                        
                        
                        void dihedral_angles(const Cell&amp; cell, std::vector&lt;double&gt;&amp; angs)
                        {
                          const Mesh&amp; mesh = cell.mesh();
                          angs.resize(6);
                          
                          const std::size_t i0 = cell.entities(0)[0];
                          const std::size_t i1 = cell.entities(0)[1];
                          const std::size_t i2 = cell.entities(0)[2];
                          const std::size_t i3 = cell.entities(0)[3];
                          
                          const Point p0 = Vertex(mesh, i0).point();
                          const Point p1 = Vertex(mesh, i1).point();
                          const Point p2 = Vertex(mesh, i2).point();
                          const Point p3 = Vertex(mesh, i3).point();
                          
                          const Point e0 = p1 - p0;
                          const Point e1 = p2 - p0;
                          const Point e2 = p3 - p0;
                          const Point e3 = p2 - p1;
                          const Point e4 = p3 - p1;
                          
                          Point n0 = e0.cross(e1);
                          Point n1 = e0.cross(e2);
                          Point n2 = e1.cross(e2);
                          Point n3 = e3.cross(e4);
                          
                          n0 /= n0.norm();
                          n1 /= n1.norm();
                          n2 /= n2.norm();
                          n3 /= n3.norm();
                          
                          angs[0] = acos(n0.dot(n1));
                          angs[1] = acos(-n0.dot(n2));
                          angs[2] = acos(n1.dot(n2));
                          angs[3] = acos(n0.dot(n3));
                          angs[4] = acos(n1.dot(-n3));
                          angs[5] = acos(n2.dot(n3));
                        }
                        
                        
                        
                        dolfin::MeshFunction&lt;double&gt;
                        skewness(std::shared_ptr&lt;const Mesh&gt; mesh)
                        {
                          MeshFunction&lt;double&gt; cf(mesh, mesh-&gt;topology().dim(), 0.0);
                          
                          double opt_angle;
                          std::vector&lt;double&gt; angs;
                          std::vector&lt;double&gt; quals;
                          
                          for (CellIterator cell(*mesh); !cell.end(); ++cell)
                          {
                                if (cell-&gt;dim() == 2)
                                {
                                  quals.resize(3);
                                  angles_triangle(*cell, angs);
                                  opt_angle = DOLFIN_PI / 3.0;
                                }
                                else if (cell-&gt;dim() == 3)
                                {
                                  quals.resize(6);
                                  dihedral_angles(*cell, angs);
                                  opt_angle = acos(1.0/3.0);
                                }
                                else
                                {
                                  dolfin_error(&#34;cashocs_quality.cpp&#34;, &#34;skewness&#34;, &#34;Not a valid dimension for the mesh.&#34;);
                                }
                                
                                for (unsigned int i = 0; i &lt; angs.size(); ++i)
                                {
                                  quals[i] = 1 - std::max((angs[i] - opt_angle) / (DOLFIN_PI - opt_angle), (opt_angle - angs[i]) / opt_angle);
                                }
                                cf[*cell] = *std::min_element(quals.begin(), quals.end());
                          }
                          return cf;
                        }
                        
                        
                        
                        dolfin::MeshFunction&lt;double&gt;
                        maximum_angle(std::shared_ptr&lt;const Mesh&gt; mesh)
                        {
                          MeshFunction&lt;double&gt; cf(mesh, mesh-&gt;topology().dim(), 0.0);
                          
                          double opt_angle;
                          std::vector&lt;double&gt; angs;
                          std::vector&lt;double&gt; quals;
                          
                          for (CellIterator cell(*mesh); !cell.end(); ++cell)
                          {
                                if (cell-&gt;dim() == 2)
                                {
                                  quals.resize(3);
                                  angles_triangle(*cell, angs);
                                  opt_angle = DOLFIN_PI / 3.0;
                                }
                                else if (cell-&gt;dim() == 3)
                                {
                                  quals.resize(6);
                                  dihedral_angles(*cell, angs);
                                  opt_angle = acos(1.0/3.0);
                                }
                                else
                                {
                                  dolfin_error(&#34;cashocs_quality.cpp&#34;, &#34;maximum_angle&#34;, &#34;Not a valid dimension for the mesh.&#34;);
                                }
                                
                                for (unsigned int i = 0; i &lt; angs.size(); ++i)
                                {
                                  quals[i] = 1 - std::max((angs[i] - opt_angle) / (DOLFIN_PI - opt_angle), 0.0);
                                }
                                cf[*cell] = *std::min_element(quals.begin(), quals.end());
                          }
                          return cf;
                        }
                        
                        PYBIND11_MODULE(SIGNATURE, m)
                        {
                          m.def(&#34;skewness&#34;, &amp;skewness);
                          m.def(&#34;maximum_angle&#34;, &amp;maximum_angle);
                        }
                
                &#34;&#34;&#34;
        _quality_object = fenics.compile_cpp_code(_cpp_code_mesh_quality)



        def __init__(self):
                &#34;&#34;&#34;Initializes self.

                &#34;&#34;&#34;
                pass



        @classmethod
        def min_skewness(cls, mesh):
                r&#34;&#34;&#34;Computes the minimal skewness of the mesh.

                This measure the relative distance of a triangle&#39;s angles or
                a tetrahedrons dihedral angles to the corresponding optimal
                angle. The optimal angle is defined as the angle an equilateral,
                and thus equiangular, element has. The skewness lies in
                \( [0,1] \), where 1 corresponds to the case of an optimal
                (equilateral) element, and 0 corresponds to a degenerate
                element. The skewness corresponding to some (dihedral) angle
                \( \alpha \) is defined as

                $$ 1 - \max \left( \frac{\alpha - \alpha^*}{\pi - \alpha*} , \frac{\alpha^* - \alpha}{\alpha^* - 0} \right),
                $$

                where \( \alpha^* \) is the corresponding optimal angle of the reference
                element. To compute the quality measure, the minimum of this expression
                over all elements and all of their (dihedral) angles is computed.

                Parameters
                ----------
                mesh : dolfin.cpp.mesh.Mesh
                        The mesh whose quality shall be computed.

                Returns
                -------
                float
                        The skewness of the mesh.
                &#34;&#34;&#34;

                return np.min(cls._quality_object.skewness(mesh).array())



        @classmethod
        def avg_skewness(cls, mesh):
                r&#34;&#34;&#34;Computes the average skewness of the mesh.

                The skewness corresponding to some (dihedral) angle
                \( \alpha \) is defined as

                $$ 1 - \max \left( \frac{\alpha - \alpha^*}{\pi - \alpha*} , \frac{\alpha^* - \alpha}{\alpha^* - 0} \right),
                $$

                where \( \alpha^* \) is the corresponding optimal angle of the reference
                element.

                Parameters
                ----------
                mesh : dolfin.cpp.mesh.Mesh
                        The mesh, whose quality shall be computed.

                Returns
                -------
                flat
                        The average skewness of the mesh.
                &#34;&#34;&#34;

                return np.average(cls._quality_object.skewness(mesh).array())



        @classmethod
        def min_maximum_angle(cls, mesh):
                r&#34;&#34;&#34;Computes the minimal quality measure based on the largest angle.

                This measures the relative distance of a triangle&#39;s angles or a
                tetrahedron&#39;s dihedral angles to the corresponding optimal
                angle. The optimal angle is defined as the angle an equilateral
                (and thus equiangular) element has. This is defined as

                $$ 1 - \max\left( \frac{\alpha - \alpha^*}{\pi - \alpha^*} , 0 \right),
                $$

                where \( \alpha \) is the corresponding (dihedral) angle of the element
                and \( \alpha^* \) is the corresponding (dihedral) angle of the reference
                element.

                Parameters
                ----------
                mesh : dolfin.cpp.mesh.Mesh
                        The mesh, whose quality shall be computed.

                Returns
                -------
                float
                        The minimum value of the maximum angle quality measure.
                &#34;&#34;&#34;

                return np.min(cls._quality_object.maximum_angle(mesh).array())



        @classmethod
        def avg_maximum_angle(cls, mesh):
                r&#34;&#34;&#34;Computes the average quality of the mesh based on the maximum angle.

                Parameters
                ----------
                mesh : dolfin.cpp.mesh.Mesh
                        The mesh, whose quality shall be computed.

                Returns
                -------
                float
                        The average quality, based on the maximum angle measure.
                &#34;&#34;&#34;

                return np.average(cls._quality_object.maximum_angle(mesh).array())


        @staticmethod
        def min_radius_ratios(mesh):
                r&#34;&#34;&#34;Computes the minimal radius ratio of the mesh.

                This measures the ratio of the element&#39;s inradius to it&#39;s circumradius,
                normalized by the geometric dimension. It is an element of \( [0,1] \),
                where 1 indicates best element quality and 0 is obtained for degenerate
                elements. This is computed via

                $$d \frac{r}{R},
                $$

                where \(d\) is the spatial dimension, \(r\) is the inradius, and \(R\) is
                the circumradius. To compute the (global) quality measure, the minimum
                of this expression over all elements is returned.

                Parameters
                ----------
                mesh : dolfin.cpp.mesh.Mesh
                        The mesh, whose radius ratios shall be computed.

                Returns
                -------
                float
                        The minimal radius ratio of the mesh.
                &#34;&#34;&#34;

                return np.min(fenics.MeshQuality.radius_ratios(mesh).array())



        @staticmethod
        def avg_radius_ratios(mesh):
                r&#34;&#34;&#34;Computes the average radius ratio of the mesh.

                Parameters
                ----------
                mesh : dolfin.cpp.mesh.Mesh
                        The mesh, whose quality shall be computed.

                Returns
                -------
                float
                        The average radius ratio of the mesh.
                &#34;&#34;&#34;

                return np.average(fenics.MeshQuality.radius_ratios(mesh).array())



        @staticmethod
        def min_condition_number(mesh):
                r&#34;&#34;&#34;Computes minimal mesh quality based on the condition number of the reference mapping.

                This quality criterion uses the condition number (in the Frobenius norm) of the
                (linear) mapping from the elements of the mesh to the reference element. Computes
                the minimum of the condition number over all elements.

                Parameters
                ----------
                mesh : dolfin.cpp.mesh.Mesh
                        The mesh, whose quality shall be computed.

                Returns
                -------
                float
                        The minimal condition number quality measure.
                &#34;&#34;&#34;

                DG0 = fenics.FunctionSpace(mesh, &#39;DG&#39;, 0)
                jac = Jacobian(mesh)
                inv = JacobianInverse(mesh)

                options = [[
                                [&#39;ksp_type&#39;, &#39;preonly&#39;],
                                [&#39;pc_type&#39;, &#39;jacobi&#39;],
                                [&#39;pc_jacobi_type&#39;, &#39;diagonal&#39;],
                                [&#39;ksp_rtol&#39;, 1e-16],
                                [&#39;ksp_atol&#39;, 1e-20],
                                [&#39;ksp_max_it&#39;, 1000]
                        ]]
                ksp = PETSc.KSP().create()
                _setup_petsc_options([ksp], options)

                dx = fenics.Measure(&#39;dx&#39;, mesh)
                a = fenics.TrialFunction(DG0)*fenics.TestFunction(DG0)*dx
                L = fenics.sqrt(fenics.inner(jac, jac))*fenics.sqrt(fenics.inner(inv, inv))*fenics.TestFunction(DG0)*dx

                cond = fenics.Function(DG0)

                A, b = _assemble_petsc_system(a, L)
                _solve_linear_problem(ksp, A, b, cond.vector().vec())

                return np.min(np.sqrt(mesh.geometric_dimension()) / cond.vector()[:])



        @staticmethod
        def avg_condition_number(mesh):
                &#34;&#34;&#34;Computes the average mesh quality based on the condition number of the reference mapping.

                Parameters
                ----------
                mesh : dolfin.cpp.mesh.Mesh
                        The mesh, whose quality shall be computed.

                Returns
                -------
                float
                        The average mesh quality based on the condition number.
                &#34;&#34;&#34;

                DG0 = fenics.FunctionSpace(mesh, &#39;DG&#39;, 0)
                jac = Jacobian(mesh)
                inv = JacobianInverse(mesh)

                options = [[
                                [&#39;ksp_type&#39;, &#39;preonly&#39;],
                                [&#39;pc_type&#39;, &#39;jacobi&#39;],
                                [&#39;pc_jacobi_type&#39;, &#39;diagonal&#39;],
                                [&#39;ksp_rtol&#39;, 1e-16],
                                [&#39;ksp_atol&#39;, 1e-20],
                                [&#39;ksp_max_it&#39;, 1000]
                        ]]
                ksp = PETSc.KSP().create()
                _setup_petsc_options([ksp], options)

                dx = fenics.Measure(&#39;dx&#39;, mesh)
                a = fenics.TrialFunction(DG0)*fenics.TestFunction(DG0)*dx
                L = fenics.sqrt(fenics.inner(jac, jac))*fenics.sqrt(fenics.inner(inv, inv))*fenics.TestFunction(DG0)*dx

                cond = fenics.Function(DG0)

                A, b = _assemble_petsc_system(a, L)
                _solve_linear_problem(ksp, A, b, cond.vector().vec())

                return np.average(np.sqrt(mesh.geometric_dimension()) / cond.vector()[:])</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="cashocs.geometry.MeshQuality.avg_condition_number"><code class="name flex">
<span>def <span class="ident">avg_condition_number</span></span>(<span>mesh)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the average mesh quality based on the condition number of the reference mapping.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>dolfin.cpp.mesh.Mesh</code></dt>
<dd>The mesh, whose quality shall be computed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The average mesh quality based on the condition number.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def avg_condition_number(mesh):
        &#34;&#34;&#34;Computes the average mesh quality based on the condition number of the reference mapping.

        Parameters
        ----------
        mesh : dolfin.cpp.mesh.Mesh
                The mesh, whose quality shall be computed.

        Returns
        -------
        float
                The average mesh quality based on the condition number.
        &#34;&#34;&#34;

        DG0 = fenics.FunctionSpace(mesh, &#39;DG&#39;, 0)
        jac = Jacobian(mesh)
        inv = JacobianInverse(mesh)

        options = [[
                        [&#39;ksp_type&#39;, &#39;preonly&#39;],
                        [&#39;pc_type&#39;, &#39;jacobi&#39;],
                        [&#39;pc_jacobi_type&#39;, &#39;diagonal&#39;],
                        [&#39;ksp_rtol&#39;, 1e-16],
                        [&#39;ksp_atol&#39;, 1e-20],
                        [&#39;ksp_max_it&#39;, 1000]
                ]]
        ksp = PETSc.KSP().create()
        _setup_petsc_options([ksp], options)

        dx = fenics.Measure(&#39;dx&#39;, mesh)
        a = fenics.TrialFunction(DG0)*fenics.TestFunction(DG0)*dx
        L = fenics.sqrt(fenics.inner(jac, jac))*fenics.sqrt(fenics.inner(inv, inv))*fenics.TestFunction(DG0)*dx

        cond = fenics.Function(DG0)

        A, b = _assemble_petsc_system(a, L)
        _solve_linear_problem(ksp, A, b, cond.vector().vec())

        return np.average(np.sqrt(mesh.geometric_dimension()) / cond.vector()[:])</code></pre>
</details>
</dd>
<dt id="cashocs.geometry.MeshQuality.avg_maximum_angle"><code class="name flex">
<span>def <span class="ident">avg_maximum_angle</span></span>(<span>mesh)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the average quality of the mesh based on the maximum angle.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>dolfin.cpp.mesh.Mesh</code></dt>
<dd>The mesh, whose quality shall be computed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The average quality, based on the maximum angle measure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def avg_maximum_angle(cls, mesh):
        r&#34;&#34;&#34;Computes the average quality of the mesh based on the maximum angle.

        Parameters
        ----------
        mesh : dolfin.cpp.mesh.Mesh
                The mesh, whose quality shall be computed.

        Returns
        -------
        float
                The average quality, based on the maximum angle measure.
        &#34;&#34;&#34;

        return np.average(cls._quality_object.maximum_angle(mesh).array())</code></pre>
</details>
</dd>
<dt id="cashocs.geometry.MeshQuality.avg_radius_ratios"><code class="name flex">
<span>def <span class="ident">avg_radius_ratios</span></span>(<span>mesh)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the average radius ratio of the mesh.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>dolfin.cpp.mesh.Mesh</code></dt>
<dd>The mesh, whose quality shall be computed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The average radius ratio of the mesh.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def avg_radius_ratios(mesh):
        r&#34;&#34;&#34;Computes the average radius ratio of the mesh.

        Parameters
        ----------
        mesh : dolfin.cpp.mesh.Mesh
                The mesh, whose quality shall be computed.

        Returns
        -------
        float
                The average radius ratio of the mesh.
        &#34;&#34;&#34;

        return np.average(fenics.MeshQuality.radius_ratios(mesh).array())</code></pre>
</details>
</dd>
<dt id="cashocs.geometry.MeshQuality.avg_skewness"><code class="name flex">
<span>def <span class="ident">avg_skewness</span></span>(<span>mesh)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the average skewness of the mesh.</p>
<p>The skewness corresponding to some (dihedral) angle
<span><span class="MathJax_Preview"> \alpha </span><script type="math/tex"> \alpha </script></span> is defined as</p>
<p><span><span class="MathJax_Preview"> 1 - \max \left( \frac{\alpha - \alpha^*}{\pi - \alpha*} , \frac{\alpha^* - \alpha}{\alpha^* - 0} \right),
</span><script type="math/tex; mode=display"> 1 - \max \left( \frac{\alpha - \alpha^*}{\pi - \alpha*} , \frac{\alpha^* - \alpha}{\alpha^* - 0} \right),
</script></span></p>
<p>where <span><span class="MathJax_Preview"> \alpha^* </span><script type="math/tex"> \alpha^* </script></span> is the corresponding optimal angle of the reference
element.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>dolfin.cpp.mesh.Mesh</code></dt>
<dd>The mesh, whose quality shall be computed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>flat</code></dt>
<dd>The average skewness of the mesh.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def avg_skewness(cls, mesh):
        r&#34;&#34;&#34;Computes the average skewness of the mesh.

        The skewness corresponding to some (dihedral) angle
        \( \alpha \) is defined as

        $$ 1 - \max \left( \frac{\alpha - \alpha^*}{\pi - \alpha*} , \frac{\alpha^* - \alpha}{\alpha^* - 0} \right),
        $$

        where \( \alpha^* \) is the corresponding optimal angle of the reference
        element.

        Parameters
        ----------
        mesh : dolfin.cpp.mesh.Mesh
                The mesh, whose quality shall be computed.

        Returns
        -------
        flat
                The average skewness of the mesh.
        &#34;&#34;&#34;

        return np.average(cls._quality_object.skewness(mesh).array())</code></pre>
</details>
</dd>
<dt id="cashocs.geometry.MeshQuality.min_condition_number"><code class="name flex">
<span>def <span class="ident">min_condition_number</span></span>(<span>mesh)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes minimal mesh quality based on the condition number of the reference mapping.</p>
<p>This quality criterion uses the condition number (in the Frobenius norm) of the
(linear) mapping from the elements of the mesh to the reference element. Computes
the minimum of the condition number over all elements.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>dolfin.cpp.mesh.Mesh</code></dt>
<dd>The mesh, whose quality shall be computed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The minimal condition number quality measure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def min_condition_number(mesh):
        r&#34;&#34;&#34;Computes minimal mesh quality based on the condition number of the reference mapping.

        This quality criterion uses the condition number (in the Frobenius norm) of the
        (linear) mapping from the elements of the mesh to the reference element. Computes
        the minimum of the condition number over all elements.

        Parameters
        ----------
        mesh : dolfin.cpp.mesh.Mesh
                The mesh, whose quality shall be computed.

        Returns
        -------
        float
                The minimal condition number quality measure.
        &#34;&#34;&#34;

        DG0 = fenics.FunctionSpace(mesh, &#39;DG&#39;, 0)
        jac = Jacobian(mesh)
        inv = JacobianInverse(mesh)

        options = [[
                        [&#39;ksp_type&#39;, &#39;preonly&#39;],
                        [&#39;pc_type&#39;, &#39;jacobi&#39;],
                        [&#39;pc_jacobi_type&#39;, &#39;diagonal&#39;],
                        [&#39;ksp_rtol&#39;, 1e-16],
                        [&#39;ksp_atol&#39;, 1e-20],
                        [&#39;ksp_max_it&#39;, 1000]
                ]]
        ksp = PETSc.KSP().create()
        _setup_petsc_options([ksp], options)

        dx = fenics.Measure(&#39;dx&#39;, mesh)
        a = fenics.TrialFunction(DG0)*fenics.TestFunction(DG0)*dx
        L = fenics.sqrt(fenics.inner(jac, jac))*fenics.sqrt(fenics.inner(inv, inv))*fenics.TestFunction(DG0)*dx

        cond = fenics.Function(DG0)

        A, b = _assemble_petsc_system(a, L)
        _solve_linear_problem(ksp, A, b, cond.vector().vec())

        return np.min(np.sqrt(mesh.geometric_dimension()) / cond.vector()[:])</code></pre>
</details>
</dd>
<dt id="cashocs.geometry.MeshQuality.min_maximum_angle"><code class="name flex">
<span>def <span class="ident">min_maximum_angle</span></span>(<span>mesh)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the minimal quality measure based on the largest angle.</p>
<p>This measures the relative distance of a triangle's angles or a
tetrahedron's dihedral angles to the corresponding optimal
angle. The optimal angle is defined as the angle an equilateral
(and thus equiangular) element has. This is defined as</p>
<p><span><span class="MathJax_Preview"> 1 - \max\left( \frac{\alpha - \alpha^*}{\pi - \alpha^*} , 0 \right),
</span><script type="math/tex; mode=display"> 1 - \max\left( \frac{\alpha - \alpha^*}{\pi - \alpha^*} , 0 \right),
</script></span></p>
<p>where <span><span class="MathJax_Preview"> \alpha </span><script type="math/tex"> \alpha </script></span> is the corresponding (dihedral) angle of the element
and <span><span class="MathJax_Preview"> \alpha^* </span><script type="math/tex"> \alpha^* </script></span> is the corresponding (dihedral) angle of the reference
element.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>dolfin.cpp.mesh.Mesh</code></dt>
<dd>The mesh, whose quality shall be computed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The minimum value of the maximum angle quality measure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def min_maximum_angle(cls, mesh):
        r&#34;&#34;&#34;Computes the minimal quality measure based on the largest angle.

        This measures the relative distance of a triangle&#39;s angles or a
        tetrahedron&#39;s dihedral angles to the corresponding optimal
        angle. The optimal angle is defined as the angle an equilateral
        (and thus equiangular) element has. This is defined as

        $$ 1 - \max\left( \frac{\alpha - \alpha^*}{\pi - \alpha^*} , 0 \right),
        $$

        where \( \alpha \) is the corresponding (dihedral) angle of the element
        and \( \alpha^* \) is the corresponding (dihedral) angle of the reference
        element.

        Parameters
        ----------
        mesh : dolfin.cpp.mesh.Mesh
                The mesh, whose quality shall be computed.

        Returns
        -------
        float
                The minimum value of the maximum angle quality measure.
        &#34;&#34;&#34;

        return np.min(cls._quality_object.maximum_angle(mesh).array())</code></pre>
</details>
</dd>
<dt id="cashocs.geometry.MeshQuality.min_radius_ratios"><code class="name flex">
<span>def <span class="ident">min_radius_ratios</span></span>(<span>mesh)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the minimal radius ratio of the mesh.</p>
<p>This measures the ratio of the element's inradius to it's circumradius,
normalized by the geometric dimension. It is an element of <span><span class="MathJax_Preview"> [0,1] </span><script type="math/tex"> [0,1] </script></span>,
where 1 indicates best element quality and 0 is obtained for degenerate
elements. This is computed via</p>
<p><span><span class="MathJax_Preview">d \frac{r}{R},
</span><script type="math/tex; mode=display">d \frac{r}{R},
</script></span></p>
<p>where <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span> is the spatial dimension, <span><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span> is the inradius, and <span><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span> is
the circumradius. To compute the (global) quality measure, the minimum
of this expression over all elements is returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>dolfin.cpp.mesh.Mesh</code></dt>
<dd>The mesh, whose radius ratios shall be computed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The minimal radius ratio of the mesh.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def min_radius_ratios(mesh):
        r&#34;&#34;&#34;Computes the minimal radius ratio of the mesh.

        This measures the ratio of the element&#39;s inradius to it&#39;s circumradius,
        normalized by the geometric dimension. It is an element of \( [0,1] \),
        where 1 indicates best element quality and 0 is obtained for degenerate
        elements. This is computed via

        $$d \frac{r}{R},
        $$

        where \(d\) is the spatial dimension, \(r\) is the inradius, and \(R\) is
        the circumradius. To compute the (global) quality measure, the minimum
        of this expression over all elements is returned.

        Parameters
        ----------
        mesh : dolfin.cpp.mesh.Mesh
                The mesh, whose radius ratios shall be computed.

        Returns
        -------
        float
                The minimal radius ratio of the mesh.
        &#34;&#34;&#34;

        return np.min(fenics.MeshQuality.radius_ratios(mesh).array())</code></pre>
</details>
</dd>
<dt id="cashocs.geometry.MeshQuality.min_skewness"><code class="name flex">
<span>def <span class="ident">min_skewness</span></span>(<span>mesh)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the minimal skewness of the mesh.</p>
<p>This measure the relative distance of a triangle's angles or
a tetrahedrons dihedral angles to the corresponding optimal
angle. The optimal angle is defined as the angle an equilateral,
and thus equiangular, element has. The skewness lies in
<span><span class="MathJax_Preview"> [0,1] </span><script type="math/tex"> [0,1] </script></span>, where 1 corresponds to the case of an optimal
(equilateral) element, and 0 corresponds to a degenerate
element. The skewness corresponding to some (dihedral) angle
<span><span class="MathJax_Preview"> \alpha </span><script type="math/tex"> \alpha </script></span> is defined as</p>
<p><span><span class="MathJax_Preview"> 1 - \max \left( \frac{\alpha - \alpha^*}{\pi - \alpha*} , \frac{\alpha^* - \alpha}{\alpha^* - 0} \right),
</span><script type="math/tex; mode=display"> 1 - \max \left( \frac{\alpha - \alpha^*}{\pi - \alpha*} , \frac{\alpha^* - \alpha}{\alpha^* - 0} \right),
</script></span></p>
<p>where <span><span class="MathJax_Preview"> \alpha^* </span><script type="math/tex"> \alpha^* </script></span> is the corresponding optimal angle of the reference
element. To compute the quality measure, the minimum of this expression
over all elements and all of their (dihedral) angles is computed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>dolfin.cpp.mesh.Mesh</code></dt>
<dd>The mesh whose quality shall be computed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The skewness of the mesh.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def min_skewness(cls, mesh):
        r&#34;&#34;&#34;Computes the minimal skewness of the mesh.

        This measure the relative distance of a triangle&#39;s angles or
        a tetrahedrons dihedral angles to the corresponding optimal
        angle. The optimal angle is defined as the angle an equilateral,
        and thus equiangular, element has. The skewness lies in
        \( [0,1] \), where 1 corresponds to the case of an optimal
        (equilateral) element, and 0 corresponds to a degenerate
        element. The skewness corresponding to some (dihedral) angle
        \( \alpha \) is defined as

        $$ 1 - \max \left( \frac{\alpha - \alpha^*}{\pi - \alpha*} , \frac{\alpha^* - \alpha}{\alpha^* - 0} \right),
        $$

        where \( \alpha^* \) is the corresponding optimal angle of the reference
        element. To compute the quality measure, the minimum of this expression
        over all elements and all of their (dihedral) angles is computed.

        Parameters
        ----------
        mesh : dolfin.cpp.mesh.Mesh
                The mesh whose quality shall be computed.

        Returns
        -------
        float
                The skewness of the mesh.
        &#34;&#34;&#34;

        return np.min(cls._quality_object.skewness(mesh).array())</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cashocs" href="index.html">cashocs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="cashocs.geometry.import_mesh" href="#cashocs.geometry.import_mesh">import_mesh</a></code></li>
<li><code><a title="cashocs.geometry.regular_box_mesh" href="#cashocs.geometry.regular_box_mesh">regular_box_mesh</a></code></li>
<li><code><a title="cashocs.geometry.regular_mesh" href="#cashocs.geometry.regular_mesh">regular_mesh</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cashocs.geometry.MeshQuality" href="#cashocs.geometry.MeshQuality">MeshQuality</a></code></h4>
<ul class="">
<li><code><a title="cashocs.geometry.MeshQuality.avg_condition_number" href="#cashocs.geometry.MeshQuality.avg_condition_number">avg_condition_number</a></code></li>
<li><code><a title="cashocs.geometry.MeshQuality.avg_maximum_angle" href="#cashocs.geometry.MeshQuality.avg_maximum_angle">avg_maximum_angle</a></code></li>
<li><code><a title="cashocs.geometry.MeshQuality.avg_radius_ratios" href="#cashocs.geometry.MeshQuality.avg_radius_ratios">avg_radius_ratios</a></code></li>
<li><code><a title="cashocs.geometry.MeshQuality.avg_skewness" href="#cashocs.geometry.MeshQuality.avg_skewness">avg_skewness</a></code></li>
<li><code><a title="cashocs.geometry.MeshQuality.min_condition_number" href="#cashocs.geometry.MeshQuality.min_condition_number">min_condition_number</a></code></li>
<li><code><a title="cashocs.geometry.MeshQuality.min_maximum_angle" href="#cashocs.geometry.MeshQuality.min_maximum_angle">min_maximum_angle</a></code></li>
<li><code><a title="cashocs.geometry.MeshQuality.min_radius_ratios" href="#cashocs.geometry.MeshQuality.min_radius_ratios">min_radius_ratios</a></code></li>
<li><code><a title="cashocs.geometry.MeshQuality.min_skewness" href="#cashocs.geometry.MeshQuality.min_skewness">min_skewness</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>