<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>cashocs.optimization_problem API documentation</title>
<meta name="description" content="Blueprint for the PDE constrained optimization problems â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cashocs.optimization_problem</code></h1>
</header>
<section id="section-intro">
<p>Blueprint for the PDE constrained optimization problems.</p>
<p>This module is used to define the parent class for the optimization problems,
as many parameters and variables are common for optimal control and shape
optimization problems.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (C) 2020 Sebastian Blauth
#
# This file is part of CASHOCS.
#
# CASHOCS is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CASHOCS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CASHOCS.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

&#34;&#34;&#34;Blueprint for the PDE constrained optimization problems.

This module is used to define the parent class for the optimization problems,
as many parameters and variables are common for optimal control and shape
optimization problems.
&#34;&#34;&#34;

import fenics

from ._exceptions import InputError



class OptimizationProblem:
        &#34;&#34;&#34;Blueprint for an abstract PDE constrained optimization problem.

        This class performs the initialization of the shared input so that the rest
        of the package can use it directly. Additionally, it includes methods that
        can be used to compute the state and adjoint variables by solving the
        corresponding equations. This could be subclassed to generate custom
        optimization problems.
        &#34;&#34;&#34;

        def __init__(self, state_forms, bcs_list, cost_functional_form, states, adjoints, config,
                                 initial_guess=None, ksp_options=None, adjoint_ksp_options=None):
                r&#34;&#34;&#34;Initializes the optimization problem.

                Parameters
                ----------
                state_forms : ufl.form.Form or list[ufl.form.Form]
                        The weak form of the state equation. Can be either a UFL form
                        or a list of UFL forms (if we have multiple equations).
                bcs_list : list[dolfin.fem.dirichletbc.DirichletBC] or list[list[dolfin.fem.dirichletbc.DirichletBC]]
                                   or dolfin.fem.dirichletbc.DirichletBC or None
                        The list of DirichletBC objects describing Dirichlet (essential) boundary conditions.
                        If this is None, then no Dirichlet boundary conditions are imposed.
                cost_functional_form : ufl.form.Form
                        The UFL form of the cost functional.
                states : dolfin.function.function.Function or list[dolfin.function.function.Function]
                        The state variable(s), can either be a single fenics Function, or a (ordered) list of these.
                adjoints : dolfin.function.function.Function or list[dolfin.function.function.Function]
                        The adjoint variable(s), can either be a single fenics Function, or a (ordered) list of these.
                config : configparser.ConfigParser
                        The config file for the problem, generated via cashocs.create_config(path_to_config).
                initial_guess : list[dolfin.function.function.Function], optional
                        A list of functions that act as initial guess for the state variables, should be valid
                        input for fenics.assign. If this is None, then a zero initial guess is used
                        (default is None).
                ksp_options : list[list[str]] or list[list[list[str]]] or None, optional
                        A list of strings corresponding to command line options for PETSc,
                        used to solve the state systems. If this is None, then the direct solver
                        mumps is used (default is None).
                adjoint_ksp_options : list[list[str]] or list[list[list[str]]] or None
                        A list of strings corresponding to command line options for PETSc,
                        used to solve the adjoint systems. If this is None, then the same options
                        as for the state systems are used (default is None).

                Notes
                -----
                If one uses a single PDE constraint, the inputs can be the objects
                (UFL forms, functions, etc.) directly. In case multiple PDE constraints
                are present the inputs have to be put into (ordered) lists. The order of
                the objects depends on the order of the state variables, so that
                `state_forms[i]` is the weak form of the PDE for state[i] with boundary
                conditions `bcs_list[i]` and corresponding adjoint state `adjoints[i]`.

                See Also
                --------
                cashocs.OptimalControlProblem : Represents an optimal control problem.
                cashocs.ShapeOptimizationProblem : Represents a shape optimization problem.
                &#34;&#34;&#34;

                ### Overloading, so that we do not have to use lists for a single state and a single control
                ### state_forms
                try:
                        if type(state_forms) == list and len(state_forms) &gt; 0:
                                for i in range(len(state_forms)):
                                        if state_forms[i].__module__==&#39;ufl.form&#39; and type(state_forms[i]).__name__==&#39;Form&#39;:
                                                pass
                                        else:
                                                raise InputError(&#39;state_forms have to be ufl forms&#39;)
                                self.state_forms = state_forms
                        elif state_forms.__module__ == &#39;ufl.form&#39; and type(state_forms).__name__ == &#39;Form&#39;:
                                self.state_forms = [state_forms]
                        else:
                                raise InputError(&#39;State forms have to be ufl forms&#39;)
                except:
                        raise InputError(&#39;Type of state_forms is wrong.&#39;)
                self.state_dim = len(self.state_forms)

                ### bcs_list
                try:
                        if bcs_list == [] or bcs_list is None:
                                self.bcs_list = []
                                for i in range(self.state_dim):
                                        self.bcs_list.append([])
                        elif type(bcs_list) == list and len(bcs_list) &gt; 0:
                                if type(bcs_list[0]) == list:
                                        for i in range(len(bcs_list)):
                                                if type(bcs_list[i]) == list:
                                                        pass
                                                else:
                                                        raise InputError(&#39;bcs_list has inconsistent types.&#39;)
                                        self.bcs_list = bcs_list

                                elif bcs_list[0].__module__ == &#39;dolfin.fem.dirichletbc&#39; and type(bcs_list[0]).__name__ == &#39;DirichletBC&#39;:
                                        for i in range(len(bcs_list)):
                                                if bcs_list[i].__module__==&#39;dolfin.fem.dirichletbc&#39; and type(bcs_list[i]).__name__==&#39;DirichletBC&#39;:
                                                        pass
                                                else:
                                                        raise InputError(&#39;bcs_list has inconsistent types.&#39;)
                                        self.bcs_list = [bcs_list]
                        elif bcs_list.__module__ == &#39;dolfin.fem.dirichletbc&#39; and type(bcs_list).__name__ == &#39;DirichletBC&#39;:
                                self.bcs_list = [[bcs_list]]
                        else:
                                raise InputError(&#39;Type of bcs_list is wrong.&#39;)
                except:
                        raise InputError(&#39;Type of bcs_list is wrong.&#39;)

                ### cost_functional_form
                try:
                        if cost_functional_form.__module__ == &#39;ufl.form&#39; and type(cost_functional_form).__name__ == &#39;Form&#39;:
                                self.cost_functional_form = cost_functional_form
                        else:
                                raise InputError(&#39;cost_functional_form has to be a ufl form&#39;)
                except:
                        raise InputError(&#39;Type of cost_functional_form is wrong.&#39;)

                ### states
                try:
                        if type(states) == list and len(states) &gt; 0:
                                for i in range(len(states)):
                                        if states[i].__module__ == &#39;dolfin.function.function&#39; and type(states[i]).__name__ == &#39;Function&#39;:
                                                pass
                                        else:
                                                raise InputError(&#39;states have to be fenics Functions.&#39;)

                                self.states = states

                        elif states.__module__ == &#39;dolfin.function.function&#39; and type(states).__name__ == &#39;Function&#39;:
                                self.states = [states]
                        else:
                                raise InputError(&#39;Type of states is wrong.&#39;)
                except:
                        raise InputError(&#39;Type of states is wrong.&#39;)

                ### adjoints
                try:
                        if type(adjoints) == list and len(adjoints) &gt; 0:
                                for i in range(len(adjoints)):
                                        if adjoints[i].__module__ == &#39;dolfin.function.function&#39; and type(adjoints[i]).__name__ == &#39;Function&#39;:
                                                pass
                                        else:
                                                raise InputError(&#39;adjoints have to fenics Functions.&#39;)

                                self.adjoints = adjoints

                        elif adjoints.__module__ == &#39;dolfin.function.function&#39; and type(adjoints).__name__ == &#39;Function&#39;:
                                self.adjoints = [adjoints]
                        else:
                                raise InputError(&#39;Type of adjoints is wrong.&#39;)
                except:
                        raise InputError(&#39;Type of adjoints is wrong.&#39;)

                ### config
                if config.__module__ == &#39;configparser&#39; and type(config).__name__ == &#39;ConfigParser&#39;:
                        self.config = config
                else:
                        raise InputError(&#39;config has to be of configparser.ConfigParser type&#39;)

                ### initial guess
                if initial_guess is None:
                        self.initial_guess = initial_guess
                else:
                        try:
                                if type(initial_guess) == list:
                                        self.initial_guess = initial_guess
                                elif initial_guess.__module__ == &#39;dolfin.function.function&#39; and type(initial_guess).__name__ == &#39;Function&#39;:
                                        self.initial_guess = [initial_guess]
                        except:
                                raise InputError(&#39;Initial guess has to be a list of functions&#39;)


                ### ksp_options
                if ksp_options is None:
                        self.ksp_options = []
                        option = [
                                [&#39;ksp_type&#39;, &#39;preonly&#39;],
                                [&#39;pc_type&#39;, &#39;lu&#39;],
                                [&#39;pc_factor_mat_solver_type&#39;, &#39;mumps&#39;],
                                [&#39;mat_mumps_icntl_24&#39;, 1]
                        ]

                        for i in range(self.state_dim):
                                self.ksp_options.append(option)

                elif type(ksp_options) == list and type(ksp_options[0]) == list and type(ksp_options[0][0]) == str:
                        self.ksp_options = [ksp_options[:]]

                elif type(ksp_options) == list and type(ksp_options[0]) == list and type(ksp_options[0][0]) == list:
                        self.ksp_options = ksp_options[:]

                else:
                        raise InputError(&#39;Wrong input format for ksp_options.&#39;)



                ### adjoint_ksp_options
                if adjoint_ksp_options is None:
                        self.adjoint_ksp_options = self.ksp_options[:]

                elif type(adjoint_ksp_options) == list and type(adjoint_ksp_options[0]) == list and type(adjoint_ksp_options[0][0]) == str:
                        self.adjoint_ksp_options = [adjoint_ksp_options[:]]

                elif type(adjoint_ksp_options) == list and type(adjoint_ksp_options[0]) == list and type(adjoint_ksp_options[0][0]) == list:
                        self.adjoint_ksp_options = adjoint_ksp_options[:]

                else:
                        raise InputError(&#39;Wrong input format for adjoint_ksp_options.&#39;)


                assert len(self.bcs_list) == self.state_dim, &#39;Length of states does not match&#39;
                assert len(self.states) == self.state_dim, &#39;Length of states does not match&#39;
                assert len(self.adjoints) == self.state_dim, &#39;Length of states does not match&#39;
                if self.initial_guess is not None:
                        assert len(self.initial_guess) == self.state_dim, &#39;Length of states does not match&#39;
                assert len(self.ksp_options) == self.state_dim, &#39;Length of states does not match&#39;
                assert len(self.adjoint_ksp_options) == self.state_dim, &#39;Length of states does not match&#39;

                fenics.set_log_level(fenics.LogLevel.ERROR)

                self.state_problem = None
                self.adjoint_problem = None



        def compute_state_variables(self):
                &#34;&#34;&#34;Solves the state system.

                This can be used for debugging purposes, to validate the solver
                and general behavior. Updates and overwrites the user input for
                the state variables.

                Returns
                -------
                None
                &#34;&#34;&#34;

                self.state_problem.solve()



        def compute_adjoint_variables(self):
                &#34;&#34;&#34;Solves the adjoint system.

                This can be used for debugging purposes and solver validation.
                Updates / overwrites the user input for the adjoint variables.
                The solve of the corresponding state system needed to determine
                the adjoints is carried out automatically.

                Returns
                -------
                None
                &#34;&#34;&#34;

                self.state_problem.solve()
                self.adjoint_problem.solve()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cashocs.optimization_problem.OptimizationProblem"><code class="flex name class">
<span>class <span class="ident">OptimizationProblem</span></span>
<span>(</span><span>state_forms, bcs_list, cost_functional_form, states, adjoints, config, initial_guess=None, ksp_options=None, adjoint_ksp_options=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Blueprint for an abstract PDE constrained optimization problem.</p>
<p>This class performs the initialization of the shared input so that the rest
of the package can use it directly. Additionally, it includes methods that
can be used to compute the state and adjoint variables by solving the
corresponding equations. This could be subclassed to generate custom
optimization problems.</p>
<p>Initializes the optimization problem.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state_forms</code></strong> :&ensp;<code>ufl.form.Form</code> or <code>list[ufl.form.Form]</code></dt>
<dd>The weak form of the state equation. Can be either a UFL form
or a list of UFL forms (if we have multiple equations).</dd>
<dt><strong><code>bcs_list</code></strong> :&ensp;<code>list[dolfin.fem.dirichletbc.DirichletBC]</code> or <code>list[list[dolfin.fem.dirichletbc.DirichletBC]]</code></dt>
<dd>or dolfin.fem.dirichletbc.DirichletBC or None
The list of DirichletBC objects describing Dirichlet (essential) boundary conditions.
If this is None, then no Dirichlet boundary conditions are imposed.</dd>
<dt><strong><code>cost_functional_form</code></strong> :&ensp;<code>ufl.form.Form</code></dt>
<dd>The UFL form of the cost functional.</dd>
<dt><strong><code>states</code></strong> :&ensp;<code>dolfin.function.function.Function</code> or <code>list[dolfin.function.function.Function]</code></dt>
<dd>The state variable(s), can either be a single fenics Function, or a (ordered) list of these.</dd>
<dt><strong><code>adjoints</code></strong> :&ensp;<code>dolfin.function.function.Function</code> or <code>list[dolfin.function.function.Function]</code></dt>
<dd>The adjoint variable(s), can either be a single fenics Function, or a (ordered) list of these.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>configparser.ConfigParser</code></dt>
<dd>The config file for the problem, generated via cashocs.create_config(path_to_config).</dd>
<dt><strong><code>initial_guess</code></strong> :&ensp;<code>list[dolfin.function.function.Function]</code>, optional</dt>
<dd>A list of functions that act as initial guess for the state variables, should be valid
input for fenics.assign. If this is None, then a zero initial guess is used
(default is None).</dd>
<dt><strong><code>ksp_options</code></strong> :&ensp;<code>list[list[str]]</code> or <code>list[list[list[str]]]</code> or <code>None</code>, optional</dt>
<dd>A list of strings corresponding to command line options for PETSc,
used to solve the state systems. If this is None, then the direct solver
mumps is used (default is None).</dd>
<dt><strong><code>adjoint_ksp_options</code></strong> :&ensp;<code>list[list[str]]</code> or <code>list[list[list[str]]]</code> or <code>None</code></dt>
<dd>A list of strings corresponding to command line options for PETSc,
used to solve the adjoint systems. If this is None, then the same options
as for the state systems are used (default is None).</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>If one uses a single PDE constraint, the inputs can be the objects
(UFL forms, functions, etc.) directly. In case multiple PDE constraints
are present the inputs have to be put into (ordered) lists. The order of
the objects depends on the order of the state variables, so that
<code>state_forms[i]</code> is the weak form of the PDE for state[i] with boundary
conditions <code>bcs_list[i]</code> and corresponding adjoint state <code>adjoints[i]</code>.</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="cashocs.OptimalControlProblem" href="index.html#cashocs.OptimalControlProblem">OptimalControlProblem</a></code></dt>
<dd>Represents an optimal control problem.</dd>
<dt><code><a title="cashocs.ShapeOptimizationProblem" href="index.html#cashocs.ShapeOptimizationProblem">ShapeOptimizationProblem</a></code></dt>
<dd>Represents a shape optimization problem.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OptimizationProblem:
        &#34;&#34;&#34;Blueprint for an abstract PDE constrained optimization problem.

        This class performs the initialization of the shared input so that the rest
        of the package can use it directly. Additionally, it includes methods that
        can be used to compute the state and adjoint variables by solving the
        corresponding equations. This could be subclassed to generate custom
        optimization problems.
        &#34;&#34;&#34;

        def __init__(self, state_forms, bcs_list, cost_functional_form, states, adjoints, config,
                                 initial_guess=None, ksp_options=None, adjoint_ksp_options=None):
                r&#34;&#34;&#34;Initializes the optimization problem.

                Parameters
                ----------
                state_forms : ufl.form.Form or list[ufl.form.Form]
                        The weak form of the state equation. Can be either a UFL form
                        or a list of UFL forms (if we have multiple equations).
                bcs_list : list[dolfin.fem.dirichletbc.DirichletBC] or list[list[dolfin.fem.dirichletbc.DirichletBC]]
                                   or dolfin.fem.dirichletbc.DirichletBC or None
                        The list of DirichletBC objects describing Dirichlet (essential) boundary conditions.
                        If this is None, then no Dirichlet boundary conditions are imposed.
                cost_functional_form : ufl.form.Form
                        The UFL form of the cost functional.
                states : dolfin.function.function.Function or list[dolfin.function.function.Function]
                        The state variable(s), can either be a single fenics Function, or a (ordered) list of these.
                adjoints : dolfin.function.function.Function or list[dolfin.function.function.Function]
                        The adjoint variable(s), can either be a single fenics Function, or a (ordered) list of these.
                config : configparser.ConfigParser
                        The config file for the problem, generated via cashocs.create_config(path_to_config).
                initial_guess : list[dolfin.function.function.Function], optional
                        A list of functions that act as initial guess for the state variables, should be valid
                        input for fenics.assign. If this is None, then a zero initial guess is used
                        (default is None).
                ksp_options : list[list[str]] or list[list[list[str]]] or None, optional
                        A list of strings corresponding to command line options for PETSc,
                        used to solve the state systems. If this is None, then the direct solver
                        mumps is used (default is None).
                adjoint_ksp_options : list[list[str]] or list[list[list[str]]] or None
                        A list of strings corresponding to command line options for PETSc,
                        used to solve the adjoint systems. If this is None, then the same options
                        as for the state systems are used (default is None).

                Notes
                -----
                If one uses a single PDE constraint, the inputs can be the objects
                (UFL forms, functions, etc.) directly. In case multiple PDE constraints
                are present the inputs have to be put into (ordered) lists. The order of
                the objects depends on the order of the state variables, so that
                `state_forms[i]` is the weak form of the PDE for state[i] with boundary
                conditions `bcs_list[i]` and corresponding adjoint state `adjoints[i]`.

                See Also
                --------
                cashocs.OptimalControlProblem : Represents an optimal control problem.
                cashocs.ShapeOptimizationProblem : Represents a shape optimization problem.
                &#34;&#34;&#34;

                ### Overloading, so that we do not have to use lists for a single state and a single control
                ### state_forms
                try:
                        if type(state_forms) == list and len(state_forms) &gt; 0:
                                for i in range(len(state_forms)):
                                        if state_forms[i].__module__==&#39;ufl.form&#39; and type(state_forms[i]).__name__==&#39;Form&#39;:
                                                pass
                                        else:
                                                raise InputError(&#39;state_forms have to be ufl forms&#39;)
                                self.state_forms = state_forms
                        elif state_forms.__module__ == &#39;ufl.form&#39; and type(state_forms).__name__ == &#39;Form&#39;:
                                self.state_forms = [state_forms]
                        else:
                                raise InputError(&#39;State forms have to be ufl forms&#39;)
                except:
                        raise InputError(&#39;Type of state_forms is wrong.&#39;)
                self.state_dim = len(self.state_forms)

                ### bcs_list
                try:
                        if bcs_list == [] or bcs_list is None:
                                self.bcs_list = []
                                for i in range(self.state_dim):
                                        self.bcs_list.append([])
                        elif type(bcs_list) == list and len(bcs_list) &gt; 0:
                                if type(bcs_list[0]) == list:
                                        for i in range(len(bcs_list)):
                                                if type(bcs_list[i]) == list:
                                                        pass
                                                else:
                                                        raise InputError(&#39;bcs_list has inconsistent types.&#39;)
                                        self.bcs_list = bcs_list

                                elif bcs_list[0].__module__ == &#39;dolfin.fem.dirichletbc&#39; and type(bcs_list[0]).__name__ == &#39;DirichletBC&#39;:
                                        for i in range(len(bcs_list)):
                                                if bcs_list[i].__module__==&#39;dolfin.fem.dirichletbc&#39; and type(bcs_list[i]).__name__==&#39;DirichletBC&#39;:
                                                        pass
                                                else:
                                                        raise InputError(&#39;bcs_list has inconsistent types.&#39;)
                                        self.bcs_list = [bcs_list]
                        elif bcs_list.__module__ == &#39;dolfin.fem.dirichletbc&#39; and type(bcs_list).__name__ == &#39;DirichletBC&#39;:
                                self.bcs_list = [[bcs_list]]
                        else:
                                raise InputError(&#39;Type of bcs_list is wrong.&#39;)
                except:
                        raise InputError(&#39;Type of bcs_list is wrong.&#39;)

                ### cost_functional_form
                try:
                        if cost_functional_form.__module__ == &#39;ufl.form&#39; and type(cost_functional_form).__name__ == &#39;Form&#39;:
                                self.cost_functional_form = cost_functional_form
                        else:
                                raise InputError(&#39;cost_functional_form has to be a ufl form&#39;)
                except:
                        raise InputError(&#39;Type of cost_functional_form is wrong.&#39;)

                ### states
                try:
                        if type(states) == list and len(states) &gt; 0:
                                for i in range(len(states)):
                                        if states[i].__module__ == &#39;dolfin.function.function&#39; and type(states[i]).__name__ == &#39;Function&#39;:
                                                pass
                                        else:
                                                raise InputError(&#39;states have to be fenics Functions.&#39;)

                                self.states = states

                        elif states.__module__ == &#39;dolfin.function.function&#39; and type(states).__name__ == &#39;Function&#39;:
                                self.states = [states]
                        else:
                                raise InputError(&#39;Type of states is wrong.&#39;)
                except:
                        raise InputError(&#39;Type of states is wrong.&#39;)

                ### adjoints
                try:
                        if type(adjoints) == list and len(adjoints) &gt; 0:
                                for i in range(len(adjoints)):
                                        if adjoints[i].__module__ == &#39;dolfin.function.function&#39; and type(adjoints[i]).__name__ == &#39;Function&#39;:
                                                pass
                                        else:
                                                raise InputError(&#39;adjoints have to fenics Functions.&#39;)

                                self.adjoints = adjoints

                        elif adjoints.__module__ == &#39;dolfin.function.function&#39; and type(adjoints).__name__ == &#39;Function&#39;:
                                self.adjoints = [adjoints]
                        else:
                                raise InputError(&#39;Type of adjoints is wrong.&#39;)
                except:
                        raise InputError(&#39;Type of adjoints is wrong.&#39;)

                ### config
                if config.__module__ == &#39;configparser&#39; and type(config).__name__ == &#39;ConfigParser&#39;:
                        self.config = config
                else:
                        raise InputError(&#39;config has to be of configparser.ConfigParser type&#39;)

                ### initial guess
                if initial_guess is None:
                        self.initial_guess = initial_guess
                else:
                        try:
                                if type(initial_guess) == list:
                                        self.initial_guess = initial_guess
                                elif initial_guess.__module__ == &#39;dolfin.function.function&#39; and type(initial_guess).__name__ == &#39;Function&#39;:
                                        self.initial_guess = [initial_guess]
                        except:
                                raise InputError(&#39;Initial guess has to be a list of functions&#39;)


                ### ksp_options
                if ksp_options is None:
                        self.ksp_options = []
                        option = [
                                [&#39;ksp_type&#39;, &#39;preonly&#39;],
                                [&#39;pc_type&#39;, &#39;lu&#39;],
                                [&#39;pc_factor_mat_solver_type&#39;, &#39;mumps&#39;],
                                [&#39;mat_mumps_icntl_24&#39;, 1]
                        ]

                        for i in range(self.state_dim):
                                self.ksp_options.append(option)

                elif type(ksp_options) == list and type(ksp_options[0]) == list and type(ksp_options[0][0]) == str:
                        self.ksp_options = [ksp_options[:]]

                elif type(ksp_options) == list and type(ksp_options[0]) == list and type(ksp_options[0][0]) == list:
                        self.ksp_options = ksp_options[:]

                else:
                        raise InputError(&#39;Wrong input format for ksp_options.&#39;)



                ### adjoint_ksp_options
                if adjoint_ksp_options is None:
                        self.adjoint_ksp_options = self.ksp_options[:]

                elif type(adjoint_ksp_options) == list and type(adjoint_ksp_options[0]) == list and type(adjoint_ksp_options[0][0]) == str:
                        self.adjoint_ksp_options = [adjoint_ksp_options[:]]

                elif type(adjoint_ksp_options) == list and type(adjoint_ksp_options[0]) == list and type(adjoint_ksp_options[0][0]) == list:
                        self.adjoint_ksp_options = adjoint_ksp_options[:]

                else:
                        raise InputError(&#39;Wrong input format for adjoint_ksp_options.&#39;)


                assert len(self.bcs_list) == self.state_dim, &#39;Length of states does not match&#39;
                assert len(self.states) == self.state_dim, &#39;Length of states does not match&#39;
                assert len(self.adjoints) == self.state_dim, &#39;Length of states does not match&#39;
                if self.initial_guess is not None:
                        assert len(self.initial_guess) == self.state_dim, &#39;Length of states does not match&#39;
                assert len(self.ksp_options) == self.state_dim, &#39;Length of states does not match&#39;
                assert len(self.adjoint_ksp_options) == self.state_dim, &#39;Length of states does not match&#39;

                fenics.set_log_level(fenics.LogLevel.ERROR)

                self.state_problem = None
                self.adjoint_problem = None



        def compute_state_variables(self):
                &#34;&#34;&#34;Solves the state system.

                This can be used for debugging purposes, to validate the solver
                and general behavior. Updates and overwrites the user input for
                the state variables.

                Returns
                -------
                None
                &#34;&#34;&#34;

                self.state_problem.solve()



        def compute_adjoint_variables(self):
                &#34;&#34;&#34;Solves the adjoint system.

                This can be used for debugging purposes and solver validation.
                Updates / overwrites the user input for the adjoint variables.
                The solve of the corresponding state system needed to determine
                the adjoints is carried out automatically.

                Returns
                -------
                None
                &#34;&#34;&#34;

                self.state_problem.solve()
                self.adjoint_problem.solve()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>cashocs._optimal_control.optimal_control_problem.OptimalControlProblem</li>
<li>cashocs._shape_optimization.shape_optimization_problem.ShapeOptimizationProblem</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cashocs.optimization_problem.OptimizationProblem.compute_adjoint_variables"><code class="name flex">
<span>def <span class="ident">compute_adjoint_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Solves the adjoint system.</p>
<p>This can be used for debugging purposes and solver validation.
Updates / overwrites the user input for the adjoint variables.
The solve of the corresponding state system needed to determine
the adjoints is carried out automatically.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_adjoint_variables(self):
        &#34;&#34;&#34;Solves the adjoint system.

        This can be used for debugging purposes and solver validation.
        Updates / overwrites the user input for the adjoint variables.
        The solve of the corresponding state system needed to determine
        the adjoints is carried out automatically.

        Returns
        -------
        None
        &#34;&#34;&#34;

        self.state_problem.solve()
        self.adjoint_problem.solve()</code></pre>
</details>
</dd>
<dt id="cashocs.optimization_problem.OptimizationProblem.compute_state_variables"><code class="name flex">
<span>def <span class="ident">compute_state_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Solves the state system.</p>
<p>This can be used for debugging purposes, to validate the solver
and general behavior. Updates and overwrites the user input for
the state variables.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_state_variables(self):
        &#34;&#34;&#34;Solves the state system.

        This can be used for debugging purposes, to validate the solver
        and general behavior. Updates and overwrites the user input for
        the state variables.

        Returns
        -------
        None
        &#34;&#34;&#34;

        self.state_problem.solve()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cashocs" href="index.html">cashocs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cashocs.optimization_problem.OptimizationProblem" href="#cashocs.optimization_problem.OptimizationProblem">OptimizationProblem</a></code></h4>
<ul class="">
<li><code><a title="cashocs.optimization_problem.OptimizationProblem.compute_adjoint_variables" href="#cashocs.optimization_problem.OptimizationProblem.compute_adjoint_variables">compute_adjoint_variables</a></code></li>
<li><code><a title="cashocs.optimization_problem.OptimizationProblem.compute_state_variables" href="#cashocs.optimization_problem.OptimizationProblem.compute_state_variables">compute_state_variables</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>