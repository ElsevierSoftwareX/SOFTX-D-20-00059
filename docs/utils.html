<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>cestrel.utils API documentation</title>
<meta name="description" content="Module for utility and helper functions â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cestrel.utils</code></h1>
</header>
<section id="section-intro">
<p>Module for utility and helper functions.</p>
<p>The functions that may be interesting for the end user, too,
are directly imported in cestrel, i.e., create_bcs_list and
create_config. However, summation, multiplication, and measure
manipulation may also be of interest.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Module for utility and helper functions.

The functions that may be interesting for the end user, too,
are directly imported in cestrel, i.e., create_bcs_list and
create_config. However, summation, multiplication, and measure
manipulation may also be of interest.
&#34;&#34;&#34;

import fenics
import configparser
import os
import numpy as np



def summation(x):
        &#34;&#34;&#34;Sums elements of a list.

        This can be used to sum, e.g., UFL forms, or UFL expressions
        that should be used in UFL forms. This is not possible with
        the built-in sum function.

        See Also
        --------
        multiplication : Multiplies the elements of a list.

        Parameters
        ----------
        x : list[ufl.form.Form] or list[int] or list[float]
                The list of entries that shall be summed.

        Returns
        -------
        y : ufl.form.Form or int or float
                Sum of input (same type as entries of input).
        &#34;&#34;&#34;
        
        if len(x) == 0:
                y = fenics.Constant(0.0)
                print(&#39;Careful, empty list handed to summ&#39;)
        else:
                y = x[0]
                
                for item in x[1:]:
                        y += item
        
        return y



def multiplication(x):
        &#34;&#34;&#34;Multiplies the elements of a list with each other.

        Used to build the product of certain UFL expressions to construct
        a UFL form.

        See Also
        --------
        summation : Sums elements of a list.

        Parameters
        ----------
        x : list[ufl.core.expr.Expr] or list[int] or list[float]
                The list whose entries shall be multiplied.

        Returns
        -------
        y : ufl.core.expr.Expr or int or float
                The result of the multiplication.
        &#34;&#34;&#34;
        
        if len(x) == 0:
                y = fenics.Constant(1.0)
                print(&#39;Careful, empty list handed to multiplication&#39;)
        else:
                y = x[0]
                
                for item in x[1:]:
                        y *= item
                        
        return y



class EmptyMeasure:
        &#34;&#34;&#34;Implements an empty measure (e.g. of a null set).

        This is used for automatic measure generation, e.g., if
        the fixed boundary is empty for a shape optimization problem,
        and is used to avoid case distinctions.
        &#34;&#34;&#34;

        def __init__(self, measure):
                &#34;&#34;&#34;Initializes self.

                Parameters
                ----------
                measure : ufl.measure.Measure
                        The underlying UFL measure.
                &#34;&#34;&#34;

                self.measure = measure



        def __rmul__(self, other):
                &#34;&#34;&#34;Generates a UFL form of the empty measure when multiplied from the right.

                Parameters
                ----------
                other : ufl.core.expr.Expr
                        A UFL expression to be integrated over an empty measure.

                Returns
                -------
                ufl.form.Form
                        The resulting UFL form.
                &#34;&#34;&#34;

                return fenics.Constant(0)*other*self.measure



def generate_measure(idx, measure):
        &#34;&#34;&#34;Generates a measure based on indices.

        Generates a MeasureSum or EmptyMeasure object corresponding to
        measure and the subdomains / boundaries specified in idx. This
        is a convenient shortcut to writing dx(1) + dx(2) + dx(3) + ...
        in case many measures are involved.

        Parameters
        ----------
        idx : list[int]
                A list of indices for the boundary / volume markers that
                shall define the new measure.
        measure : ufl.measure.Measure
                The corresponding UFL measure.

        Returns
        -------
        ufl.measure.Measure or cestrel.utils.EmptyMeasure
                The corresponding sum of the measures or an empty measure.
        &#34;&#34;&#34;

        if len(idx) == 0:
                out_measure = EmptyMeasure(measure)

        else:
                out_measure = measure(idx[0])

                for i in idx[1:]:
                        out_measure += measure(i)

        return out_measure



def create_config(path):
        &#34;&#34;&#34;Generates a config object from a config file.

        Creates the config from a .ini file via the
        configparser package.

        Parameters
        ----------
        path : str
                The path to the config .ini file.

        Returns
        -------
        configparser.ConfigParser
                The output config file, which includes the path
                to the .ini file.
        &#34;&#34;&#34;

        config = configparser.ConfigParser()
        config.read(path)

        return config



def create_bcs_list(function_space, value, boundaries, idcs):
        &#34;&#34;&#34;Create several Dirichlet boundary conditions at once.

        Wraps multiple Dirichlet boundary conditions into a list, in case
        they have the same value but are to be defined for multiple boundaries
        with different markers. Particularly useful for defining homogeneous
        boundary conditions.

        Parameters
        ----------
        function_space : dolfin.function.functionspace.FunctionSpace
                The function space onto which the BCs should be imposed on.
        value : dolfin.function.constant.Constant or dolfin.function.expression.Expression or dolfin.function.function.Function or float or tuple(float)
                The value of the boundary condition. Has to be compatible with the function_space,
                so that it could also be used as DirichletBC(function_space, value, ...).
        boundaries : dolfin.cpp.mesh.MeshFunctionSizet
                The MeshFunction object representing the boundaries.
        idcs : list[int]
                A list of indices / boundary markers that determine the boundaries
                onto which the Dirichlet boundary conditions should be applied to.

        Returns
        -------
        list[dolfin.fem.dirichletbc.DirichletBC]
                A list of DirichletBC objects that represent the boundary conditions.
        &#34;&#34;&#34;

        bcs_list = []
        for i in idcs:
                bcs_list.append(fenics.DirichletBC(function_space, value, boundaries, i))

        return bcs_list



class Interpolator:
        &#34;&#34;&#34;Efficient interpolation between two function spaces.

        This is very useful, if multiple interpolations have to be
        carried out between the same spaces, which is made significantly
        faster by computing the corresponding matrix.
        The function spaces can even be defined on different meshes.
        &#34;&#34;&#34;

        def __init__(self, V, W):
                &#34;&#34;&#34;Initializes the object.

                Parameters
                ----------
                V : dolfin.function.functionspace.FunctionSpace
                        The function space whose objects shall be interpolated.
                W : dolfin.function.functionspace.FunctionSpace
                        The space into which they shall be interpolated.
                &#34;&#34;&#34;

                self.V = V
                self.W = W
                self.transfer_matrix = fenics.PETScDMCollection.create_transfer_matrix(self.V, self.W)


        def interpolate(self, u):
                &#34;&#34;&#34;Interpolates function to target space.

                Parameters
                ----------
                u : dolfin.function.function.Function
                        The function that shall be interpolated.

                Returns
                -------
                dolfin.function.function.Function
                        The result of the interpolation.
                &#34;&#34;&#34;

                assert u.function_space() == self.V, &#39;input does not belong to the correct function space&#39;
                v = fenics.Function(self.W)
                v.vector()[:] = (self.transfer_matrix*u.vector())[:]

                return v



def _assemble_petsc_system(A_form, b_form, bcs=None):
        &#34;&#34;&#34;Assembles a system symmetrically and converts to PETSc

        Also uses ident_zeros() to get well-posed problems

        Parameters
        ----------
        A_form : ufl.form.Form
                the UFL form for the LHS
        b_form : ufl.form.Form
                the UFL form for the RHS
        bcs : None or dolfin.fem.dirichletbc.DirichletBC or list[dolfin.fem.dirichletbc.DirichletBC]
                list of Dirichlet boundary conditions

        Returns
        -------
        petsc4py.PETSc.Mat
                the petsc matrix for the LHS
        petsc4py.PETSc.Vec
                the petsc matrix for the RHS
        &#34;&#34;&#34;

        A, b = fenics.assemble_system(A_form, b_form, bcs, keep_diagonal=True)
        A.ident_zeros()

        A = fenics.as_backend_type(A).mat()
        b = fenics.as_backend_type(b).vec()

        return A, b



def _setup_petsc_options(ksps, ksp_options):
        &#34;&#34;&#34;Sets up an (iterative) linear solver.

        This is used to pass user defined command line options for PETSc
        to the PETSc KSP objects.
        Here, options[i] is applied to ksps[i]

        Parameters
        ----------
        ksps : list[petsc4py.PETSc.KSP]
                A list of PETSc KSP objects (linear solvers) to which the (command line)
                options are applied to.
        ksp_options : list[list[list[str]]]
                A list of command line options that specify the iterative solver
                from PETSc.

        Returns
        -------
        None
        &#34;&#34;&#34;

        assert len(ksps) == len(ksp_options), &#39;Length of options and ksps does not match&#39;

        opts = fenics.PETScOptions

        for i in range(len(ksps)):
                opts.clear()

                for option in ksp_options[i]:
                        opts.set(*option)

                ksps[i].setFromOptions()



def write_out_mesh(mesh, original_msh_file, out_msh_file):
        &#34;&#34;&#34;Writes out the current mesh as .msh file

        Parameters
        ----------
        mesh : dolfin.cpp.mesh.Mesh
                The mesh object in fenics that should be saved as gmsh file.
        original_msh_file : str
                Path to the original gmsh mesh file of the mesh object, has to
                end with &#39;.msh&#39;
        out_msh_file : str
                Path (and name) of the output mesh file, has to end with &#39;.msh&#39;

        Returns
        -------
        None
        &#34;&#34;&#34;

        assert original_msh_file[-4:] == &#39;.msh&#39;, &#39;Format for original_mesh_file is wrong&#39;
        assert out_msh_file[-4:] == &#39;.msh&#39;, &#39;Format for out_mesh_file is wrong&#39;

        dim = mesh.geometric_dimension()

        with open(original_msh_file, &#39;r&#39;) as old_file, open(out_msh_file, &#39;w&#39;) as new_file:

                points = mesh.coordinates()

                node_section = False
                info_section = False
                subnode_counter = 0
                subwrite_counter = 0
                idcs = np.zeros(1, dtype=int)

                for line in old_file:
                        if line == &#39;$EndNodes\n&#39;:
                                node_section = False

                        if not node_section:
                                new_file.write(line)
                        else:
                                split_line = line.split(&#39; &#39;)
                                if info_section:
                                        new_file.write(line)
                                        info_section = False
                                else:
                                        if len(split_line) == 4:
                                                num_subnodes = int(split_line[-1][:-1])
                                                subnode_counter = 0
                                                subwrite_counter = 0
                                                idcs = np.zeros(num_subnodes, dtype=int)
                                                new_file.write(line)
                                        elif len(split_line) == 1:
                                                idcs[subnode_counter] = int(split_line[0][:-1]) - 1
                                                subnode_counter += 1
                                                new_file.write(line)
                                        elif len(split_line) == 3:
                                                if dim == 2:
                                                        mod_line = format(points[idcs[subwrite_counter]][0], &#39;.16f&#39;) + &#39; &#39; + format(points[idcs[subwrite_counter]][1], &#39;.16f&#39;) + &#39; &#39; + &#39;0\n&#39;
                                                elif dim == 3:
                                                        mod_line = format(points[idcs[subwrite_counter]][0], &#39;.16f&#39;) + &#39; &#39; + format(points[idcs[subwrite_counter]][1], &#39;.16f&#39;) + &#39; &#39; + format(points[idcs[subwrite_counter]][2], &#39;.16f&#39;) + &#39;\n&#39;
                                                else:
                                                        raise Exception(&#39;Not a valid dimension for the mesh.&#39;)
                                                new_file.write(mod_line)
                                                subwrite_counter += 1


                        if line == &#39;$Nodes\n&#39;:
                                node_section = True
                                info_section = True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cestrel.utils.create_bcs_list"><code class="name flex">
<span>def <span class="ident">create_bcs_list</span></span>(<span>function_space, value, boundaries, idcs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create several Dirichlet boundary conditions at once.</p>
<p>Wraps multiple Dirichlet boundary conditions into a list, in case
they have the same value but are to be defined for multiple boundaries
with different markers. Particularly useful for defining homogeneous
boundary conditions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>function_space</code></strong> :&ensp;<code>dolfin.function.functionspace.FunctionSpace</code></dt>
<dd>The function space onto which the BCs should be imposed on.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>dolfin.function.constant.Constant</code> or <code>dolfin.function.expression.Expression</code> or <code>dolfin.function.function.Function</code> or <code>float</code> or <code>tuple(float)</code></dt>
<dd>The value of the boundary condition. Has to be compatible with the function_space,
so that it could also be used as DirichletBC(function_space, value, &hellip;).</dd>
<dt><strong><code>boundaries</code></strong> :&ensp;<code>dolfin.cpp.mesh.MeshFunctionSizet</code></dt>
<dd>The MeshFunction object representing the boundaries.</dd>
<dt><strong><code>idcs</code></strong> :&ensp;<code>list[int]</code></dt>
<dd>A list of indices / boundary markers that determine the boundaries
onto which the Dirichlet boundary conditions should be applied to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[dolfin.fem.dirichletbc.DirichletBC]</code></dt>
<dd>A list of DirichletBC objects that represent the boundary conditions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_bcs_list(function_space, value, boundaries, idcs):
        &#34;&#34;&#34;Create several Dirichlet boundary conditions at once.

        Wraps multiple Dirichlet boundary conditions into a list, in case
        they have the same value but are to be defined for multiple boundaries
        with different markers. Particularly useful for defining homogeneous
        boundary conditions.

        Parameters
        ----------
        function_space : dolfin.function.functionspace.FunctionSpace
                The function space onto which the BCs should be imposed on.
        value : dolfin.function.constant.Constant or dolfin.function.expression.Expression or dolfin.function.function.Function or float or tuple(float)
                The value of the boundary condition. Has to be compatible with the function_space,
                so that it could also be used as DirichletBC(function_space, value, ...).
        boundaries : dolfin.cpp.mesh.MeshFunctionSizet
                The MeshFunction object representing the boundaries.
        idcs : list[int]
                A list of indices / boundary markers that determine the boundaries
                onto which the Dirichlet boundary conditions should be applied to.

        Returns
        -------
        list[dolfin.fem.dirichletbc.DirichletBC]
                A list of DirichletBC objects that represent the boundary conditions.
        &#34;&#34;&#34;

        bcs_list = []
        for i in idcs:
                bcs_list.append(fenics.DirichletBC(function_space, value, boundaries, i))

        return bcs_list</code></pre>
</details>
</dd>
<dt id="cestrel.utils.create_config"><code class="name flex">
<span>def <span class="ident">create_config</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a config object from a config file.</p>
<p>Creates the config from a .ini file via the
configparser package.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the config .ini file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>configparser.ConfigParser</code></dt>
<dd>The output config file, which includes the path
to the .ini file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_config(path):
        &#34;&#34;&#34;Generates a config object from a config file.

        Creates the config from a .ini file via the
        configparser package.

        Parameters
        ----------
        path : str
                The path to the config .ini file.

        Returns
        -------
        configparser.ConfigParser
                The output config file, which includes the path
                to the .ini file.
        &#34;&#34;&#34;

        config = configparser.ConfigParser()
        config.read(path)

        return config</code></pre>
</details>
</dd>
<dt id="cestrel.utils.generate_measure"><code class="name flex">
<span>def <span class="ident">generate_measure</span></span>(<span>idx, measure)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a measure based on indices.</p>
<p>Generates a MeasureSum or EmptyMeasure object corresponding to
measure and the subdomains / boundaries specified in idx. This
is a convenient shortcut to writing dx(1) + dx(2) + dx(3) + &hellip;
in case many measures are involved.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>list[int]</code></dt>
<dd>A list of indices for the boundary / volume markers that
shall define the new measure.</dd>
<dt><strong><code>measure</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>The corresponding UFL measure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ufl.measure.Measure</code> or <code><a title="cestrel.utils.EmptyMeasure" href="#cestrel.utils.EmptyMeasure">EmptyMeasure</a></code></dt>
<dd>The corresponding sum of the measures or an empty measure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_measure(idx, measure):
        &#34;&#34;&#34;Generates a measure based on indices.

        Generates a MeasureSum or EmptyMeasure object corresponding to
        measure and the subdomains / boundaries specified in idx. This
        is a convenient shortcut to writing dx(1) + dx(2) + dx(3) + ...
        in case many measures are involved.

        Parameters
        ----------
        idx : list[int]
                A list of indices for the boundary / volume markers that
                shall define the new measure.
        measure : ufl.measure.Measure
                The corresponding UFL measure.

        Returns
        -------
        ufl.measure.Measure or cestrel.utils.EmptyMeasure
                The corresponding sum of the measures or an empty measure.
        &#34;&#34;&#34;

        if len(idx) == 0:
                out_measure = EmptyMeasure(measure)

        else:
                out_measure = measure(idx[0])

                for i in idx[1:]:
                        out_measure += measure(i)

        return out_measure</code></pre>
</details>
</dd>
<dt id="cestrel.utils.multiplication"><code class="name flex">
<span>def <span class="ident">multiplication</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Multiplies the elements of a list with each other.</p>
<p>Used to build the product of certain UFL expressions to construct
a UFL form.</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="cestrel.utils.summation" href="#cestrel.utils.summation">summation()</a></code></dt>
<dd>Sums elements of a list.</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>list[ufl.core.expr.Expr]</code> or <code>list[int]</code> or <code>list[float]</code></dt>
<dd>The list whose entries shall be multiplied.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>ufl.core.expr.Expr</code> or <code>int</code> or <code>float</code></dt>
<dd>The result of the multiplication.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiplication(x):
        &#34;&#34;&#34;Multiplies the elements of a list with each other.

        Used to build the product of certain UFL expressions to construct
        a UFL form.

        See Also
        --------
        summation : Sums elements of a list.

        Parameters
        ----------
        x : list[ufl.core.expr.Expr] or list[int] or list[float]
                The list whose entries shall be multiplied.

        Returns
        -------
        y : ufl.core.expr.Expr or int or float
                The result of the multiplication.
        &#34;&#34;&#34;
        
        if len(x) == 0:
                y = fenics.Constant(1.0)
                print(&#39;Careful, empty list handed to multiplication&#39;)
        else:
                y = x[0]
                
                for item in x[1:]:
                        y *= item
                        
        return y</code></pre>
</details>
</dd>
<dt id="cestrel.utils.summation"><code class="name flex">
<span>def <span class="ident">summation</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Sums elements of a list.</p>
<p>This can be used to sum, e.g., UFL forms, or UFL expressions
that should be used in UFL forms. This is not possible with
the built-in sum function.</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="cestrel.utils.multiplication" href="#cestrel.utils.multiplication">multiplication()</a></code></dt>
<dd>Multiplies the elements of a list.</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>list[ufl.form.Form]</code> or <code>list[int]</code> or <code>list[float]</code></dt>
<dd>The list of entries that shall be summed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>ufl.form.Form</code> or <code>int</code> or <code>float</code></dt>
<dd>Sum of input (same type as entries of input).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summation(x):
        &#34;&#34;&#34;Sums elements of a list.

        This can be used to sum, e.g., UFL forms, or UFL expressions
        that should be used in UFL forms. This is not possible with
        the built-in sum function.

        See Also
        --------
        multiplication : Multiplies the elements of a list.

        Parameters
        ----------
        x : list[ufl.form.Form] or list[int] or list[float]
                The list of entries that shall be summed.

        Returns
        -------
        y : ufl.form.Form or int or float
                Sum of input (same type as entries of input).
        &#34;&#34;&#34;
        
        if len(x) == 0:
                y = fenics.Constant(0.0)
                print(&#39;Careful, empty list handed to summ&#39;)
        else:
                y = x[0]
                
                for item in x[1:]:
                        y += item
        
        return y</code></pre>
</details>
</dd>
<dt id="cestrel.utils.write_out_mesh"><code class="name flex">
<span>def <span class="ident">write_out_mesh</span></span>(<span>mesh, original_msh_file, out_msh_file)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes out the current mesh as .msh file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>dolfin.cpp.mesh.Mesh</code></dt>
<dd>The mesh object in fenics that should be saved as gmsh file.</dd>
<dt><strong><code>original_msh_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the original gmsh mesh file of the mesh object, has to
end with '.msh'</dd>
<dt><strong><code>out_msh_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path (and name) of the output mesh file, has to end with '.msh'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_out_mesh(mesh, original_msh_file, out_msh_file):
        &#34;&#34;&#34;Writes out the current mesh as .msh file

        Parameters
        ----------
        mesh : dolfin.cpp.mesh.Mesh
                The mesh object in fenics that should be saved as gmsh file.
        original_msh_file : str
                Path to the original gmsh mesh file of the mesh object, has to
                end with &#39;.msh&#39;
        out_msh_file : str
                Path (and name) of the output mesh file, has to end with &#39;.msh&#39;

        Returns
        -------
        None
        &#34;&#34;&#34;

        assert original_msh_file[-4:] == &#39;.msh&#39;, &#39;Format for original_mesh_file is wrong&#39;
        assert out_msh_file[-4:] == &#39;.msh&#39;, &#39;Format for out_mesh_file is wrong&#39;

        dim = mesh.geometric_dimension()

        with open(original_msh_file, &#39;r&#39;) as old_file, open(out_msh_file, &#39;w&#39;) as new_file:

                points = mesh.coordinates()

                node_section = False
                info_section = False
                subnode_counter = 0
                subwrite_counter = 0
                idcs = np.zeros(1, dtype=int)

                for line in old_file:
                        if line == &#39;$EndNodes\n&#39;:
                                node_section = False

                        if not node_section:
                                new_file.write(line)
                        else:
                                split_line = line.split(&#39; &#39;)
                                if info_section:
                                        new_file.write(line)
                                        info_section = False
                                else:
                                        if len(split_line) == 4:
                                                num_subnodes = int(split_line[-1][:-1])
                                                subnode_counter = 0
                                                subwrite_counter = 0
                                                idcs = np.zeros(num_subnodes, dtype=int)
                                                new_file.write(line)
                                        elif len(split_line) == 1:
                                                idcs[subnode_counter] = int(split_line[0][:-1]) - 1
                                                subnode_counter += 1
                                                new_file.write(line)
                                        elif len(split_line) == 3:
                                                if dim == 2:
                                                        mod_line = format(points[idcs[subwrite_counter]][0], &#39;.16f&#39;) + &#39; &#39; + format(points[idcs[subwrite_counter]][1], &#39;.16f&#39;) + &#39; &#39; + &#39;0\n&#39;
                                                elif dim == 3:
                                                        mod_line = format(points[idcs[subwrite_counter]][0], &#39;.16f&#39;) + &#39; &#39; + format(points[idcs[subwrite_counter]][1], &#39;.16f&#39;) + &#39; &#39; + format(points[idcs[subwrite_counter]][2], &#39;.16f&#39;) + &#39;\n&#39;
                                                else:
                                                        raise Exception(&#39;Not a valid dimension for the mesh.&#39;)
                                                new_file.write(mod_line)
                                                subwrite_counter += 1


                        if line == &#39;$Nodes\n&#39;:
                                node_section = True
                                info_section = True</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cestrel.utils.EmptyMeasure"><code class="flex name class">
<span>class <span class="ident">EmptyMeasure</span></span>
<span>(</span><span>measure)</span>
</code></dt>
<dd>
<div class="desc"><p>Implements an empty measure (e.g. of a null set).</p>
<p>This is used for automatic measure generation, e.g., if
the fixed boundary is empty for a shape optimization problem,
and is used to avoid case distinctions.</p>
<p>Initializes self.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>measure</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>The underlying UFL measure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmptyMeasure:
        &#34;&#34;&#34;Implements an empty measure (e.g. of a null set).

        This is used for automatic measure generation, e.g., if
        the fixed boundary is empty for a shape optimization problem,
        and is used to avoid case distinctions.
        &#34;&#34;&#34;

        def __init__(self, measure):
                &#34;&#34;&#34;Initializes self.

                Parameters
                ----------
                measure : ufl.measure.Measure
                        The underlying UFL measure.
                &#34;&#34;&#34;

                self.measure = measure



        def __rmul__(self, other):
                &#34;&#34;&#34;Generates a UFL form of the empty measure when multiplied from the right.

                Parameters
                ----------
                other : ufl.core.expr.Expr
                        A UFL expression to be integrated over an empty measure.

                Returns
                -------
                ufl.form.Form
                        The resulting UFL form.
                &#34;&#34;&#34;

                return fenics.Constant(0)*other*self.measure</code></pre>
</details>
</dd>
<dt id="cestrel.utils.Interpolator"><code class="flex name class">
<span>class <span class="ident">Interpolator</span></span>
<span>(</span><span>V, W)</span>
</code></dt>
<dd>
<div class="desc"><p>Efficient interpolation between two function spaces.</p>
<p>This is very useful, if multiple interpolations have to be
carried out between the same spaces, which is made significantly
faster by computing the corresponding matrix.
The function spaces can even be defined on different meshes.</p>
<p>Initializes the object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>dolfin.function.functionspace.FunctionSpace</code></dt>
<dd>The function space whose objects shall be interpolated.</dd>
<dt><strong><code>W</code></strong> :&ensp;<code>dolfin.function.functionspace.FunctionSpace</code></dt>
<dd>The space into which they shall be interpolated.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Interpolator:
        &#34;&#34;&#34;Efficient interpolation between two function spaces.

        This is very useful, if multiple interpolations have to be
        carried out between the same spaces, which is made significantly
        faster by computing the corresponding matrix.
        The function spaces can even be defined on different meshes.
        &#34;&#34;&#34;

        def __init__(self, V, W):
                &#34;&#34;&#34;Initializes the object.

                Parameters
                ----------
                V : dolfin.function.functionspace.FunctionSpace
                        The function space whose objects shall be interpolated.
                W : dolfin.function.functionspace.FunctionSpace
                        The space into which they shall be interpolated.
                &#34;&#34;&#34;

                self.V = V
                self.W = W
                self.transfer_matrix = fenics.PETScDMCollection.create_transfer_matrix(self.V, self.W)


        def interpolate(self, u):
                &#34;&#34;&#34;Interpolates function to target space.

                Parameters
                ----------
                u : dolfin.function.function.Function
                        The function that shall be interpolated.

                Returns
                -------
                dolfin.function.function.Function
                        The result of the interpolation.
                &#34;&#34;&#34;

                assert u.function_space() == self.V, &#39;input does not belong to the correct function space&#39;
                v = fenics.Function(self.W)
                v.vector()[:] = (self.transfer_matrix*u.vector())[:]

                return v</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cestrel.utils.Interpolator.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>self, u)</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolates function to target space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>dolfin.function.function.Function</code></dt>
<dd>The function that shall be interpolated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dolfin.function.function.Function</code></dt>
<dd>The result of the interpolation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate(self, u):
        &#34;&#34;&#34;Interpolates function to target space.

        Parameters
        ----------
        u : dolfin.function.function.Function
                The function that shall be interpolated.

        Returns
        -------
        dolfin.function.function.Function
                The result of the interpolation.
        &#34;&#34;&#34;

        assert u.function_space() == self.V, &#39;input does not belong to the correct function space&#39;
        v = fenics.Function(self.W)
        v.vector()[:] = (self.transfer_matrix*u.vector())[:]

        return v</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cestrel" href="index.html">cestrel</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="cestrel.utils.create_bcs_list" href="#cestrel.utils.create_bcs_list">create_bcs_list</a></code></li>
<li><code><a title="cestrel.utils.create_config" href="#cestrel.utils.create_config">create_config</a></code></li>
<li><code><a title="cestrel.utils.generate_measure" href="#cestrel.utils.generate_measure">generate_measure</a></code></li>
<li><code><a title="cestrel.utils.multiplication" href="#cestrel.utils.multiplication">multiplication</a></code></li>
<li><code><a title="cestrel.utils.summation" href="#cestrel.utils.summation">summation</a></code></li>
<li><code><a title="cestrel.utils.write_out_mesh" href="#cestrel.utils.write_out_mesh">write_out_mesh</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cestrel.utils.EmptyMeasure" href="#cestrel.utils.EmptyMeasure">EmptyMeasure</a></code></h4>
</li>
<li>
<h4><code><a title="cestrel.utils.Interpolator" href="#cestrel.utils.Interpolator">Interpolator</a></code></h4>
<ul class="">
<li><code><a title="cestrel.utils.Interpolator.interpolate" href="#cestrel.utils.Interpolator.interpolate">interpolate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>