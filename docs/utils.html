<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>cashocs.utils API documentation</title>
<meta name="description" content="Module including utility and helper functions â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cashocs.utils</code></h1>
</header>
<section id="section-intro">
<p>Module including utility and helper functions.</p>
<p>These module includes utility and helper functions used in cashocs. They
might also be interesting for users, so they are part of the public API.
They include wrappers that allow to shorten the coding for often recurring
actions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (C) 2020 Sebastian Blauth
#
# This file is part of CASHOCS.
#
# CASHOCS is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CASHOCS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CASHOCS.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

&#34;&#34;&#34;Module including utility and helper functions.

These module includes utility and helper functions used in cashocs. They
might also be interesting for users, so they are part of the public API.
They include wrappers that allow to shorten the coding for often recurring
actions.
&#34;&#34;&#34;

import configparser

import fenics
import numpy as np
from petsc4py import PETSc

from ._exceptions import InputError, PETScKSPError



def summation(x):
        &#34;&#34;&#34;Sums elements of a list in a UFL friendly fashion.

        This can be used to sum, e.g., UFL forms, or UFL expressions
        that can be used in UFL forms.

        Parameters
        ----------
        x : list[ufl.form.Form] or list[int] or list[float]
                The list of entries that shall be summed.

        Returns
        -------
        y : ufl.form.Form or int or float
                Sum of input (same type as entries of input).

        See Also
        --------
        multiplication : Multiplies the elements of a list.

        Notes
        -----
        For &#34;usual&#34; summation of integers or floats, the built-in sum function
        of python or the numpy variant are recommended. Still, they are
        incompatible with fenics objects, so this function should be used for
        the latter.

        Examples
        --------
            a = cashocs.summation([u.dx(i)*v.dx(i)*dx for i in mesh.geometric_dimension()])

        is equivalent to

            a = u.dx(0)*v.dx(0)*dx + u.dx(1)*v.dx(1)*dx

        (for a 2D mesh).
        &#34;&#34;&#34;
        
        if len(x) == 0:
                y = fenics.Constant(0.0)
                print(&#39;Careful, empty list handed to summ&#39;)
        else:
                y = x[0]
                
                for item in x[1:]:
                        y += item
        
        return y



def multiplication(x):
        &#34;&#34;&#34;Multiplies the elements of a list in a UFL friendly fashion.

        Used to build the product of certain UFL expressions to construct
        a UFL form.

        Parameters
        ----------
        x : list[ufl.core.expr.Expr] or list[int] or list[float]
                The list whose entries shall be multiplied.

        Returns
        -------
        y : ufl.core.expr.Expr or int or float
                The result of the multiplication.

        See Also
        --------
        summation : Sums elements of a list.

        Examples
        --------
            a = cashocs.multiplication([u.dx(i) for i in range(mesh.geometric_dimension())])

        is equivalent to

            a = u.dx(0) * u.dx(1)

        (for a 2D mesh).
        &#34;&#34;&#34;
        
        if len(x) == 0:
                y = fenics.Constant(1.0)
                print(&#39;Careful, empty list handed to multiplication&#39;)
        else:
                y = x[0]
                
                for item in x[1:]:
                        y *= item
                        
        return y





class EmptyMeasure:
        &#34;&#34;&#34;Implements an empty measure (e.g. of a null set).

        This is used for automatic measure generation, e.g., if
        the fixed boundary is empty for a shape optimization problem,
        and is used to avoid case distinctions.

        Examples
        --------
            dm = EmptyMeasure(dx)
            u*dm

        is equivalent to

            Constant(0)*u*dm

        so that this generates zeros when assembled over.
        &#34;&#34;&#34;

        def __init__(self, measure):
                &#34;&#34;&#34;Initializes self.

                Parameters
                ----------
                measure : ufl.measure.Measure
                        The underlying UFL measure.
                &#34;&#34;&#34;

                self.measure = measure



        def __rmul__(self, other):
                &#34;&#34;&#34;Multiplies the empty measure to the right.

                Parameters
                ----------
                other : ufl.core.expr.Expr
                        A UFL expression to be integrated over an empty measure.

                Returns
                -------
                ufl.form.Form
                        The resulting UFL form.
                &#34;&#34;&#34;

                return fenics.Constant(0)*other*self.measure





def generate_measure(idx, measure):
        &#34;&#34;&#34;Generates a measure based on indices.

        Generates a MeasureSum or EmptyMeasure object corresponding to
        measure and the subdomains / boundaries specified in idx. This
        is a convenient shortcut to writing dx(1) + dx(2) + dx(3) + ...
        in case many measures are involved.

        Parameters
        ----------
        idx : list[int]
                A list of indices for the boundary / volume markers that
                shall define the new measure.
        measure : ufl.measure.Measure
                The corresponding UFL measure.

        Returns
        -------
        ufl.measure.Measure or cashocs.utils.EmptyMeasure
                The corresponding sum of the measures or an empty measure.

        Examples
        --------
            from fenics import *
            import cashocs
            mesh, _, boundaries, dx, ds, _ = cashocs.regular_mesh(25)
            top_bottom_measure = cashocs.utils.generate_measure([3,4], ds)
            assemble(1*top_bottom_measure)
        &#34;&#34;&#34;

        if len(idx) == 0:
                out_measure = EmptyMeasure(measure)

        else:
                out_measure = measure(idx[0])

                for i in idx[1:]:
                        out_measure += measure(i)

        return out_measure



def create_config(path):
        &#34;&#34;&#34;Generates a config object from a config file.

        Creates the config from a .ini file via the
        configparser package.

        Parameters
        ----------
        path : str
                The path to the config .ini file.

        Returns
        -------
        configparser.ConfigParser
                The output config file, which includes the path
                to the .ini file.
        &#34;&#34;&#34;

        config = configparser.ConfigParser()
        config.read(path)

        return config



def create_bcs_list(function_space, value, boundaries, idcs, **kwargs):
        &#34;&#34;&#34;Create several Dirichlet boundary conditions at once.

        Wraps multiple Dirichlet boundary conditions into a list, in case
        they have the same value but are to be defined for multiple boundaries
        with different markers. Particularly useful for defining homogeneous
        boundary conditions.

        Parameters
        ----------
        function_space : dolfin.function.functionspace.FunctionSpace
                The function space onto which the BCs should be imposed on.
        value : dolfin.function.constant.Constant or dolfin.function.expression.Expression or dolfin.function.function.Function or float or tuple(float)
                The value of the boundary condition. Has to be compatible with the function_space,
                so that it could also be used as DirichletBC(function_space, value, ...).
        boundaries : dolfin.cpp.mesh.MeshFunctionSizet
                The MeshFunction object representing the boundaries.
        idcs : list[int] or int
                A list of indices / boundary markers that determine the boundaries
                onto which the Dirichlet boundary conditions should be applied to.
                Can also be a single integer for a single boundary.

        Returns
        -------
        list[dolfin.fem.dirichletbc.DirichletBC]
                A list of DirichletBC objects that represent the boundary conditions.

        Examples
        --------
        Generate homogeneous Dirichlet boundary conditions for all 4 sides of the unit square.

            from fenics import *
            import cashocs

            mesh, _, _, _, _, _ = cashocs.regular_mesh(25)
            V = FunctionSpace(mesh, &#39;CG&#39;, 1)
            bcs = cashocs.create_bcs_list(V, Constant(0), boundaries, [1,2,3,4])
        &#34;&#34;&#34;

        bcs_list = []
        if type(idcs) == list:
                for i in idcs:
                        bcs_list.append(fenics.DirichletBC(function_space, value, boundaries, i, **kwargs))

        elif type(idcs) == int:
                bcs_list.append(fenics.DirichletBC(function_space, value, boundaries, idcs, **kwargs))

        return bcs_list





class Interpolator:
        &#34;&#34;&#34;Efficient interpolation between two function spaces.

        This is very useful, if multiple interpolations have to be
        carried out between the same spaces, which is made significantly
        faster by computing the corresponding matrix.
        The function spaces can even be defined on different meshes.

        Examples
        --------
            from fenics import *
            import cashocs

            mesh, _, _, _, _, _ = cashocs.regular_mesh(25)
            V1 = FunctionSpace(mesh, &#39;CG&#39;, 1)
            V2 = FunctionSpace(mesh, &#39;CG&#39;, 2)

            expr = Expression(&#39;sin(2*pi*x[0])&#39;, degree=1)
            u = interpolate(expr, V1)

            interp = cashocs.utils.Interpolator(V1, V2)
            interp.interpolate(u)
        &#34;&#34;&#34;

        def __init__(self, V, W):
                &#34;&#34;&#34;Initializes the object.

                Parameters
                ----------
                V : dolfin.function.functionspace.FunctionSpace
                        The function space whose objects shall be interpolated.
                W : dolfin.function.functionspace.FunctionSpace
                        The space into which they shall be interpolated.
                &#34;&#34;&#34;
                
                if not (V.ufl_element().family() == &#39;Lagrange&#39; or (V.ufl_element().family() == &#39;Discontinuous Lagrange&#39; and V.ufl_element().degree() == 0)):
                        raise InputError(&#39;cashocs.utils.Interpolator&#39;, &#39;V&#39;, &#39;The interpolator only works with CG n or DG 0 elements&#39;)
                if not (W.ufl_element().family() == &#39;Lagrange&#39; or (W.ufl_element().family() == &#39;Discontinuous Lagrange&#39; and W.ufl_element().degree() == 0)):
                        raise InputError(&#39;cashocs.utils.Interpolator&#39;, &#39;W&#39;, &#39;The interpolator only works with CG n or DG 0 elements&#39;)
                
                self.V = V
                self.W = W
                self.transfer_matrix = fenics.PETScDMCollection.create_transfer_matrix(self.V, self.W)



        def interpolate(self, u):
                &#34;&#34;&#34;Interpolates function to target space.

                The function has to belong to the origin space, i.e., the first argument
                of __init__, and it is interpolated to the destination space, i.e., the
                second argument of __init__. There is no need to call set_allow_extrapolation
                on the function (this is done automatically due to the method).

                Parameters
                ----------
                u : dolfin.function.function.Function
                        The function that shall be interpolated.

                Returns
                -------
                dolfin.function.function.Function
                        The result of the interpolation.
                &#34;&#34;&#34;
                
                if not u.function_space() == self.V:
                        raise InputError(&#39;cashocs.utils.Interpolator.interpolate&#39;, &#39;u&#39;, &#39;The input does not belong to the correct function space.&#39;)
                v = fenics.Function(self.W)
                v.vector()[:] = (self.transfer_matrix*u.vector())[:]

                return v





def _assemble_petsc_system(A_form, b_form, bcs=None):
        &#34;&#34;&#34;Assembles a system symmetrically and converts objects to PETSc format.

        Parameters
        ----------
        A_form : ufl.form.Form
                The UFL form for the left-hand side of the linear equation.
        b_form : ufl.form.Form
                The UFL form for the right-hand side of the linear equation.
        bcs : None or dolfin.fem.dirichletbc.DirichletBC or list[dolfin.fem.dirichletbc.DirichletBC]
                A list of Dirichlet boundary conditions.

        Returns
        -------
        petsc4py.PETSc.Mat
                The petsc matrix for the left-hand side of the linear equation.
        petsc4py.PETSc.Vec
                The petsc vector for the right-hand side of the linear equation.

        Notes
        -----
        This function always uses the ident_zeros method of the matrix in order to add a one to the diagonal
        in case the corresponding row only consists of zeros. This allows for well-posed problems on the
        boundary etc.
        &#34;&#34;&#34;

        A, b = fenics.assemble_system(A_form, b_form, bcs, keep_diagonal=True)
        A.ident_zeros()

        A = fenics.as_backend_type(A).mat()
        b = fenics.as_backend_type(b).vec()

        return A, b



def _setup_petsc_options(ksps, ksp_options):
        &#34;&#34;&#34;Sets up an (iterative) linear solver.

        This is used to pass user defined command line type options for PETSc
        to the PETSc KSP objects. Here, options[i] is applied to ksps[i]

        Parameters
        ----------
        ksps : list[petsc4py.PETSc.KSP]
                A list of PETSc KSP objects (linear solvers) to which the (command line)
                options are applied to.
        ksp_options : list[list[list[str]]]
                A list of command line options that specify the iterative solver
                from PETSc.

        Returns
        -------
        None
        &#34;&#34;&#34;
        
        if not len(ksps) == len(ksp_options):
                raise InputError(&#39;cashocs.utils._setup_petsc_options&#39;, &#39;ksps&#39;, &#39;Length of ksp_options and ksps does not match.&#39;)

        opts = fenics.PETScOptions

        for i in range(len(ksps)):
                opts.clear()

                for option in ksp_options[i]:
                        opts.set(*option)

                ksps[i].setFromOptions()



def _solve_linear_problem(ksp=None, A=None, b=None, x=None):
        &#34;&#34;&#34;Solves a finite dimensional linear problem.

        Parameters
        ----------
        ksp : petsc4py.PETSc.KSP or None, optional
                The PETSc KSP object used to solve the problem. None means that the solver
                mumps is used (default is None).
        A : petsc4py.PETSc.Mat or None, optional
                The PETSc matrix corresponding to the left-hand side of the problem. If
                this is None, then the matrix stored in the ksp object is used. Raises
                an error if no matrix is stored. Default is None.
        b : petsc4py.PETSc.Vec or None, optional
                The PETSc vector corresponding to the right-hand side of the problem.
                If this is None, then a zero right-hand side is assumed, and a zero
                vector is returned. Default is None.
        x : petsc4py.PETSc.Vec or None, optional
                The PETSc vector that stores the solution of the problem. If this is
                None, then a new vector will be created (and returned)

        Returns
        -------
        petsc4py.PETSc.Vec
                The solution vector.
        &#34;&#34;&#34;

        if ksp is None:
                ksp = PETSc.KSP().create()
                options = [[
                        [&#39;ksp_type&#39;, &#39;preonly&#39;],
                        [&#39;pc_type&#39;, &#39;lu&#39;],
                        [&#39;pc_factor_mat_solver_type&#39;, &#39;mumps&#39;],
                        [&#39;mat_mumps_icntl_24&#39;, 1]
                ]]

                _setup_petsc_options([ksp], options)


        if A is not None:
                ksp.setOperators(A)
        else:
                A = ksp.getOperators()[0]
                if A.size[0] == -1 and A.size[1] == -1:
                        raise InputError(&#39;cashocs.utils._solve_linear_problem&#39;, &#39;ksp&#39;, &#39;The KSP object has to be initialized with some Matrix in case A is None.&#39;)

        if b is None:
                return A.getVecs()[0]

        if x is None:
                x, _ = A.getVecs()

        ksp.solve(b, x)

        if ksp.getConvergedReason() &lt; 0:
                raise PETScKSPError(ksp.getConvergedReason())

        return x



def write_out_mesh(mesh, original_msh_file, out_msh_file):
        &#34;&#34;&#34;Writes out the current mesh as .msh file.

        This method updates the vertex positions in the `original_gmsh_file`, the
        topology of the mesh and its connections are the same. The original gmsh
        file is kept, and a new one is generated under `out_mesh_file`.

        Parameters
        ----------
        mesh : dolfin.cpp.mesh.Mesh
                The mesh object in fenics that should be saved as gmsh file.
        original_msh_file : str
                Path to the original gmsh mesh file of the mesh object, has to
                end with &#39;.msh&#39;.
        out_msh_file : str
                Path (and name) of the output mesh file, has to end with &#39;.msh&#39;.

        Returns
        -------
        None

        Notes
        -----
        The method only works with gmsh mesh 4.1 file format. Others might also work,
        but this is not tested or ensured in any way.
        &#34;&#34;&#34;
        
        if not original_msh_file[-4:] == &#39;.msh&#39;:
                raise InputError(&#39;cashocs.utils.write_out_mesh&#39;, &#39;original_msh_file&#39;, &#39;Format for original_mesh_file is wrong, has to end in .msh&#39;)
        if not out_msh_file[-4:] == &#39;.msh&#39;:
                raise InputError(&#39;cashocs.utils.write_out_mesh&#39;, &#39;out_msh_file&#39;, &#39;Format for out_mesh_file is wrong, has to end in .msh&#39;)

        dim = mesh.geometric_dimension()

        with open(original_msh_file, &#39;r&#39;) as old_file, open(out_msh_file, &#39;w&#39;) as new_file:

                points = mesh.coordinates()

                node_section = False
                info_section = False
                subnode_counter = 0
                subwrite_counter = 0
                idcs = np.zeros(1, dtype=int)

                for line in old_file:
                        if line == &#39;$EndNodes\n&#39;:
                                node_section = False

                        if not node_section:
                                new_file.write(line)
                        else:
                                split_line = line.split(&#39; &#39;)
                                if info_section:
                                        new_file.write(line)
                                        info_section = False
                                else:
                                        if len(split_line) == 4:
                                                num_subnodes = int(split_line[-1][:-1])
                                                subnode_counter = 0
                                                subwrite_counter = 0
                                                idcs = np.zeros(num_subnodes, dtype=int)
                                                new_file.write(line)
                                        elif len(split_line) == 1:
                                                idcs[subnode_counter] = int(split_line[0][:-1]) - 1
                                                subnode_counter += 1
                                                new_file.write(line)
                                        elif len(split_line) == 3:
                                                if dim == 2:
                                                        mod_line = format(points[idcs[subwrite_counter]][0], &#39;.16f&#39;) + &#39; &#39; + format(points[idcs[subwrite_counter]][1], &#39;.16f&#39;) + &#39; &#39; + &#39;0\n&#39;
                                                elif dim == 3:
                                                        mod_line = format(points[idcs[subwrite_counter]][0], &#39;.16f&#39;) + &#39; &#39; + format(points[idcs[subwrite_counter]][1], &#39;.16f&#39;) + &#39; &#39; + format(points[idcs[subwrite_counter]][2], &#39;.16f&#39;) + &#39;\n&#39;
                                                else:
                                                        raise InputError(&#39;cashocs.utils.write_out_mesh&#39;, &#39;mesh&#39;, &#39;Not a valid dimension for the mesh.&#39;)
                                                new_file.write(mod_line)
                                                subwrite_counter += 1


                        if line == &#39;$Nodes\n&#39;:
                                node_section = True
                                info_section = True



def _optimization_algorithm_configuration(config, algorithm=None):
        &#34;&#34;&#34;Returns the internal name of the optimization algorithm and updates config.

        Parameters
        ----------
        config : configparser.ConfigParser or None
                The config of the problem.
        algorithm : str or None, optional
                A string representing user input for the optimization algorithm
                if this is set via keywords in the .solve() call. If this is
                None, then the config is used to return a consistent value
                for internal use. (Default is None).

        Returns
        -------
        str
                Internal name of the algorithms.
        &#34;&#34;&#34;

        internal_algorithm = None

        if algorithm is not None:
                overwrite = True
        else:
                overwrite = False

        if algorithm is None:
                algorithm = config.get(&#39;OptimizationRoutine&#39;, &#39;algorithm&#39;)
        
        if not type(algorithm) == str:
                raise InputError(&#39;cashocs.utils._optimization_algorithm_configuration&#39;, &#39;algorithm&#39;, &#39;Not a valid input type for algorithm. Has to be a string.&#39;)
        
        if algorithm in [&#39;gradient_descent&#39;, &#39;gd&#39;]:
                internal_algorithm = &#39;gradient_descent&#39;
        elif algorithm in [&#39;cg&#39;, &#39;conjugate_gradient&#39;, &#39;ncg&#39;, &#39;nonlinear_cg&#39;]:
                internal_algorithm = &#39;conjugate_gradient&#39;
        elif algorithm in [&#39;lbfgs&#39;, &#39;bfgs&#39;]:
                internal_algorithm = &#39;lbfgs&#39;
        elif algorithm in [&#39;newton&#39;]:
                internal_algorithm = &#39;newton&#39;
        elif algorithm in [&#39;pdas&#39;, &#39;primal_dual_active_set&#39;]:
                internal_algorithm = &#39;pdas&#39;
        else:
                raise InputError(&#39;cashocs.utils._optimization_algorithm_configuration&#39;, &#39;algorithm&#39;, &#39;Not a valid choice for the optimization algorithm.\n&#39;
                                                 &#39;      For a gradient descent method, use \&#39;gradient_descent\&#39; or \&#39;gd\&#39;.\n&#39;
                                                 &#39;      For a nonlinear conjugate gradient method use \&#39;cg\&#39;, \&#39;conjugate_gradient\&#39;, \&#39;ncg\&#39;, or \&#39;nonlinear_cg\&#39;.\n&#39;
                                                 &#39;      For a limited memory BFGS method use \&#39;bfgs\&#39; or \&#39;lbfgs\&#39;.\n&#39;
                                                 &#39;      For a truncated Newton method use \&#39;newton\&#39; (optimal control only).\n&#39;
                                                 &#39;      For a primal dual active set method use \&#39;pdas\&#39; or \&#39;primal dual active set\&#39; (optimal control only).&#39;)

        if overwrite:
                config.set(&#39;OptimizationRoutine&#39;, &#39;algorithm&#39;, internal_algorithm)

        return internal_algorithm</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cashocs.utils.create_bcs_list"><code class="name flex">
<span>def <span class="ident">create_bcs_list</span></span>(<span>function_space, value, boundaries, idcs, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create several Dirichlet boundary conditions at once.</p>
<p>Wraps multiple Dirichlet boundary conditions into a list, in case
they have the same value but are to be defined for multiple boundaries
with different markers. Particularly useful for defining homogeneous
boundary conditions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>function_space</code></strong> :&ensp;<code>dolfin.function.functionspace.FunctionSpace</code></dt>
<dd>The function space onto which the BCs should be imposed on.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>dolfin.function.constant.Constant</code> or <code>dolfin.function.expression.Expression</code> or <code>dolfin.function.function.Function</code> or <code>float</code> or <code>tuple(float)</code></dt>
<dd>The value of the boundary condition. Has to be compatible with the function_space,
so that it could also be used as DirichletBC(function_space, value, &hellip;).</dd>
<dt><strong><code>boundaries</code></strong> :&ensp;<code>dolfin.cpp.mesh.MeshFunctionSizet</code></dt>
<dd>The MeshFunction object representing the boundaries.</dd>
<dt><strong><code>idcs</code></strong> :&ensp;<code>list[int]</code> or <code>int</code></dt>
<dd>A list of indices / boundary markers that determine the boundaries
onto which the Dirichlet boundary conditions should be applied to.
Can also be a single integer for a single boundary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[dolfin.fem.dirichletbc.DirichletBC]</code></dt>
<dd>A list of DirichletBC objects that represent the boundary conditions.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Generate homogeneous Dirichlet boundary conditions for all 4 sides of the unit square.</p>
<pre><code>from fenics import *
import cashocs

mesh, _, _, _, _, _ = cashocs.regular_mesh(25)
V = FunctionSpace(mesh, 'CG', 1)
bcs = cashocs.create_bcs_list(V, Constant(0), boundaries, [1,2,3,4])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_bcs_list(function_space, value, boundaries, idcs, **kwargs):
        &#34;&#34;&#34;Create several Dirichlet boundary conditions at once.

        Wraps multiple Dirichlet boundary conditions into a list, in case
        they have the same value but are to be defined for multiple boundaries
        with different markers. Particularly useful for defining homogeneous
        boundary conditions.

        Parameters
        ----------
        function_space : dolfin.function.functionspace.FunctionSpace
                The function space onto which the BCs should be imposed on.
        value : dolfin.function.constant.Constant or dolfin.function.expression.Expression or dolfin.function.function.Function or float or tuple(float)
                The value of the boundary condition. Has to be compatible with the function_space,
                so that it could also be used as DirichletBC(function_space, value, ...).
        boundaries : dolfin.cpp.mesh.MeshFunctionSizet
                The MeshFunction object representing the boundaries.
        idcs : list[int] or int
                A list of indices / boundary markers that determine the boundaries
                onto which the Dirichlet boundary conditions should be applied to.
                Can also be a single integer for a single boundary.

        Returns
        -------
        list[dolfin.fem.dirichletbc.DirichletBC]
                A list of DirichletBC objects that represent the boundary conditions.

        Examples
        --------
        Generate homogeneous Dirichlet boundary conditions for all 4 sides of the unit square.

            from fenics import *
            import cashocs

            mesh, _, _, _, _, _ = cashocs.regular_mesh(25)
            V = FunctionSpace(mesh, &#39;CG&#39;, 1)
            bcs = cashocs.create_bcs_list(V, Constant(0), boundaries, [1,2,3,4])
        &#34;&#34;&#34;

        bcs_list = []
        if type(idcs) == list:
                for i in idcs:
                        bcs_list.append(fenics.DirichletBC(function_space, value, boundaries, i, **kwargs))

        elif type(idcs) == int:
                bcs_list.append(fenics.DirichletBC(function_space, value, boundaries, idcs, **kwargs))

        return bcs_list</code></pre>
</details>
</dd>
<dt id="cashocs.utils.create_config"><code class="name flex">
<span>def <span class="ident">create_config</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a config object from a config file.</p>
<p>Creates the config from a .ini file via the
configparser package.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the config .ini file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>configparser.ConfigParser</code></dt>
<dd>The output config file, which includes the path
to the .ini file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_config(path):
        &#34;&#34;&#34;Generates a config object from a config file.

        Creates the config from a .ini file via the
        configparser package.

        Parameters
        ----------
        path : str
                The path to the config .ini file.

        Returns
        -------
        configparser.ConfigParser
                The output config file, which includes the path
                to the .ini file.
        &#34;&#34;&#34;

        config = configparser.ConfigParser()
        config.read(path)

        return config</code></pre>
</details>
</dd>
<dt id="cashocs.utils.generate_measure"><code class="name flex">
<span>def <span class="ident">generate_measure</span></span>(<span>idx, measure)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a measure based on indices.</p>
<p>Generates a MeasureSum or EmptyMeasure object corresponding to
measure and the subdomains / boundaries specified in idx. This
is a convenient shortcut to writing dx(1) + dx(2) + dx(3) + &hellip;
in case many measures are involved.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>list[int]</code></dt>
<dd>A list of indices for the boundary / volume markers that
shall define the new measure.</dd>
<dt><strong><code>measure</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>The corresponding UFL measure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ufl.measure.Measure</code> or <code><a title="cashocs.utils.EmptyMeasure" href="#cashocs.utils.EmptyMeasure">EmptyMeasure</a></code></dt>
<dd>The corresponding sum of the measures or an empty measure.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>from fenics import *
import cashocs
mesh, _, boundaries, dx, ds, _ = cashocs.regular_mesh(25)
top_bottom_measure = cashocs.utils.generate_measure([3,4], ds)
assemble(1*top_bottom_measure)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_measure(idx, measure):
        &#34;&#34;&#34;Generates a measure based on indices.

        Generates a MeasureSum or EmptyMeasure object corresponding to
        measure and the subdomains / boundaries specified in idx. This
        is a convenient shortcut to writing dx(1) + dx(2) + dx(3) + ...
        in case many measures are involved.

        Parameters
        ----------
        idx : list[int]
                A list of indices for the boundary / volume markers that
                shall define the new measure.
        measure : ufl.measure.Measure
                The corresponding UFL measure.

        Returns
        -------
        ufl.measure.Measure or cashocs.utils.EmptyMeasure
                The corresponding sum of the measures or an empty measure.

        Examples
        --------
            from fenics import *
            import cashocs
            mesh, _, boundaries, dx, ds, _ = cashocs.regular_mesh(25)
            top_bottom_measure = cashocs.utils.generate_measure([3,4], ds)
            assemble(1*top_bottom_measure)
        &#34;&#34;&#34;

        if len(idx) == 0:
                out_measure = EmptyMeasure(measure)

        else:
                out_measure = measure(idx[0])

                for i in idx[1:]:
                        out_measure += measure(i)

        return out_measure</code></pre>
</details>
</dd>
<dt id="cashocs.utils.multiplication"><code class="name flex">
<span>def <span class="ident">multiplication</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Multiplies the elements of a list in a UFL friendly fashion.</p>
<p>Used to build the product of certain UFL expressions to construct
a UFL form.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>list[ufl.core.expr.Expr]</code> or <code>list[int]</code> or <code>list[float]</code></dt>
<dd>The list whose entries shall be multiplied.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>ufl.core.expr.Expr</code> or <code>int</code> or <code>float</code></dt>
<dd>The result of the multiplication.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="cashocs.utils.summation" href="#cashocs.utils.summation">summation()</a></code></dt>
<dd>Sums elements of a list.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>a = cashocs.multiplication([u.dx(i) for i in range(mesh.geometric_dimension())])
</code></pre>
<p>is equivalent to</p>
<pre><code>a = u.dx(0) * u.dx(1)
</code></pre>
<p>(for a 2D mesh).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiplication(x):
        &#34;&#34;&#34;Multiplies the elements of a list in a UFL friendly fashion.

        Used to build the product of certain UFL expressions to construct
        a UFL form.

        Parameters
        ----------
        x : list[ufl.core.expr.Expr] or list[int] or list[float]
                The list whose entries shall be multiplied.

        Returns
        -------
        y : ufl.core.expr.Expr or int or float
                The result of the multiplication.

        See Also
        --------
        summation : Sums elements of a list.

        Examples
        --------
            a = cashocs.multiplication([u.dx(i) for i in range(mesh.geometric_dimension())])

        is equivalent to

            a = u.dx(0) * u.dx(1)

        (for a 2D mesh).
        &#34;&#34;&#34;
        
        if len(x) == 0:
                y = fenics.Constant(1.0)
                print(&#39;Careful, empty list handed to multiplication&#39;)
        else:
                y = x[0]
                
                for item in x[1:]:
                        y *= item
                        
        return y</code></pre>
</details>
</dd>
<dt id="cashocs.utils.summation"><code class="name flex">
<span>def <span class="ident">summation</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Sums elements of a list in a UFL friendly fashion.</p>
<p>This can be used to sum, e.g., UFL forms, or UFL expressions
that can be used in UFL forms.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>list[ufl.form.Form]</code> or <code>list[int]</code> or <code>list[float]</code></dt>
<dd>The list of entries that shall be summed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>ufl.form.Form</code> or <code>int</code> or <code>float</code></dt>
<dd>Sum of input (same type as entries of input).</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="cashocs.utils.multiplication" href="#cashocs.utils.multiplication">multiplication()</a></code></dt>
<dd>Multiplies the elements of a list.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>For "usual" summation of integers or floats, the built-in sum function
of python or the numpy variant are recommended. Still, they are
incompatible with fenics objects, so this function should be used for
the latter.</p>
<h2 id="examples">Examples</h2>
<pre><code>a = cashocs.summation([u.dx(i)*v.dx(i)*dx for i in mesh.geometric_dimension()])
</code></pre>
<p>is equivalent to</p>
<pre><code>a = u.dx(0)*v.dx(0)*dx + u.dx(1)*v.dx(1)*dx
</code></pre>
<p>(for a 2D mesh).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summation(x):
        &#34;&#34;&#34;Sums elements of a list in a UFL friendly fashion.

        This can be used to sum, e.g., UFL forms, or UFL expressions
        that can be used in UFL forms.

        Parameters
        ----------
        x : list[ufl.form.Form] or list[int] or list[float]
                The list of entries that shall be summed.

        Returns
        -------
        y : ufl.form.Form or int or float
                Sum of input (same type as entries of input).

        See Also
        --------
        multiplication : Multiplies the elements of a list.

        Notes
        -----
        For &#34;usual&#34; summation of integers or floats, the built-in sum function
        of python or the numpy variant are recommended. Still, they are
        incompatible with fenics objects, so this function should be used for
        the latter.

        Examples
        --------
            a = cashocs.summation([u.dx(i)*v.dx(i)*dx for i in mesh.geometric_dimension()])

        is equivalent to

            a = u.dx(0)*v.dx(0)*dx + u.dx(1)*v.dx(1)*dx

        (for a 2D mesh).
        &#34;&#34;&#34;
        
        if len(x) == 0:
                y = fenics.Constant(0.0)
                print(&#39;Careful, empty list handed to summ&#39;)
        else:
                y = x[0]
                
                for item in x[1:]:
                        y += item
        
        return y</code></pre>
</details>
</dd>
<dt id="cashocs.utils.write_out_mesh"><code class="name flex">
<span>def <span class="ident">write_out_mesh</span></span>(<span>mesh, original_msh_file, out_msh_file)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes out the current mesh as .msh file.</p>
<p>This method updates the vertex positions in the <code>original_gmsh_file</code>, the
topology of the mesh and its connections are the same. The original gmsh
file is kept, and a new one is generated under <code>out_mesh_file</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>dolfin.cpp.mesh.Mesh</code></dt>
<dd>The mesh object in fenics that should be saved as gmsh file.</dd>
<dt><strong><code>original_msh_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the original gmsh mesh file of the mesh object, has to
end with '.msh'.</dd>
<dt><strong><code>out_msh_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path (and name) of the output mesh file, has to end with '.msh'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The method only works with gmsh mesh 4.1 file format. Others might also work,
but this is not tested or ensured in any way.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_out_mesh(mesh, original_msh_file, out_msh_file):
        &#34;&#34;&#34;Writes out the current mesh as .msh file.

        This method updates the vertex positions in the `original_gmsh_file`, the
        topology of the mesh and its connections are the same. The original gmsh
        file is kept, and a new one is generated under `out_mesh_file`.

        Parameters
        ----------
        mesh : dolfin.cpp.mesh.Mesh
                The mesh object in fenics that should be saved as gmsh file.
        original_msh_file : str
                Path to the original gmsh mesh file of the mesh object, has to
                end with &#39;.msh&#39;.
        out_msh_file : str
                Path (and name) of the output mesh file, has to end with &#39;.msh&#39;.

        Returns
        -------
        None

        Notes
        -----
        The method only works with gmsh mesh 4.1 file format. Others might also work,
        but this is not tested or ensured in any way.
        &#34;&#34;&#34;
        
        if not original_msh_file[-4:] == &#39;.msh&#39;:
                raise InputError(&#39;cashocs.utils.write_out_mesh&#39;, &#39;original_msh_file&#39;, &#39;Format for original_mesh_file is wrong, has to end in .msh&#39;)
        if not out_msh_file[-4:] == &#39;.msh&#39;:
                raise InputError(&#39;cashocs.utils.write_out_mesh&#39;, &#39;out_msh_file&#39;, &#39;Format for out_mesh_file is wrong, has to end in .msh&#39;)

        dim = mesh.geometric_dimension()

        with open(original_msh_file, &#39;r&#39;) as old_file, open(out_msh_file, &#39;w&#39;) as new_file:

                points = mesh.coordinates()

                node_section = False
                info_section = False
                subnode_counter = 0
                subwrite_counter = 0
                idcs = np.zeros(1, dtype=int)

                for line in old_file:
                        if line == &#39;$EndNodes\n&#39;:
                                node_section = False

                        if not node_section:
                                new_file.write(line)
                        else:
                                split_line = line.split(&#39; &#39;)
                                if info_section:
                                        new_file.write(line)
                                        info_section = False
                                else:
                                        if len(split_line) == 4:
                                                num_subnodes = int(split_line[-1][:-1])
                                                subnode_counter = 0
                                                subwrite_counter = 0
                                                idcs = np.zeros(num_subnodes, dtype=int)
                                                new_file.write(line)
                                        elif len(split_line) == 1:
                                                idcs[subnode_counter] = int(split_line[0][:-1]) - 1
                                                subnode_counter += 1
                                                new_file.write(line)
                                        elif len(split_line) == 3:
                                                if dim == 2:
                                                        mod_line = format(points[idcs[subwrite_counter]][0], &#39;.16f&#39;) + &#39; &#39; + format(points[idcs[subwrite_counter]][1], &#39;.16f&#39;) + &#39; &#39; + &#39;0\n&#39;
                                                elif dim == 3:
                                                        mod_line = format(points[idcs[subwrite_counter]][0], &#39;.16f&#39;) + &#39; &#39; + format(points[idcs[subwrite_counter]][1], &#39;.16f&#39;) + &#39; &#39; + format(points[idcs[subwrite_counter]][2], &#39;.16f&#39;) + &#39;\n&#39;
                                                else:
                                                        raise InputError(&#39;cashocs.utils.write_out_mesh&#39;, &#39;mesh&#39;, &#39;Not a valid dimension for the mesh.&#39;)
                                                new_file.write(mod_line)
                                                subwrite_counter += 1


                        if line == &#39;$Nodes\n&#39;:
                                node_section = True
                                info_section = True</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cashocs.utils.EmptyMeasure"><code class="flex name class">
<span>class <span class="ident">EmptyMeasure</span></span>
<span>(</span><span>measure)</span>
</code></dt>
<dd>
<div class="desc"><p>Implements an empty measure (e.g. of a null set).</p>
<p>This is used for automatic measure generation, e.g., if
the fixed boundary is empty for a shape optimization problem,
and is used to avoid case distinctions.</p>
<h2 id="examples">Examples</h2>
<pre><code>dm = EmptyMeasure(dx)
u*dm
</code></pre>
<p>is equivalent to</p>
<pre><code>Constant(0)*u*dm
</code></pre>
<p>so that this generates zeros when assembled over.</p>
<p>Initializes self.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>measure</code></strong> :&ensp;<code>ufl.measure.Measure</code></dt>
<dd>The underlying UFL measure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmptyMeasure:
        &#34;&#34;&#34;Implements an empty measure (e.g. of a null set).

        This is used for automatic measure generation, e.g., if
        the fixed boundary is empty for a shape optimization problem,
        and is used to avoid case distinctions.

        Examples
        --------
            dm = EmptyMeasure(dx)
            u*dm

        is equivalent to

            Constant(0)*u*dm

        so that this generates zeros when assembled over.
        &#34;&#34;&#34;

        def __init__(self, measure):
                &#34;&#34;&#34;Initializes self.

                Parameters
                ----------
                measure : ufl.measure.Measure
                        The underlying UFL measure.
                &#34;&#34;&#34;

                self.measure = measure



        def __rmul__(self, other):
                &#34;&#34;&#34;Multiplies the empty measure to the right.

                Parameters
                ----------
                other : ufl.core.expr.Expr
                        A UFL expression to be integrated over an empty measure.

                Returns
                -------
                ufl.form.Form
                        The resulting UFL form.
                &#34;&#34;&#34;

                return fenics.Constant(0)*other*self.measure</code></pre>
</details>
</dd>
<dt id="cashocs.utils.Interpolator"><code class="flex name class">
<span>class <span class="ident">Interpolator</span></span>
<span>(</span><span>V, W)</span>
</code></dt>
<dd>
<div class="desc"><p>Efficient interpolation between two function spaces.</p>
<p>This is very useful, if multiple interpolations have to be
carried out between the same spaces, which is made significantly
faster by computing the corresponding matrix.
The function spaces can even be defined on different meshes.</p>
<h2 id="examples">Examples</h2>
<pre><code>from fenics import *
import cashocs

mesh, _, _, _, _, _ = cashocs.regular_mesh(25)
V1 = FunctionSpace(mesh, 'CG', 1)
V2 = FunctionSpace(mesh, 'CG', 2)

expr = Expression('sin(2*pi*x[0])', degree=1)
u = interpolate(expr, V1)

interp = cashocs.utils.Interpolator(V1, V2)
interp.interpolate(u)
</code></pre>
<p>Initializes the object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>dolfin.function.functionspace.FunctionSpace</code></dt>
<dd>The function space whose objects shall be interpolated.</dd>
<dt><strong><code>W</code></strong> :&ensp;<code>dolfin.function.functionspace.FunctionSpace</code></dt>
<dd>The space into which they shall be interpolated.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Interpolator:
        &#34;&#34;&#34;Efficient interpolation between two function spaces.

        This is very useful, if multiple interpolations have to be
        carried out between the same spaces, which is made significantly
        faster by computing the corresponding matrix.
        The function spaces can even be defined on different meshes.

        Examples
        --------
            from fenics import *
            import cashocs

            mesh, _, _, _, _, _ = cashocs.regular_mesh(25)
            V1 = FunctionSpace(mesh, &#39;CG&#39;, 1)
            V2 = FunctionSpace(mesh, &#39;CG&#39;, 2)

            expr = Expression(&#39;sin(2*pi*x[0])&#39;, degree=1)
            u = interpolate(expr, V1)

            interp = cashocs.utils.Interpolator(V1, V2)
            interp.interpolate(u)
        &#34;&#34;&#34;

        def __init__(self, V, W):
                &#34;&#34;&#34;Initializes the object.

                Parameters
                ----------
                V : dolfin.function.functionspace.FunctionSpace
                        The function space whose objects shall be interpolated.
                W : dolfin.function.functionspace.FunctionSpace
                        The space into which they shall be interpolated.
                &#34;&#34;&#34;
                
                if not (V.ufl_element().family() == &#39;Lagrange&#39; or (V.ufl_element().family() == &#39;Discontinuous Lagrange&#39; and V.ufl_element().degree() == 0)):
                        raise InputError(&#39;cashocs.utils.Interpolator&#39;, &#39;V&#39;, &#39;The interpolator only works with CG n or DG 0 elements&#39;)
                if not (W.ufl_element().family() == &#39;Lagrange&#39; or (W.ufl_element().family() == &#39;Discontinuous Lagrange&#39; and W.ufl_element().degree() == 0)):
                        raise InputError(&#39;cashocs.utils.Interpolator&#39;, &#39;W&#39;, &#39;The interpolator only works with CG n or DG 0 elements&#39;)
                
                self.V = V
                self.W = W
                self.transfer_matrix = fenics.PETScDMCollection.create_transfer_matrix(self.V, self.W)



        def interpolate(self, u):
                &#34;&#34;&#34;Interpolates function to target space.

                The function has to belong to the origin space, i.e., the first argument
                of __init__, and it is interpolated to the destination space, i.e., the
                second argument of __init__. There is no need to call set_allow_extrapolation
                on the function (this is done automatically due to the method).

                Parameters
                ----------
                u : dolfin.function.function.Function
                        The function that shall be interpolated.

                Returns
                -------
                dolfin.function.function.Function
                        The result of the interpolation.
                &#34;&#34;&#34;
                
                if not u.function_space() == self.V:
                        raise InputError(&#39;cashocs.utils.Interpolator.interpolate&#39;, &#39;u&#39;, &#39;The input does not belong to the correct function space.&#39;)
                v = fenics.Function(self.W)
                v.vector()[:] = (self.transfer_matrix*u.vector())[:]

                return v</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cashocs.utils.Interpolator.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>self, u)</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolates function to target space.</p>
<p>The function has to belong to the origin space, i.e., the first argument
of <strong>init</strong>, and it is interpolated to the destination space, i.e., the
second argument of <strong>init</strong>. There is no need to call set_allow_extrapolation
on the function (this is done automatically due to the method).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>dolfin.function.function.Function</code></dt>
<dd>The function that shall be interpolated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dolfin.function.function.Function</code></dt>
<dd>The result of the interpolation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate(self, u):
        &#34;&#34;&#34;Interpolates function to target space.

        The function has to belong to the origin space, i.e., the first argument
        of __init__, and it is interpolated to the destination space, i.e., the
        second argument of __init__. There is no need to call set_allow_extrapolation
        on the function (this is done automatically due to the method).

        Parameters
        ----------
        u : dolfin.function.function.Function
                The function that shall be interpolated.

        Returns
        -------
        dolfin.function.function.Function
                The result of the interpolation.
        &#34;&#34;&#34;
        
        if not u.function_space() == self.V:
                raise InputError(&#39;cashocs.utils.Interpolator.interpolate&#39;, &#39;u&#39;, &#39;The input does not belong to the correct function space.&#39;)
        v = fenics.Function(self.W)
        v.vector()[:] = (self.transfer_matrix*u.vector())[:]

        return v</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = 'search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cashocs" href="index.html">cashocs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="cashocs.utils.create_bcs_list" href="#cashocs.utils.create_bcs_list">create_bcs_list</a></code></li>
<li><code><a title="cashocs.utils.create_config" href="#cashocs.utils.create_config">create_config</a></code></li>
<li><code><a title="cashocs.utils.generate_measure" href="#cashocs.utils.generate_measure">generate_measure</a></code></li>
<li><code><a title="cashocs.utils.multiplication" href="#cashocs.utils.multiplication">multiplication</a></code></li>
<li><code><a title="cashocs.utils.summation" href="#cashocs.utils.summation">summation</a></code></li>
<li><code><a title="cashocs.utils.write_out_mesh" href="#cashocs.utils.write_out_mesh">write_out_mesh</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cashocs.utils.EmptyMeasure" href="#cashocs.utils.EmptyMeasure">EmptyMeasure</a></code></h4>
</li>
<li>
<h4><code><a title="cashocs.utils.Interpolator" href="#cashocs.utils.Interpolator">Interpolator</a></code></h4>
<ul class="">
<li><code><a title="cashocs.utils.Interpolator.interpolate" href="#cashocs.utils.Interpolator.interpolate">interpolate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>