"""Mesh generation and import tools.

This module consists of tools for for the fast generation
or import of meshes into fenics. The import_mesh function
is used to import (converted) gmsh mesh files, and the
regular_(box_)mesh commands create 2D and 3D box meshes
which are great for testing.
"""

import fenics
import numpy as np
import time
from petsc4py import PETSc
import os
import sys
import uuid
import configparser
from .utils import _setup_petsc_options, write_out_mesh
import json



def import_mesh(arg):
	"""Imports a mesh file for use with cestrel / fenics.

	This function imports a mesh file that was generated by GMSH and converted to
	.xdmf with the command line function mesh-convert (see cestrel main documentation).
	The syntax for the conversion is
		mesh-convert in.msh out.xdmf
	If there are Physical quantities specified in the gmsh file, these are imported
	to the subdomains and boundaries output of this function and can also be directly
	accessed via the measures, e.g., with dx(1), ds(1), etc.

	Parameters
	----------
	arg : str or configparser.ConfigParser
		This is either a string, in which case it corresponds to the location
		of the mesh file in .xdmf file format, or a config file that
		has this path stored in its settings.

	Returns
	-------
	mesh : dolfin.cpp.mesh.Mesh
		The imported (computational) mesh.
	subdomains : dolfin.cpp.mesh.MeshFunctionSizet
		A MeshFunction object containing the subdomains,
		i.e., the Physical regions marked in the gmsh
		file.
	boundaries : dolfin.cpp.mesh.MeshFunctionSizet
		A MeshFunction object containing the boundaries,
		i.e., the Physical regions marked in the gmsh
		file. Can be, e.g., used to set up boundary
		conditions.
	dx : ufl.measure.Measure
		The volume measure of the mesh corresponding to
		the subdomains (i.e. gmsh Physical region indices).
	ds : ufl.measure.Measure
		The surface measure of the mesh corresponding to
		the boundaries (i.e. gmsh Physical region indices).
	dS : ufl.measure.Measure
		The interior facet measure of the mesh corresponding
		to boundaries (i.e. gmsh Physical region indices).
	"""
	
	start_time = time.time()
	print('Importing mesh to FEniCS')
	# Check for the file format

	if type(arg) == str:
		mesh_file = arg
		mesh_attribute = 'str'
	elif type(arg) == configparser.ConfigParser:
		mesh_attribute = 'config'
		### overloading for remeshing
		if not arg.getboolean('Mesh', 'remesh', fallback=False):
			mesh_file = arg.get('Mesh', 'mesh_file')
		else:
			assert len(sys.argv) in [1, 2], 'Do not use additional command line options.'
			if len(sys.argv) == 1:
				mesh_file = arg.get('Mesh', 'mesh_file')
			elif len(sys.argv) == 2:
				temp_dir = sys.argv[1]
				with open(temp_dir + '/temp_dict.json', 'r') as file:
					temp_dict = json.load(file)
				mesh_file = temp_dict['mesh_file']

	else:
		raise Exception('Not a valid input for import_mesh')

	if mesh_file[-5:] == '.xdmf':
		file_string = mesh_file[:-5]
	else:
		raise Exception('Not a suitable mesh file format')
	
	mesh = fenics.Mesh()
	xdmf_file = fenics.XDMFFile(mesh.mpi_comm(), mesh_file)
	xdmf_file.read(mesh)
	xdmf_file.close()
	
	subdomains_mvc = fenics.MeshValueCollection('size_t', mesh, mesh.geometric_dimension())
	boundaries_mvc = fenics.MeshValueCollection('size_t', mesh, mesh.geometric_dimension() - 1)

	if os.path.exists(file_string + '_subdomains.xdmf'):
		xdmf_subdomains = fenics.XDMFFile(mesh.mpi_comm(), file_string + '_subdomains.xdmf')
		xdmf_subdomains.read(subdomains_mvc, 'subdomains')
		xdmf_subdomains.close()
	if os.path.exists(file_string + '_boundaries.xdmf'):
		xdmf_boundaries = fenics.XDMFFile(mesh.mpi_comm(), file_string + '_boundaries.xdmf')
		xdmf_boundaries.read(boundaries_mvc, 'boundaries')
		xdmf_boundaries.close()

	subdomains = fenics.MeshFunction('size_t', mesh, subdomains_mvc)
	boundaries = fenics.MeshFunction('size_t', mesh, boundaries_mvc)

	dx = fenics.Measure('dx', domain=mesh, subdomain_data=subdomains)
	ds = fenics.Measure('ds', domain=mesh, subdomain_data=boundaries)
	dS = fenics.Measure('dS', domain=mesh, subdomain_data=boundaries)
	
	end_time = time.time()
	print('Done Importing Mesh. Elapsed Time: ' + format(end_time - start_time, '.3e') + ' s')
	print('')

	# Add an attribute to the mesh to show with what procedure it was generated
	mesh._cestrel_generator = mesh_attribute

	return mesh, subdomains, boundaries, dx, ds, dS



def regular_mesh(n=10, L_x=1.0, L_y=1.0, L_z=None):
	r"""Creates a mesh corresponding to a rectangle or cube.

	This function creates a uniform mesh of either a rectangle
	or a cube, starting at the origin and having length specified
	in lx, lx, lz. The resulting mesh uses n elements along the
	shortest direction and accordingly many along the longer ones.
	The resulting domain is
		$$[0, L_x] \times [0, L_y] \phantom{ \times [0, L_z] a} \quad \text{ in } 2D, \\
		[0, L_x] \times [0, L_y] \times [0, L_z] \quad \text{ in } 3D.
		$$

	The boundary markers are ordered as follows:

	  - 1 corresponds to \(\{x=0\}\)

	  - 2 corresponds to \(\{x=L_x\}\)

	  - 3 corresponds to \(\{y=0\}\)

	  - 4 corresponds to \(\{y=L_y\}\)

	  - 5 corresponds to \(\{z=0\}\) (only in 3D)

	  - 6 corresponds to \(\{z=L_z\}\) (only in 3D)

	Parameters
	----------
	n : int
		Number of elements in the shortest coordinate direction.
	L_x : float
		Length in x-direction.
	L_y : float
		Length in y-direction.
	L_z : float or None, optional
		Length in z-direction, if this is None, then the geometry
		will be two-dimensional (default is None).

	Returns
	-------
	mesh : dolfin.cpp.mesh.Mesh
		The computational mesh.
	subdomains : dolfin.cpp.mesh.MeshFunctionSizet
		A MeshFunction object containing the subdomains.
	boundaries : dolfin.cpp.mesh.MeshFunctionSizet
		A MeshFunction object containing the boundaries.
	dx : ufl.measure.Measure
		The volume measure of the mesh corresponding to subdomains.
	ds : ufl.measure.Measure
		The surface measure of the mesh corresponding to boundaries.
	dS : ufl.measure.Measure
		The interior facet measure of the mesh corresponding to boundaries.
	"""

	n = int(n)
	
	if L_z is None:
		sizes = [L_x, L_y]
		dim = 2
	else:
		sizes = [L_x, L_y, L_z]
		dim = 3
	
	size_min = np.min(sizes)
	num_points = [int(np.round(length/size_min*n)) for length in sizes]
	
	if L_z is None:
		mesh = fenics.RectangleMesh(fenics.Point(0, 0), fenics.Point(sizes), num_points[0], num_points[1])
	else:
		mesh = fenics.BoxMesh(fenics.Point(0, 0, 0), fenics.Point(sizes), num_points[0], num_points[1], num_points[2])
	
	subdomains = fenics.MeshFunction('size_t', mesh, dim=dim)
	boundaries = fenics.MeshFunction('size_t', mesh, dim=dim - 1)
	
	x_min = fenics.CompiledSubDomain('on_boundary && near(x[0], 0, tol)', tol=fenics.DOLFIN_EPS)
	x_max = fenics.CompiledSubDomain('on_boundary && near(x[0], length, tol)', tol=fenics.DOLFIN_EPS, length=sizes[0])
	x_min.mark(boundaries, 1)
	x_max.mark(boundaries, 2)

	y_min = fenics.CompiledSubDomain('on_boundary && near(x[1], 0, tol)', tol=fenics.DOLFIN_EPS)
	y_max = fenics.CompiledSubDomain('on_boundary && near(x[1], length, tol)', tol=fenics.DOLFIN_EPS, length=sizes[1])
	y_min.mark(boundaries, 3)
	y_max.mark(boundaries, 4)

	if L_z is not None:
		z_min = fenics.CompiledSubDomain('on_boundary && near(x[2], 0, tol)', tol=fenics.DOLFIN_EPS)
		z_max = fenics.CompiledSubDomain('on_boundary && near(x[2], length, tol)', tol=fenics.DOLFIN_EPS, length=sizes[2])
		z_min.mark(boundaries, 5)
		z_max.mark(boundaries, 6)
	
	dx = fenics.Measure('dx', mesh, subdomain_data=subdomains)
	ds = fenics.Measure('ds', mesh, subdomain_data=boundaries)
	dS = fenics.Measure('dS', mesh)
	
	return mesh, subdomains, boundaries, dx, ds, dS



def regular_box_mesh(n=10, S_x=0.0, S_y=0.0, S_z=None, E_x=1.0, E_y=1.0, E_z=None):
	r"""Creates a mesh corresponding to a rectangle or cube.

	This function creates a uniform mesh of either a rectangle
	or a cube, with specified start (S_) and end points (E_).
	The resulting mesh uses n elements along the shortest direction
	and accordingly many along the longer ones. The resulting domain is
		$$[S_x, E_x] \times [S_y, E_y] \phantom{ \times [S_z, E_z] a} \quad \text{ in } 2D, \\
		[S_x, E_x] \times [S_y, E_y] \times [S_z, E_z] \quad \text{ in } 3D.
		$$

	The boundary markers are ordered as follows:

	  - 1 corresponds to \(\{x=S_x\}\)

	  - 2 corresponds to \(\{x=E_x\}\)

	  - 3 corresponds to \(\{y=S_y\}\)

	  - 4 corresponds to \(\{y=E_y\}\)

	  - 5 corresponds to \(\{z=S_z\}\) (only in 3D)

	  - 6 corresponds to \(\{z=E_z\}\) (only in 3D)

	Parameters
	----------
	n : int
		Number of elements in the shortest coordinate direction.
	S_x : float
		Start of the x-interval.
	S_y : float
		Start of the y-interval.
	S_z : float or None, optional
		Start of the z-interval, mesh is 2D if this is None
		(default is None).
	E_x : float
		End of the x-interval.
	E_y : float
		End of the y-interval.
	E_z : float or None, optional
		End of the z-interval, mesh is 2D if this is None
		(default is None).

	Returns
	-------
	mesh : dolfin.cpp.mesh.Mesh
		the computational mesh
	subdomains : dolfin.cpp.mesh.MeshFunctionSizet
		a MeshFunction object containing the subdomains
	boundaries : dolfin.cpp.mesh.MeshFunctionSizet
		a MeshFunction object containing the boundaries
	dx : ufl.measure.Measure
		the volume measure of the mesh corresponding to subdomains
	ds : ufl.measure.Measure
		the surface measure of the mesh corresponding to boundaries
	dS : ufl.measure.Measure
		the interior facet measure of the mesh corresponding to boundaries
	"""

	n = int(n)

	assert S_x < E_x, 'Incorrect input for the x-coordinate'
	assert S_y < E_y, 'Incorrect input for the y-coordinate'
	assert (S_z is None and E_z is None) or (S_z < E_z), 'Incorrect input for the z-coordinate'

	if S_z is None:
		lx = E_x - S_x
		ly = E_y - S_y
		sizes = [lx, ly]
		dim = 2
	else:
		lx = E_x - S_x
		ly = E_y - S_y
		lz = E_z - S_z
		sizes = [lx, ly, lz]
		dim = 3

	size_min = np.min(sizes)
	num_points = [int(np.round(length/size_min*n)) for length in sizes]

	if S_z is None:
		mesh = fenics.RectangleMesh(fenics.Point(S_x, S_y), fenics.Point(E_x, E_y), num_points[0], num_points[1])
	else:
		mesh = fenics.BoxMesh(fenics.Point(S_x, S_y, S_z), fenics.Point(E_x, E_y, E_z), num_points[0], num_points[1], num_points[2])

	subdomains = fenics.MeshFunction('size_t', mesh, dim=dim)
	boundaries = fenics.MeshFunction('size_t', mesh, dim=dim - 1)

	x_min = fenics.CompiledSubDomain('on_boundary && near(x[0], sx, tol)', tol=fenics.DOLFIN_EPS, sx=S_x)
	x_max = fenics.CompiledSubDomain('on_boundary && near(x[0], ex, tol)', tol=fenics.DOLFIN_EPS, ex=E_x)
	x_min.mark(boundaries, 1)
	x_max.mark(boundaries, 2)

	y_min = fenics.CompiledSubDomain('on_boundary && near(x[1], sy, tol)', tol=fenics.DOLFIN_EPS, sy=S_y)
	y_max = fenics.CompiledSubDomain('on_boundary && near(x[1], ey, tol)', tol=fenics.DOLFIN_EPS, ey=E_y)
	y_min.mark(boundaries, 3)
	y_max.mark(boundaries, 4)

	if S_z is not None:
		z_min = fenics.CompiledSubDomain('on_boundary && near(x[2], sz, tol)', tol=fenics.DOLFIN_EPS, sz=S_z)
		z_max = fenics.CompiledSubDomain('on_boundary && near(x[2], ez, tol)', tol=fenics.DOLFIN_EPS, ez=E_z)
		z_min.mark(boundaries, 5)
		z_max.mark(boundaries, 6)

	dx = fenics.Measure('dx', mesh, subdomain_data=subdomains)
	ds = fenics.Measure('ds', mesh, subdomain_data=boundaries)
	dS = fenics.Measure('dS', mesh)

	return mesh, subdomains, boundaries, dx, ds, dS





class _MeshHandler:
	"""Handles the mesh for shape optimization problems.

	This class implements all mesh related things for the shape optimization,
	 such as transformations and remeshing. Also includes mesh quality control
	 checks.
	"""

	def __init__(self, shape_optimization_problem):
		"""Initializes the MeshHandler object.

		Parameters
		----------
		shape_optimization_problem : cestrel._shape_optimization.shape_optimization_problem.ShapeOptimizationProblem
			The corresponding shape optimization problem.
		"""

		self.shape_optimization_problem = shape_optimization_problem
		self.shape_form_handler = self.shape_optimization_problem.shape_form_handler
		# Namespacing
		self.mesh = self.shape_form_handler.mesh
		self.dx = self.shape_form_handler.dx
		self.bbtree = self.mesh.bounding_box_tree()
		self.config = self.shape_form_handler.config

		self.check_a_posteriori = self.config.getboolean('MeshQuality', 'check_a_posteriori', fallback=True)
		self.volume_change = float(self.config.get('MeshQuality', 'volume_change', fallback='inf'))
		self.angle_change = float(self.config.get('MeshQuality', 'angle_change', fallback='inf'))

		self.radius_ratios_initial_mf = fenics.MeshQuality.radius_ratios(self.mesh)
		self.radius_ratios_initial = self.radius_ratios_initial_mf.array().copy()

		self.mesh_quality_tol = self.config.getfloat('MeshQuality', 'qtol', fallback=0.25)
		self.min_quality = 1.0

		self.__setup_decrease_computation()
		self.__setup_a_priori()

		# Remeshing initializations
		self.do_remesh = self.config.getboolean('Mesh', 'remesh', fallback=False)

		if self.do_remesh:
			self.temp_dict = self.shape_optimization_problem.temp_dict
			self.remesh_counter = self.temp_dict.get('remesh_counter', 0)
			self.gmsh_file = self.temp_dict['gmsh_file']
			assert self.gmsh_file[-4:] == '.msh', 'Not a valid gmsh file'
			self.mesh_directory = os.path.dirname(os.path.realpath(self.config.get('Mesh', 'gmsh_file')))

			self.remesh_directory = self.mesh_directory + '/cestrel_remesh'
			if not os.path.exists(self.remesh_directory):
				os.mkdir(self.remesh_directory)
			if len(sys.argv) == 1:
				os.system('rm -r ' + self.remesh_directory + '/*')
			self.remesh_geo_file = self.remesh_directory + '/remesh.geo'

		# create a copy of the initial mesh file
		if self.do_remesh and self.remesh_counter == 0:
			self.gmsh_file_init = self.remesh_directory + '/mesh_' + format(self.remesh_counter, '02d') + '.msh'
			copy_mesh = 'cp ' + self.gmsh_file + ' ' + self.gmsh_file_init
			os.system(copy_mesh)
			self.gmsh_file = self.gmsh_file_init



	def move_mesh(self, transformation):
		r"""Transforms the mesh by perturbation of identity.

		Moves the mesh according to the deformation given by
		$$\text{id} + \mathcal{V}(x),
		$$
		where \(\mathcal{V}\) is the transformation. This
		represents the perturbation of identity.

		Parameters
		----------
		transformation : dolfin.function.function.Function
			The transformation for the mesh, a vector CG1 Function
		"""

		assert transformation.ufl_element().family() == 'Lagrange' and \
			   transformation.ufl_element().degree() == 1, 'Not a valid mesh transformation'

		if not self.__test_a_priori(transformation):
			return False
		else:
			self.old_coordinates = self.mesh.coordinates().copy()
			fenics.ALE.move(self.mesh, transformation)
			self.bbtree.build(self.mesh)

			return self.__test_a_posteriori()



	def revert_transformation(self):
		"""Reverts a mesh transformation.

		This is used when the mesh quality for the resulting deformed mesh
		is not sufficient, or when the solution algorithm terminates due
		to lack of decrease in the Armijo rule, e.g..

		Returns
		-------
		None
		"""

		self.mesh.coordinates()[:, :] = self.old_coordinates
		self.bbtree.build(self.mesh)



	def __setup_decrease_computation(self):
		"""Initializes attributes and solver for the frobenius norm check

		Returns
		-------
		None
		"""

		assert self.angle_change > 0, 'Angle change has to be positive'

		options = [[
				['ksp_type', 'preonly'],
				['pc_type', 'jacobi'],
				['pc_jacobi_type', 'diagonal'],
				['ksp_rtol', 1e-16],
				['ksp_atol', 1e-20],
				['ksp_max_it', 1000]
		]]
		self.ksp_frobenius = PETSc.KSP().create()
		_setup_petsc_options([self.ksp_frobenius], options)

		self.trial_dg0 = fenics.TrialFunction(self.shape_form_handler.DG0)
		self.test_dg0 = fenics.TestFunction(self.shape_form_handler.DG0)

		if not self.angle_change == float('inf'):
			self.search_direction_container = fenics.Function(self.shape_form_handler.deformation_space)

			a_frobenius = self.trial_dg0*self.test_dg0*self.dx
			self.A_frobenius = fenics.as_backend_type(fenics.assemble(a_frobenius)).mat()
			self.ksp_frobenius.setOperators(self.A_frobenius)
			self.L_frobenius = fenics.sqrt(fenics.inner(fenics.grad(self.search_direction_container), fenics.grad(self.search_direction_container)))*self.test_dg0*self.dx



	def compute_decreases(self, search_direction, stepsize):
		"""Estimates the number of Armijo decreases for a certain mesh quality.

		Gives a better estimation of the stepsize. The output is
		the number of Armijo decreases we have to do in order to
		get a transformation that satisfies norm(transformation)_fro <= tol,
		where transformation = stepsize*search_direction and tol is specified in
		the config file under "angle_change". Due to the linearity
		of the norm this has to be done only once, all smaller stepsizes are
		feasible wrt. to this criterion as well

		Parameters
		----------
		search_direction : dolfin.function.function.Function
			The search direction in the optimization routine / descent algorithm
		stepsize : float
			The stepsize in the descent algorithm

		Returns
		-------
		int
			A guess for the number of "Armijo halvings" to get a better stepsize
		"""


		assert self.angle_change > 0, 'Angle change has to be positive'
		if self.angle_change == float('inf'):
			return 0

		else:
			self.search_direction_container.vector()[:] = search_direction.vector()[:]
			b = fenics.as_backend_type(fenics.assemble(self.L_frobenius)).vec()
			x, _ = self.A_frobenius.getVecs()

			self.ksp_frobenius.solve(b, x)
			if self.ksp_frobenius.getConvergedReason() < 0:
				raise Exception('Krylov solver did not converge. Reason: ' + str(self.ksp_frobenius.getConvergedReason()))

			frobenius_norm = np.max(x[:])
			beta_armijo = self.config.getfloat('OptimizationRoutine', 'beta_armijo', fallback=2)

			return np.maximum(np.ceil(np.log(self.angle_change/stepsize/frobenius_norm)/np.log(1/beta_armijo)), 0.0)



	def __setup_a_priori(self):
		"""Sets up the attributes and petsc solver for the a priori quality check

		Returns
		-------
		None
		"""

		if self.volume_change < float('inf'):
			options = [[
				['ksp_type', 'preonly'],
				['pc_type', 'jacobi'],
				['pc_jacobi_type', 'diagonal'],
				['ksp_rtol', 1e-16],
				['ksp_atol', 1e-20],
				['ksp_max_it', 1000]
			]]
			self.ksp_prior = PETSc.KSP().create()
			_setup_petsc_options([self.ksp_prior], options)

			self.transformation_container = fenics.Function(self.shape_form_handler.deformation_space)
			dim = self.mesh.geometric_dimension()
			assert self.volume_change > 1, 'Volume change has to be larger than 1'
			a_prior = self.trial_dg0*self.test_dg0*self.dx
			self.A_prior = fenics.as_backend_type(fenics.assemble(a_prior)).mat()
			self.ksp_prior.setOperators(self.A_prior)
			self.L_prior = fenics.det(fenics.Identity(dim) + fenics.grad(self.transformation_container))*self.test_dg0*self.dx





	def __test_a_priori(self, transformation):
		"""Check the quality of the transformation before the actual mesh is moved.

		Checks the quality of the transformation. The criterion is that
		 det(I + D transformation) should neither be too large nor too small
		in order to achieve the best transformations.

		Parameters
		----------
		transformation : dolfin.function.function.Function
			The transformation for the mesh

		Returns
		-------
		bool
			A boolean that indicates whether the desired transformation is feasible
		"""

		if self.volume_change < float('inf'):

			self.transformation_container.vector()[:] = transformation.vector()[:]

			b = fenics.as_backend_type(fenics.assemble(self.L_prior)).vec()
			x, _ = self.A_prior.getVecs()

			self.ksp_prior.solve(b, x)
			if self.ksp_prior.getConvergedReason() < 0:
				raise Exception('Krylov solver did not converge. Reason: ' + str(self.ksp_prior.getConvergedReason()))

			min_det = np.min(x[:])
			max_det = np.max(x[:])

			return (min_det >= 1/self.volume_change) and (max_det <= self.volume_change)

		else:
			return True



	def __test_a_posteriori(self):
		"""Check the quality of the transformation after the actual mesh is moved.

		Checks whether the mesh is a valid finite element mesh
		after it has been moved, i.e., if there are no overlapping
		or self intersecting elements.

		Returns
		-------
		bool
			True if the test is successful, False otherwise
		"""

		if self.check_a_posteriori:
			mesh = self.mesh
			cells = mesh.cells()
			coordinates = mesh.coordinates()
			self_intersections = False
			for i in range(coordinates.shape[0]):
				x = fenics.Point(coordinates[i])
				cells_idx = self.bbtree.compute_entity_collisions(x)
				intersections = len(cells_idx)
				M = cells[cells_idx]
				occurences = M.flatten().tolist().count(i)

				if intersections > occurences:
					self_intersections = True
					break

			if self_intersections:
				self.revert_transformation()
				return False
			else:
				return True

		else:
			return True



	def compute_relative_quality(self):
		"""Computes the relative mesh quality for the current mesh

		Returns
		-------
		None
		"""

		radius_ratios_mf = fenics.MeshQuality.radius_ratios(self.mesh)
		self.radius_ratios = radius_ratios_mf.array().copy()
		relative_quality = self.radius_ratios / self.radius_ratios_initial
		self.min_quality = np.min(relative_quality)



	def write_out_mesh(self):
		"""Writes out the current mesh as .msh file

		Returns
		-------
		None
		"""

		# TODO: Put this as a general, accessible routine

		dim = self.mesh.geometric_dimension()

		old_file = open(self.gmsh_file, 'r')
		self.temp_file = self.remesh_directory + '/mesh_' + str(uuid.uuid4().hex) + '.msh'
		new_file = open(self.temp_file, 'w')

		points = self.mesh.coordinates()

		node_section = False
		info_section = False
		subnode_counter = 0
		subwrite_counter = 0
		idcs = np.zeros(1, dtype=int)

		for line in old_file:
			if line == '$EndNodes\n':
				node_section = False

			if not node_section:
				new_file.write(line)
			else:
				split_line = line.split(' ')
				if info_section:
					new_file.write(line)
					info_section = False
				else:
					if len(split_line) == 4:
						num_subnodes = int(split_line[-1][:-1])
						subnode_counter = 0
						subwrite_counter = 0
						idcs = np.zeros(num_subnodes, dtype=int)
						new_file.write(line)
					elif len(split_line) == 1:
						idcs[subnode_counter] = int(split_line[0][:-1]) - 1
						subnode_counter += 1
						new_file.write(line)
					elif len(split_line) == 3:
						if dim == 2:
							mod_line = format(points[idcs[subwrite_counter]][0], '.16f') + ' ' + format(points[idcs[subwrite_counter]][1], '.16f') + ' ' + '0\n'
						elif dim == 3:
							mod_line = format(points[idcs[subwrite_counter]][0], '.16f') + ' ' + format(points[idcs[subwrite_counter]][1], '.16f') + ' ' + format(points[idcs[subwrite_counter]][2], '.16f') + '\n'
						new_file.write(mod_line)
						subwrite_counter += 1


			if line == '$Nodes\n':
				node_section = True
				info_section = True

		old_file.close()
		new_file.close()



	def __generate_remesh_geo(self, input_mesh_file):
		"""Generates a .geo file used for remeshing

		The .geo file is generated via the original .geo file for the
		initial geometry, so that mesh size fields are correctly given
		for the remeshing

		Parameters
		----------
		input_mesh_file : str
			Path to the mesh file used for generating the new .geo file

		Returns
		-------
		None
		"""

		with open(self.remesh_geo_file, 'w') as file:
			temp_name = os.path.split(input_mesh_file)[1]

			file.write('Merge \'' + temp_name + '\';\n')
			file.write('CreateGeometry;\n')
			file.write('\n')

			geo_file = self.temp_dict['geo_file']
			with open(geo_file, 'r') as f:
				for line in f:
					if line[:2] == 'lc':
						file.write(line)
					if line[:5] == 'Field':
						file.write(line)
					if line[:16] == 'Background Field':
						file.write(line)



	def remesh(self):
		"""Remeshes the current geometry with gmsh.

		Performs a remeshing of the geometry, and then restarts
		the optimization problem with the new mesh.

		Returns
		-------
		None
		"""

		if self.do_remesh:
			self.temp_file = self.remesh_directory + '/mesh_' + str(uuid.uuid4().hex) + '.msh'
			write_out_mesh(self.mesh, self.gmsh_file, self.temp_file)
			self.__generate_remesh_geo(self.temp_file)

			# save the output dict (without the last entries since they are "remeshed")
			self.temp_dict['output_dict'] = {}
			self.temp_dict['output_dict']['state_solves'] = self.shape_optimization_problem.state_problem.number_of_solves
			self.temp_dict['output_dict']['adjoint_solves'] = self.shape_optimization_problem.adjoint_problem.number_of_solves
			self.temp_dict['output_dict']['iterations'] = self.shape_optimization_problem.solver.iteration

			self.temp_dict['output_dict']['cost_function_value'] = self.shape_optimization_problem.solver.output_dict['cost_function_value'][:-1]
			self.temp_dict['output_dict']['gradient_norm'] = self.shape_optimization_problem.solver.output_dict['gradient_norm'][:-1]
			self.temp_dict['output_dict']['stepsize'] = self.shape_optimization_problem.solver.output_dict['stepsize'][:-1]
			self.temp_dict['output_dict']['MeshQuality'] = self.shape_optimization_problem.solver.output_dict['MeshQuality'][:-1]

			dim = self.mesh.geometric_dimension()

			gmsh_command = 'gmsh ' + self.remesh_geo_file + ' -' + str(int(dim)) + ' -o ' + self.temp_file
			# os.system(gmsh_command + ' >/dev/null 2>&1')
			os.system(gmsh_command)
			self.remesh_counter += 1

			self.temp_dict['remesh_counter'] = self.remesh_counter

			self.new_gmsh_file = self.remesh_directory + '/mesh_' + format(self.remesh_counter, '02d') + '.msh'
			rename_command = 'mv ' + self.temp_file + ' ' + self.new_gmsh_file
			os.system(rename_command)

			self.new_xdmf_file = self.remesh_directory + '/mesh_' + format(self.remesh_counter, '02d') + '.xdmf'
			convert_command = 'mesh-convert ' + self.new_gmsh_file + ' ' + self.new_xdmf_file
			os.system(convert_command)

			self.temp_dict['mesh_file'] = self.new_xdmf_file
			self.temp_dict['gmsh_file'] = self.new_gmsh_file

			# test, whether the same geometry is remeshed again
			if self.temp_dict['OptimizationRoutine']['iteration_counter'] == self.shape_optimization_problem.solver.iteration:
				raise Exception('Remeshing the geometry failed.')

			self.temp_dict['OptimizationRoutine']['iteration_counter'] = self.shape_optimization_problem.solver.iteration
			self.temp_dict['OptimizationRoutine']['gradient_norm_initial'] = self.shape_optimization_problem.solver.gradient_norm_initial

			self.temp_dir = self.temp_dict['temp_dir']

			with open(self.temp_dir + '/temp_dict.json', 'w') as file:
				json.dump(self.temp_dict, file)

			os.execv(sys.executable, [sys.executable] + [sys.argv[0]] + [self.temp_dir])
